{"version":3,"sources":["webpack:///x-tag-core.min.js","webpack:///webpack/bootstrap 947234f86f83a66d9b4d","webpack:///./xtag.js","webpack:///./context.js","webpack:///./polyfills/performance.js","webpack:///./polyfills/matches.js","webpack:///./polyfills/CustomEvent.js","webpack:///./polyfills/CustomEventCommon.js","webpack:///./polyfills/DOMAttrModified.js","webpack:///../~/dom-token-list-polyfill/src/token-list.js","webpack:///../~/webcomponents.js/src/WeakMap/WeakMap.js","webpack:///../~/webcomponents.js/src/MutationObserver/MutationObserver.js","webpack:///../~/webcomponents.js/src/CustomElements/base.js","webpack:///../~/webcomponents.js/src/CustomElements/traverse.js","webpack:///../~/webcomponents.js/src/CustomElements/observe.js","webpack:///../~/webcomponents.js/src/CustomElements/upgrade.js","webpack:///../~/webcomponents.js/src/CustomElements/register.js","webpack:///../~/webcomponents.js/src/CustomElements/boot.js","webpack:///../~/webcomponents.js/src/HTMLImports/base.js","webpack:///../~/webcomponents.js/src/HTMLImports/module.js","webpack:///../~/webcomponents.js/src/HTMLImports/path.js","webpack:///../~/webcomponents.js/src/HTMLImports/xhr.js","webpack:///../~/webcomponents.js/src/HTMLImports/Loader.js","webpack:///../~/webcomponents.js/src/HTMLImports/Observer.js","webpack:///../~/webcomponents.js/src/HTMLImports/parser.js","webpack:///../~/webcomponents.js/src/HTMLImports/importer.js","webpack:///../~/webcomponents.js/src/HTMLImports/dynamic.js","webpack:///../~/webcomponents.js/src/HTMLImports/boot.js","webpack:///../~/handjs/hand.base.js","webpack:///../~/x-tag/src/core.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_context","_context2","_xTagSrcCoreJs","_xTagSrcCoreJs2","Platform","xtag","context","this","eval","performance","now","nowOffset","timing","navigationStart","navigationStar","Date","indexOf","Array","prototype","proto","Element","matches","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","selector","parentNode","ownerDocument","querySelectorAll","CustomEvent","CustomEventCommon","issetCustomEvent","Boolean","document","createEvent","e","eventName","params","bubbles","cancelable","evt","initCustomEvent","detail","initEvent","Event","attrModifiedWorks","listener","htmlElement","documentElement","addEventListener","setAttribute","removeEventListener","removeAttribute","__setAttribute","attrName","newVal","prevVal","getAttribute","initMutationEvent","ADDITION","MODIFICATION","dispatchEvent","__removeAttribute","REMOVAL","DOMTokenList","el","_element","className","_classCache","i","classes","replace","split","length","push","setToClassName","join","defineElementGetter","prop","getter","get","__defineGetter__","window","slice","splice","add","token","contains","item","index","remove","toString","toggle","WeakMap","counter","name","Math","random","set","key","entry","writable","undefined","delete","has","global","scheduleCallback","observer","scheduledObservers","isScheduled","setImmediate","dispatchCallbacks","wrapIfNeeded","node","ShadowDOMPolyfill","observers","sort","o1","o2","uid_","anyNonEmpty","forEach","queue","takeRecords","removeTransientObserversFor","callback_","nodes_","registrations","registrationsTable","registration","removeTransientObservers","forEachAncestorAndObserverEnqueueRecord","target","callback","j","options","subtree","record","enqueue","JsMutationObserver","records_","uidCounter","MutationRecord","type","addedNodes","removedNodes","previousSibling","nextSibling","attributeName","attributeNamespace","oldValue","copyMutationRecord","original","getRecord","currentRecord","getRecordWithOldValue","recordWithOldValue","clearRecords","recordRepresentsCurrentMutation","selectRecord","lastRecord","newRecord","Registration","transientObservedNodes","test","navigator","userAgent","setTimeout","setImmediateQueue","sentinel","String","data","func","postMessage","observe","childList","attributes","characterData","attributeOldValue","attributeFilter","characterDataOldValue","SyntaxError","removeListeners","addListeners","disconnect","copyOfRecords","records","recordToReplaceLast","addListeners_","removeListeners_","addTransientObserver","handleEvent","stopImmediatePropagation","namespace","relatedNode","namespaceURI","attrChange","MutationEvent","prevValue","changedNode","MutationObserver","_isPolyfilled","self","CustomElements","flags","scope","addModule","initializeModules","hasNative","registerElement","isIE","useNative","register","HTMLImports","forSubtree","cb","findAllElements","forRoots","find","firstElementChild","firstChild","nodeType","Node","ELEMENT_NODE","nextElementSibling","root","shadowRoot","olderShadowRoot","forDocumentTree","doc","_forDocumentTree","processingDocuments","wrap","n","imports","IMPORT_LINK_TYPE","l","addedNode","isAttached","added","addedSubtree","upgrade","attached","deferMutation","fn","pendingMutations","isPendingMutations","takeMutations","$p","element","hasThrottledAttached","_attached","__upgraded__","__attached","attachedCallback","detachedNode","detached","_detached","detachedCallback","inDocument","DOCUMENT_FRAGMENT_NODE","host","watchShadow","__watched","dom","console","log","localName","handler","mutations","mx","d","u","URL","_URL","shift","pop","group","groupEnd","__observer","inRoot","bind","upgradeDocument","isMainDocument","upgradeDocumentTree","hasPolyfillMutations","originalCreateShadowRoot","createShadowRoot","upgradeSubtree","upgradeAll","HTMLTemplateElement","decorate","is","definition","getRegisteredDefinition","tag","upgradeWithDefinition","implementPrototype","created","__proto__","customMixin","inTarget","inSrc","inNative","used","HTMLElement","k","keys","getOwnPropertyNames","getOwnPropertyDescriptor","getPrototypeOf","createdCallback","Error","isReservedTag","create","__name","toLowerCase","lifecycle","ancestry","resolveTagName","resolvePrototypeChain","overrideAttributeApi","registerDefinition","ctor","generateConstructor","constructor","ready","_polyfilled","changeAttribute","operation","apply","arguments","newValue","attributeChangedCallback","reservedTagList","extnds","extendee","concat","a","baseTag","nativePrototype","inst","createElement","ancestor","foundPrototype","warn","instantiate","domCreateElement","registry","createElementNS","typeExtension","HTML_NAMESPACE","domCreateElementNS","wrapDomMethodToForceUpgrade","methodName","orig","isInstance","base","importNode","f","createDocumentFragment","appendChild","bootstrap","requestAnimationFrame","readyTime","elapsed","nop","unwrap","unwrapIfNeeded","__importsParsingHook","elt","readyState","eager","attachEvent","loadEvent","whenReady","rootDocument","whenDocumentReady","watchImportsLoad","isDocumentReady","requiredReadyState","checkReady","READY_EVENT","markTargetLoaded","event","__loaded","checkDone","parsedCount","importCount","allImports","loadedImports","newImports","errorImports","loadedImport","errorLoadingImport","imp","isImportLoaded","link","__importParsed","handleImports","nodes","isImport","handleImport","rel","hasShadowDOMPolyfill","currentScriptDescriptor","script","currentScript","scripts","configurable","mxns","head","getTime","CSS_URL_REGEXP","CSS_IMPORT_REGEXP","path","resolveUrlsInStyle","style","linkUrl","resolver","textContent","resolveUrlsInCssText","cssText","urlObj","r","replaceUrls","text","regexp","pre","url","post","urlPath","href","xhr","async","ok","request","status","load","next","nextContext","XMLHttpRequest","debug","bust","open","redirectedUrl","locationHeader","getResponseHeader","substr","location","origin","error","message","response","responseText","send","loadDocument","responseType","Loader","onLoad","onComplete","cache","onload","oncomplete","inflight","pending","addNodes","require","addNode","src","__nodeUrl","dedupe","fetch","tail","match","pieces","header","body","atob","decodeURIComponent","receive","receiveXhr","err","resource","Observer","addCallback","mo","children","nodeIsImport","generateScriptDataUrl","scriptContent","generateScriptContent","encodeURIComponent","generateSourceMapHint","owner","__importedScripts","moniker","baseURI","num","cloneStyle","clone","IMPORT_SELECTOR","importParser","documentSelectors","importsSelectors","map","dynamicElements","parseNext","nextToParse","parse","isParsed","markParsing","parseDynamic","quiet","parsingElement","markParsingComplete","markDynamicParsingComplete","__importElement","parseImport","__doc","__resource","__error","__pending","parseLink","linkElt","parseGeneric","parseStyle","__appliedElement","trackElement","addElementToDocument","rootImportForElement","__importLink","port","insertBefore","done","fakeLoad","sheet","csr","cssRules","len","CSSRule","IMPORT_RULE","styleSheet","parseScript","scriptElt","removeChild","_mayParse","nextToParseInDoc","nextToParseDynamic","parseSelectorsForNode","hasResource","needsDynamicParsing","parser","isImportLink","isLinkRel","hasBaseURIAccessor","makeDocument","implementation","createHTMLDocument","meta","innerHTML","importer","documents","documentPreloadSelectors","importsPreloadSelectors","loadNode","importLoader","loadSubtree","parent","marshalNodes","loadSelectorsForNode","bootDocument","loadedAll","baseURIDescriptor","querySelector","dynamic","parsed","loading","shouldLoadNode","shouldParseNode","setTouchTimer","touching","clearTimeout","touchTimer","getFirstCommonNode","x","y","dispatchPointerEnter","currentTarget","relatedTarget","generateProxy","commonParent","nodelist","checkEventRegistration","dispatchPointerLeave","applySimpleEventTunnels","nameGenerator","eventGenerator","findEventRegisteredNode","foundNode","targetNode","PointerEvent","searchElement","t","Number","Infinity","floor","abs","max","method","thisArg","Function","TypeError","trim","supportedEventsNames","upperCaseEventsNames","POINTER_TYPE_TOUCH","POINTER_TYPE_PEN","POINTER_TYPE_MOUSE","previousTargets","checkPreventDefault","handjs_forcePreventDefault","generateTouchClonedEvent","sourceEvent","newName","canBubble","evObj","initMouseEvent","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","createEventObject","offsetX","offsetY","offsetLeft","offsetTop","layerX","layerY","isPrimary","pressure","which","rotation","hwTimestamp","tiltX","tiltY","height","width","preventDefault","stopPropagation","current","pointerId","pointerType","srcElement","fireEvent","getMouseEquivalentEventName","generateMouseProxy","generateTouchEventProxy","touchPoint","eventObject","touchPointId","identifier","__handjsGlobalRegisteredEvents","generateTouchEventProxyIfRegistered","getPrefixEventName","prefix","upperCaseIndex","newEventName","registerOrUnregisterEvent","enable","__handjsRegisteredEvents","setTouchAware","MSPointerEvent","targetEvent","interceptAddEventListener","customAddEventListener","capture","interceptRemoveEventListener","customRemoveEventListener","detachEvent","isCocoonJS","HTMLBodyElement","HTMLDivElement","HTMLImageElement","HTMLUListElement","HTMLAnchorElement","HTMLLIElement","HTMLTableElement","HTMLSpanElement","HTMLCanvasElement","SVGElement","ontouchstart","changedTouches","newTarget","elementFromPoint","pointerEnabled","msPointerEnabled","maxTouchPoints","msMaxTouchPoints","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","typeOf","typeString","typeCache","typeRegexp","toArray","unsliceable","query","str","parsePseudo","mergeOne","source","merge","mergeMixin","mixin","z","__mixin__","applyPseudos","pseudos","addMixin","uniqueMixinCount","resolveMixins","mixins","output","unshift","applyMixins","delegateAction","pseudo","tagName","matchSelector","touchFilter","writeProperty","desc","enumerable","inheritEvent","skipProps","baseEvent","modAttr","attr","attrProto","syncAttr","property","attachProperties","accessor","old","hasAttribute","validate","setter","parseAccessor","accessors","attribute","regexCamelToDash","parseMultiline","unwrapComment","exec","customEvent","win","hasShadow","container","noop","trueop","regexReplaceCommas","regexPseudoParens","regexPseudoCapture","regexDigits","keypseudo","action","keyCode","styles","getComputedStyle","OLink","lowercase","css","js","toUpperCase","object","array","null","number","boolean","string","function","tags","defaultOptions","events","methods","__xtag__","_name","basePrototype","compiled","parseEvent","shadow","nodeName","createFragment","content","finalized","cloneNode","outerHTML","addEvents","hasAttr","hasDefault","def","onAdd","xtagComponentReady","inserted","removed","__parentNode__","args","attributeChanged","elementProto","reg","captureEvents","focus","blur","scroll","DOMMouseScroll","customEvents","animationstart","attach","animationend","transitionend","move","enter","leave","scrollwheel","condition","delta","wheelDelta","round","tap","custom","startX","startY","tapstart","tapend","tapmove","moveListener","addEvent","removeEvent","taphold","pointers","duration","onCompiled","returns","keypass","keyfail","delegate","preventable","defaultPrevented","v","uid","skipTransition","transitionProperty","skipFrame","requestFrame","raf","cancelFrame","cancel","cancelAnimationFrame","html","hasClass","klass","addClass","list","removeClass","filter","toggleClass","queryChildren","result","template","manipulate","returned","valueFlag","solo","onRemove","removePseudos","stack","_attach","_pseudos","chain","__stack__","cancelBubble","removeEvents"],"mappings":"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","file":"x-tag-core.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t    value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _context = __webpack_require__(1);\n\t\n\tvar _context2 = _interopRequireDefault(_context);\n\t\n\t// dom: true\n\t// data: true\n\t\n\t__webpack_require__(2);\n\t\n\t__webpack_require__(3);\n\t\n\t__webpack_require__(4);\n\t\n\t__webpack_require__(6);\n\t\n\t__webpack_require__(7);\n\t\n\t__webpack_require__(8);\n\t\n\t__webpack_require__(9);\n\t\n\t__webpack_require__(10);\n\t\n\t__webpack_require__(11);\n\t\n\t__webpack_require__(12);\n\t\n\t__webpack_require__(13);\n\t\n\t__webpack_require__(14);\n\t\n\t__webpack_require__(15);\n\t\n\t__webpack_require__(16);\n\t\n\t__webpack_require__(17);\n\t\n\t__webpack_require__(18);\n\t\n\t__webpack_require__(19);\n\t\n\t__webpack_require__(20);\n\t\n\t__webpack_require__(21);\n\t\n\t__webpack_require__(22);\n\t\n\t__webpack_require__(23);\n\t\n\t__webpack_require__(24);\n\t\n\t__webpack_require__(25);\n\t\n\t__webpack_require__(26);\n\t\n\tvar _xTagSrcCoreJs = __webpack_require__(27);\n\t\n\tvar _xTagSrcCoreJs2 = _interopRequireDefault(_xTagSrcCoreJs);\n\t\n\t_context2['default'].Platform = {};\n\t\n\t/* eslint no-unused-vars:0 */\n\tvar logFlags = {};\n\t\n\t_context2['default'].xtag = _xTagSrcCoreJs2['default'];\n\t\n\texports['default'] = _xTagSrcCoreJs2['default'];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t    value: true\n\t});\n\tvar context = (function () {\n\t    return this || (1, eval)('this');\n\t})();\n\t\n\texports['default'] = context;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _context = __webpack_require__(1);\n\t\n\tvar _context2 = _interopRequireDefault(_context);\n\t\n\tif (typeof _context2['default'].performance === 'undefined') {\n\t    _context2['default'].performance = {};\n\t}\n\t\n\tif (!_context2['default'].performance.now) {\n\t    var nowOffset;\n\t\n\t    if (_context2['default'].performance.timing && _context2['default'].performance.timing.navigationStart) {\n\t        nowOffset = _context2['default'].performance.timing.navigationStar;\n\t    } else {\n\t        nowOffset = Date.now();\n\t    }\n\t\n\t    _context2['default'].performance.now = function () {\n\t        return Date.now() - nowOffset;\n\t    };\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t    value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _context = __webpack_require__(1);\n\t\n\tvar _context2 = _interopRequireDefault(_context);\n\t\n\tvar indexOf = Array.prototype.indexOf;\n\tvar proto = _context2['default'].Element.prototype;\n\t\n\tproto.matches = proto.matches || proto.matchesSelector || proto.webkitMatchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || function (selector) {\n\t    return indexOf.call((this.parentNode || this.ownerDocument).querySelectorAll(selector), this) !== -1;\n\t};\n\t\n\texports['default'] = proto.matches;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * strange commit, checks CustomEvent only in IE\n\t * https://github.com/webcomponents/webcomponentsjs/commit/8d6a38aa6e3d03ff54a41db9e9725401bbc1446c\n\t */\n\t\n\t'use strict';\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _context = __webpack_require__(1);\n\t\n\tvar _context2 = _interopRequireDefault(_context);\n\t\n\tif (typeof _context2['default'].CustomEvent !== 'function') {\n\t  _context2['default'].CustomEvent = __webpack_require__(5);\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t    value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _context = __webpack_require__(1);\n\t\n\tvar _context2 = _interopRequireDefault(_context);\n\t\n\tvar CustomEventCommon;\n\tvar issetCustomEvent = false;\n\t\n\ttry {\n\t    issetCustomEvent = Boolean(_context2['default'].document.createEvent('CustomEvent'));\n\t} catch (e) {\n\t    // do nothing\n\t}\n\t\n\tif (issetCustomEvent) {\n\t    CustomEventCommon = function (eventName, params) {\n\t        params = params || {};\n\t\n\t        var bubbles = Boolean(params.bubbles);\n\t        var cancelable = Boolean(params.cancelable);\n\t        var evt = _context2['default'].document.createEvent('CustomEvent');\n\t\n\t        evt.initCustomEvent(eventName, bubbles, cancelable, params.detail);\n\t\n\t        return evt;\n\t    };\n\t} else {\n\t    CustomEventCommon = function (eventName, params) {\n\t        params = params || {};\n\t\n\t        var bubbles = Boolean(params.bubbles);\n\t        var cancelable = Boolean(params.cancelable);\n\t        var evt = _context2['default'].document.createEvent('Event');\n\t\n\t        evt.initEvent(eventName, bubbles, cancelable);\n\t        evt.detail = params.detail;\n\t\n\t        return evt;\n\t    };\n\t}\n\t\n\tCustomEventCommon.prototype = _context2['default'].Event.prototype;\n\t\n\texports['default'] = CustomEventCommon;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @see http://engineering.silk.co/post/31921750832/mutation-events-what-happens\n\t */\n\t\n\t'use strict';\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _context = __webpack_require__(1);\n\t\n\tvar _context2 = _interopRequireDefault(_context);\n\t\n\tvar attrModifiedWorks = false;\n\tvar listener = function listener() {\n\t    attrModifiedWorks = true;\n\t};\n\t\n\tvar htmlElement = _context2['default'].document.documentElement;\n\thtmlElement.addEventListener('DOMAttrModified', listener, false);\n\thtmlElement.setAttribute('___TEST___', true);\n\thtmlElement.removeEventListener('DOMAttrModified', listener, false);\n\thtmlElement.removeAttribute('___TEST___', true);\n\t\n\tif (!attrModifiedWorks) {\n\t    var proto = _context2['default'].Element.prototype;\n\t\n\t    proto.__setAttribute = proto.setAttribute;\n\t    proto.setAttribute = function (attrName, newVal) {\n\t        var prevVal = this.getAttribute(attrName);\n\t        this.__setAttribute(attrName, newVal);\n\t        newVal = this.getAttribute(attrName);\n\t        if (newVal !== prevVal) {\n\t            var evt = _context2['default'].document.createEvent('MutationEvent');\n\t            evt.initMutationEvent('DOMAttrModified', true, false, this, prevVal || '', newVal || '', attrName, prevVal === null ? evt.ADDITION : evt.MODIFICATION);\n\t            this.dispatchEvent(evt);\n\t        }\n\t    };\n\t\n\t    proto.__removeAttribute = proto.removeAttribute;\n\t    proto.removeAttribute = function (attrName) {\n\t        var prevVal = this.getAttribute(attrName);\n\t        this.__removeAttribute(attrName);\n\t        var evt = _context2['default'].document.createEvent('MutationEvent');\n\t        evt.initMutationEvent('DOMAttrModified', true, false, this, prevVal, '', attrName, evt.REMOVAL);\n\t        this.dispatchEvent(evt);\n\t    };\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t// DOMTokenList polyfill for IE9\n\t(function () {\n\t\n\tif (typeof window.Element === \"undefined\" || \"classList\" in document.documentElement) return;\n\t\n\tvar prototype = Array.prototype,\n\t    indexOf = prototype.indexOf,\n\t    slice = prototype.slice,\n\t    push = prototype.push,\n\t    splice = prototype.splice,\n\t    join = prototype.join;\n\t\n\tfunction DOMTokenList(el) {\n\t  this._element = el;\n\t  if (el.className != this._classCache) {\n\t    this._classCache = el.className;\n\t\n\t    if (!this._classCache) return;\n\t\n\t      // The className needs to be trimmed and split on whitespace\n\t      // to retrieve a list of classes.\n\t      var classes = this._classCache.replace(/^\\s+|\\s+$/g,'').split(/\\s+/),\n\t        i;\n\t    for (i = 0; i < classes.length; i++) {\n\t      push.call(this, classes[i]);\n\t    }\n\t  }\n\t};\n\t\n\tfunction setToClassName(el, classes) {\n\t  el.className = classes.join(' ');\n\t}\n\t\n\tDOMTokenList.prototype = {\n\t  add: function(token) {\n\t    if(this.contains(token)) return;\n\t    push.call(this, token);\n\t    setToClassName(this._element, slice.call(this, 0));\n\t  },\n\t  contains: function(token) {\n\t    return indexOf.call(this, token) !== -1;\n\t  },\n\t  item: function(index) {\n\t    return this[index] || null;\n\t  },\n\t  remove: function(token) {\n\t    var i = indexOf.call(this, token);\n\t     if (i === -1) {\n\t       return;\n\t     }\n\t    splice.call(this, i, 1);\n\t    setToClassName(this._element, slice.call(this, 0));\n\t  },\n\t  toString: function() {\n\t    return join.call(this, ' ');\n\t  },\n\t  toggle: function(token) {\n\t    if (indexOf.call(this, token) === -1) {\n\t      this.add(token);\n\t    } else {\n\t      this.remove(token);\n\t    }\n\t  }\n\t};\n\t\n\twindow.DOMTokenList = DOMTokenList;\n\t\n\tfunction defineElementGetter (obj, prop, getter) {\n\t  if (Object.defineProperty) {\n\t    Object.defineProperty(obj, prop,{\n\t      get : getter\n\t    })\n\t  } else {\n\t    obj.__defineGetter__(prop, getter);\n\t  }\n\t}\n\t\n\tdefineElementGetter(Element.prototype, 'classList', function () {\n\t  return new DOMTokenList(this);\n\t});\n\t\n\t})();\n\t\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\t\n\tif (typeof WeakMap === 'undefined') {\n\t  (function() {\n\t    var defineProperty = Object.defineProperty;\n\t    var counter = Date.now() % 1e9;\n\t\n\t    var WeakMap = function() {\n\t      this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');\n\t    };\n\t\n\t    WeakMap.prototype = {\n\t      set: function(key, value) {\n\t        var entry = key[this.name];\n\t        if (entry && entry[0] === key)\n\t          entry[1] = value;\n\t        else\n\t          defineProperty(key, this.name, {value: [key, value], writable: true});\n\t        return this;\n\t      },\n\t      get: function(key) {\n\t        var entry;\n\t        return (entry = key[this.name]) && entry[0] === key ?\n\t            entry[1] : undefined;\n\t      },\n\t      delete: function(key) {\n\t        var entry = key[this.name];\n\t        if (!entry || entry[0] !== key) return false;\n\t        entry[0] = entry[1] = undefined;\n\t        return true;\n\t      },\n\t      has: function(key) {\n\t        var entry = key[this.name];\n\t        if (!entry) return false;\n\t        return entry[0] === key;\n\t      }\n\t    };\n\t\n\t    window.WeakMap = WeakMap;\n\t  })();\n\t}\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\t\n\t(function(global) {\n\t\n\t  // Don't allow this object to be redefined.\n\t  if (global.JsMutationObserver) {\n\t    return;\n\t  }\n\t\n\t  var registrationsTable = new WeakMap();\n\t\n\t  var setImmediate;\n\t\n\t  // As much as we would like to use the native implementation, IE\n\t  // (all versions) suffers a rather annoying bug where it will drop or defer\n\t  // callbacks when heavy DOM operations are being performed concurrently.\n\t  //\n\t  // For a thorough discussion on this, see:\n\t  // http://codeforhire.com/2013/09/21/setimmediate-and-messagechannel-broken-on-internet-explorer-10/\n\t  if (/Trident|Edge/.test(navigator.userAgent)) {\n\t    // Sadly, this bug also affects postMessage and MessageQueues.\n\t    //\n\t    // We would like to use the onreadystatechange hack for IE <= 10, but it is\n\t    // dangerous in the polyfilled environment due to requiring that the\n\t    // observed script element be in the document.\n\t    setImmediate = setTimeout;\n\t\n\t  // If some other browser ever implements it, let's prefer their native\n\t  // implementation:\n\t  } else if (window.setImmediate) {\n\t    setImmediate = window.setImmediate;\n\t\n\t  // Otherwise, we fall back to postMessage as a means of emulating the next\n\t  // task semantics of setImmediate.\n\t  } else {\n\t    var setImmediateQueue = [];\n\t    var sentinel = String(Math.random());\n\t    window.addEventListener('message', function(e) {\n\t      if (e.data === sentinel) {\n\t        var queue = setImmediateQueue;\n\t        setImmediateQueue = [];\n\t        queue.forEach(function(func) {\n\t          func();\n\t        });\n\t      }\n\t    });\n\t    setImmediate = function(func) {\n\t      setImmediateQueue.push(func);\n\t      window.postMessage(sentinel, '*');\n\t    };\n\t  }\n\t\n\t  // This is used to ensure that we never schedule 2 callas to setImmediate\n\t  var isScheduled = false;\n\t\n\t  // Keep track of observers that needs to be notified next time.\n\t  var scheduledObservers = [];\n\t\n\t  /**\n\t   * Schedules |dispatchCallback| to be called in the future.\n\t   * @param {MutationObserver} observer\n\t   */\n\t  function scheduleCallback(observer) {\n\t    scheduledObservers.push(observer);\n\t    if (!isScheduled) {\n\t      isScheduled = true;\n\t      setImmediate(dispatchCallbacks);\n\t    }\n\t  }\n\t\n\t  function wrapIfNeeded(node) {\n\t    return window.ShadowDOMPolyfill &&\n\t        window.ShadowDOMPolyfill.wrapIfNeeded(node) ||\n\t        node;\n\t  }\n\t\n\t  function dispatchCallbacks() {\n\t    // http://dom.spec.whatwg.org/#mutation-observers\n\t\n\t    isScheduled = false; // Used to allow a new setImmediate call above.\n\t\n\t    var observers = scheduledObservers;\n\t    scheduledObservers = [];\n\t    // Sort observers based on their creation UID (incremental).\n\t    observers.sort(function(o1, o2) {\n\t      return o1.uid_ - o2.uid_;\n\t    });\n\t\n\t    var anyNonEmpty = false;\n\t    observers.forEach(function(observer) {\n\t\n\t      // 2.1, 2.2\n\t      var queue = observer.takeRecords();\n\t      // 2.3. Remove all transient registered observers whose observer is mo.\n\t      removeTransientObserversFor(observer);\n\t\n\t      // 2.4\n\t      if (queue.length) {\n\t        observer.callback_(queue, observer);\n\t        anyNonEmpty = true;\n\t      }\n\t    });\n\t\n\t    // 3.\n\t    if (anyNonEmpty)\n\t      dispatchCallbacks();\n\t  }\n\t\n\t  function removeTransientObserversFor(observer) {\n\t    observer.nodes_.forEach(function(node) {\n\t      var registrations = registrationsTable.get(node);\n\t      if (!registrations)\n\t        return;\n\t      registrations.forEach(function(registration) {\n\t        if (registration.observer === observer)\n\t          registration.removeTransientObservers();\n\t      });\n\t    });\n\t  }\n\t\n\t  /**\n\t   * This function is used for the \"For each registered observer observer (with\n\t   * observer's options as options) in target's list of registered observers,\n\t   * run these substeps:\" and the \"For each ancestor ancestor of target, and for\n\t   * each registered observer observer (with options options) in ancestor's list\n\t   * of registered observers, run these substeps:\" part of the algorithms. The\n\t   * |options.subtree| is checked to ensure that the callback is called\n\t   * correctly.\n\t   *\n\t   * @param {Node} target\n\t   * @param {function(MutationObserverInit):MutationRecord} callback\n\t   */\n\t  function forEachAncestorAndObserverEnqueueRecord(target, callback) {\n\t    for (var node = target; node; node = node.parentNode) {\n\t      var registrations = registrationsTable.get(node);\n\t\n\t      if (registrations) {\n\t        for (var j = 0; j < registrations.length; j++) {\n\t          var registration = registrations[j];\n\t          var options = registration.options;\n\t\n\t          // Only target ignores subtree.\n\t          if (node !== target && !options.subtree)\n\t            continue;\n\t\n\t          var record = callback(options);\n\t          if (record)\n\t            registration.enqueue(record);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  var uidCounter = 0;\n\t\n\t  /**\n\t   * The class that maps to the DOM MutationObserver interface.\n\t   * @param {Function} callback.\n\t   * @constructor\n\t   */\n\t  function JsMutationObserver(callback) {\n\t    this.callback_ = callback;\n\t    this.nodes_ = [];\n\t    this.records_ = [];\n\t    this.uid_ = ++uidCounter;\n\t  }\n\t\n\t  JsMutationObserver.prototype = {\n\t    observe: function(target, options) {\n\t      target = wrapIfNeeded(target);\n\t\n\t      // 1.1\n\t      if (!options.childList && !options.attributes && !options.characterData ||\n\t\n\t          // 1.2\n\t          options.attributeOldValue && !options.attributes ||\n\t\n\t          // 1.3\n\t          options.attributeFilter && options.attributeFilter.length &&\n\t              !options.attributes ||\n\t\n\t          // 1.4\n\t          options.characterDataOldValue && !options.characterData) {\n\t\n\t        throw new SyntaxError();\n\t      }\n\t\n\t      var registrations = registrationsTable.get(target);\n\t      if (!registrations)\n\t        registrationsTable.set(target, registrations = []);\n\t\n\t      // 2\n\t      // If target's list of registered observers already includes a registered\n\t      // observer associated with the context object, replace that registered\n\t      // observer's options with options.\n\t      var registration;\n\t      for (var i = 0; i < registrations.length; i++) {\n\t        if (registrations[i].observer === this) {\n\t          registration = registrations[i];\n\t          registration.removeListeners();\n\t          registration.options = options;\n\t          break;\n\t        }\n\t      }\n\t\n\t      // 3.\n\t      // Otherwise, add a new registered observer to target's list of registered\n\t      // observers with the context object as the observer and options as the\n\t      // options, and add target to context object's list of nodes on which it\n\t      // is registered.\n\t      if (!registration) {\n\t        registration = new Registration(this, target, options);\n\t        registrations.push(registration);\n\t        this.nodes_.push(target);\n\t      }\n\t\n\t      registration.addListeners();\n\t    },\n\t\n\t    disconnect: function() {\n\t      this.nodes_.forEach(function(node) {\n\t        var registrations = registrationsTable.get(node);\n\t        for (var i = 0; i < registrations.length; i++) {\n\t          var registration = registrations[i];\n\t          if (registration.observer === this) {\n\t            registration.removeListeners();\n\t            registrations.splice(i, 1);\n\t            // Each node can only have one registered observer associated with\n\t            // this observer.\n\t            break;\n\t          }\n\t        }\n\t      }, this);\n\t      this.records_ = [];\n\t    },\n\t\n\t    takeRecords: function() {\n\t      var copyOfRecords = this.records_;\n\t      this.records_ = [];\n\t      return copyOfRecords;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * @param {string} type\n\t   * @param {Node} target\n\t   * @constructor\n\t   */\n\t  function MutationRecord(type, target) {\n\t    this.type = type;\n\t    this.target = target;\n\t    this.addedNodes = [];\n\t    this.removedNodes = [];\n\t    this.previousSibling = null;\n\t    this.nextSibling = null;\n\t    this.attributeName = null;\n\t    this.attributeNamespace = null;\n\t    this.oldValue = null;\n\t  }\n\t\n\t  function copyMutationRecord(original) {\n\t    var record = new MutationRecord(original.type, original.target);\n\t    record.addedNodes = original.addedNodes.slice();\n\t    record.removedNodes = original.removedNodes.slice();\n\t    record.previousSibling = original.previousSibling;\n\t    record.nextSibling = original.nextSibling;\n\t    record.attributeName = original.attributeName;\n\t    record.attributeNamespace = original.attributeNamespace;\n\t    record.oldValue = original.oldValue;\n\t    return record;\n\t  };\n\t\n\t  // We keep track of the two (possibly one) records used in a single mutation.\n\t  var currentRecord, recordWithOldValue;\n\t\n\t  /**\n\t   * Creates a record without |oldValue| and caches it as |currentRecord| for\n\t   * later use.\n\t   * @param {string} oldValue\n\t   * @return {MutationRecord}\n\t   */\n\t  function getRecord(type, target) {\n\t    return currentRecord = new MutationRecord(type, target);\n\t  }\n\t\n\t  /**\n\t   * Gets or creates a record with |oldValue| based in the |currentRecord|\n\t   * @param {string} oldValue\n\t   * @return {MutationRecord}\n\t   */\n\t  function getRecordWithOldValue(oldValue) {\n\t    if (recordWithOldValue)\n\t      return recordWithOldValue;\n\t    recordWithOldValue = copyMutationRecord(currentRecord);\n\t    recordWithOldValue.oldValue = oldValue;\n\t    return recordWithOldValue;\n\t  }\n\t\n\t  function clearRecords() {\n\t    currentRecord = recordWithOldValue = undefined;\n\t  }\n\t\n\t  /**\n\t   * @param {MutationRecord} record\n\t   * @return {boolean} Whether the record represents a record from the current\n\t   * mutation event.\n\t   */\n\t  function recordRepresentsCurrentMutation(record) {\n\t    return record === recordWithOldValue || record === currentRecord;\n\t  }\n\t\n\t  /**\n\t   * Selects which record, if any, to replace the last record in the queue.\n\t   * This returns |null| if no record should be replaced.\n\t   *\n\t   * @param {MutationRecord} lastRecord\n\t   * @param {MutationRecord} newRecord\n\t   * @param {MutationRecord}\n\t   */\n\t  function selectRecord(lastRecord, newRecord) {\n\t    if (lastRecord === newRecord)\n\t      return lastRecord;\n\t\n\t    // Check if the the record we are adding represents the same record. If\n\t    // so, we keep the one with the oldValue in it.\n\t    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))\n\t      return recordWithOldValue;\n\t\n\t    return null;\n\t  }\n\t\n\t  /**\n\t   * Class used to represent a registered observer.\n\t   * @param {MutationObserver} observer\n\t   * @param {Node} target\n\t   * @param {MutationObserverInit} options\n\t   * @constructor\n\t   */\n\t  function Registration(observer, target, options) {\n\t    this.observer = observer;\n\t    this.target = target;\n\t    this.options = options;\n\t    this.transientObservedNodes = [];\n\t  }\n\t\n\t  Registration.prototype = {\n\t    enqueue: function(record) {\n\t      var records = this.observer.records_;\n\t      var length = records.length;\n\t\n\t      // There are cases where we replace the last record with the new record.\n\t      // For example if the record represents the same mutation we need to use\n\t      // the one with the oldValue. If we get same record (this can happen as we\n\t      // walk up the tree) we ignore the new record.\n\t      if (records.length > 0) {\n\t        var lastRecord = records[length - 1];\n\t        var recordToReplaceLast = selectRecord(lastRecord, record);\n\t        if (recordToReplaceLast) {\n\t          records[length - 1] = recordToReplaceLast;\n\t          return;\n\t        }\n\t      } else {\n\t        scheduleCallback(this.observer);\n\t      }\n\t\n\t      records[length] = record;\n\t    },\n\t\n\t    addListeners: function() {\n\t      this.addListeners_(this.target);\n\t    },\n\t\n\t    addListeners_: function(node) {\n\t      var options = this.options;\n\t      if (options.attributes)\n\t        node.addEventListener('DOMAttrModified', this, true);\n\t\n\t      if (options.characterData)\n\t        node.addEventListener('DOMCharacterDataModified', this, true);\n\t\n\t      if (options.childList)\n\t        node.addEventListener('DOMNodeInserted', this, true);\n\t\n\t      if (options.childList || options.subtree)\n\t        node.addEventListener('DOMNodeRemoved', this, true);\n\t    },\n\t\n\t    removeListeners: function() {\n\t      this.removeListeners_(this.target);\n\t    },\n\t\n\t    removeListeners_: function(node) {\n\t      var options = this.options;\n\t      if (options.attributes)\n\t        node.removeEventListener('DOMAttrModified', this, true);\n\t\n\t      if (options.characterData)\n\t        node.removeEventListener('DOMCharacterDataModified', this, true);\n\t\n\t      if (options.childList)\n\t        node.removeEventListener('DOMNodeInserted', this, true);\n\t\n\t      if (options.childList || options.subtree)\n\t        node.removeEventListener('DOMNodeRemoved', this, true);\n\t    },\n\t\n\t    /**\n\t     * Adds a transient observer on node. The transient observer gets removed\n\t     * next time we deliver the change records.\n\t     * @param {Node} node\n\t     */\n\t    addTransientObserver: function(node) {\n\t      // Don't add transient observers on the target itself. We already have all\n\t      // the required listeners set up on the target.\n\t      if (node === this.target)\n\t        return;\n\t\n\t      this.addListeners_(node);\n\t      this.transientObservedNodes.push(node);\n\t      var registrations = registrationsTable.get(node);\n\t      if (!registrations)\n\t        registrationsTable.set(node, registrations = []);\n\t\n\t      // We know that registrations does not contain this because we already\n\t      // checked if node === this.target.\n\t      registrations.push(this);\n\t    },\n\t\n\t    removeTransientObservers: function() {\n\t      var transientObservedNodes = this.transientObservedNodes;\n\t      this.transientObservedNodes = [];\n\t\n\t      transientObservedNodes.forEach(function(node) {\n\t        // Transient observers are never added to the target.\n\t        this.removeListeners_(node);\n\t\n\t        var registrations = registrationsTable.get(node);\n\t        for (var i = 0; i < registrations.length; i++) {\n\t          if (registrations[i] === this) {\n\t            registrations.splice(i, 1);\n\t            // Each node can only have one registered observer associated with\n\t            // this observer.\n\t            break;\n\t          }\n\t        }\n\t      }, this);\n\t    },\n\t\n\t    handleEvent: function(e) {\n\t      // Stop propagation since we are managing the propagation manually.\n\t      // This means that other mutation events on the page will not work\n\t      // correctly but that is by design.\n\t      e.stopImmediatePropagation();\n\t\n\t      switch (e.type) {\n\t        case 'DOMAttrModified':\n\t          // http://dom.spec.whatwg.org/#concept-mo-queue-attributes\n\t\n\t          var name = e.attrName;\n\t          var namespace = e.relatedNode.namespaceURI;\n\t          var target = e.target;\n\t\n\t          // 1.\n\t          var record = new getRecord('attributes', target);\n\t          record.attributeName = name;\n\t          record.attributeNamespace = namespace;\n\t\n\t          // 2.\n\t          var oldValue =\n\t              e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n\t\n\t          forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n\t            // 3.1, 4.2\n\t            if (!options.attributes)\n\t              return;\n\t\n\t            // 3.2, 4.3\n\t            if (options.attributeFilter && options.attributeFilter.length &&\n\t                options.attributeFilter.indexOf(name) === -1 &&\n\t                options.attributeFilter.indexOf(namespace) === -1) {\n\t              return;\n\t            }\n\t            // 3.3, 4.4\n\t            if (options.attributeOldValue)\n\t              return getRecordWithOldValue(oldValue);\n\t\n\t            // 3.4, 4.5\n\t            return record;\n\t          });\n\t\n\t          break;\n\t\n\t        case 'DOMCharacterDataModified':\n\t          // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata\n\t          var target = e.target;\n\t\n\t          // 1.\n\t          var record = getRecord('characterData', target);\n\t\n\t          // 2.\n\t          var oldValue = e.prevValue;\n\t\n\t\n\t          forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n\t            // 3.1, 4.2\n\t            if (!options.characterData)\n\t              return;\n\t\n\t            // 3.2, 4.3\n\t            if (options.characterDataOldValue)\n\t              return getRecordWithOldValue(oldValue);\n\t\n\t            // 3.3, 4.4\n\t            return record;\n\t          });\n\t\n\t          break;\n\t\n\t        case 'DOMNodeRemoved':\n\t          this.addTransientObserver(e.target);\n\t          // Fall through.\n\t        case 'DOMNodeInserted':\n\t          // http://dom.spec.whatwg.org/#concept-mo-queue-childlist\n\t          var changedNode = e.target;\n\t          var addedNodes, removedNodes;\n\t          if (e.type === 'DOMNodeInserted') {\n\t            addedNodes = [changedNode];\n\t            removedNodes = [];\n\t          } else {\n\t\n\t            addedNodes = [];\n\t            removedNodes = [changedNode];\n\t          }\n\t          var previousSibling = changedNode.previousSibling;\n\t          var nextSibling = changedNode.nextSibling;\n\t\n\t          // 1.\n\t          var record = getRecord('childList', e.target.parentNode);\n\t          record.addedNodes = addedNodes;\n\t          record.removedNodes = removedNodes;\n\t          record.previousSibling = previousSibling;\n\t          record.nextSibling = nextSibling;\n\t\n\t          forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {\n\t            // 2.1, 3.2\n\t            if (!options.childList)\n\t              return;\n\t\n\t            // 2.2, 3.3\n\t            return record;\n\t          });\n\t\n\t      }\n\t\n\t      clearRecords();\n\t    }\n\t  };\n\t\n\t  global.JsMutationObserver = JsMutationObserver;\n\t\n\t  if (!global.MutationObserver) {\n\t    global.MutationObserver = JsMutationObserver;\n\t    // Explicltly mark MO as polyfilled for user reference.\n\t    JsMutationObserver._isPolyfilled = true;\n\t  }\n\t\n\t})(self);\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\twindow.CustomElements = window.CustomElements || {flags:{}};\n\t\n\t(function(scope) {\n\t\n\t// imports\n\tvar flags = scope.flags;\n\t\n\t// world's simplest module initializer\n\tvar modules = [];\n\tvar addModule = function(module) {\n\t\tmodules.push(module);\n\t};\n\t\n\tvar initializeModules = function() {\n\t\tmodules.forEach(function(module) {\n\t\t\tmodule(scope);\n\t\t});\n\t};\n\t\n\t// exports\n\tscope.addModule = addModule;\n\tscope.initializeModules = initializeModules;\n\tscope.hasNative = Boolean(document.registerElement);\n\tscope.isIE = /Trident/.test(navigator.userAgent);\n\t\n\t// NOTE: For consistent timing, use native custom elements only when not\n\t// polyfilling other key related web components features.\n\tscope.useNative = !flags.register && scope.hasNative &&\n\t\t\t!window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);\n\t\n\t})(window.CustomElements);\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\t\n\t// helper methods for traversing through element trees\n\twindow.CustomElements.addModule(function(scope){\n\t\n\t// imports\n\tvar IMPORT_LINK_TYPE = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : 'none';\n\t\n\t// walk the subtree rooted at node, including descent into shadow-roots,\n\t// applying 'cb' to each element\n\tfunction forSubtree(node, cb) {\n\t  //flags.dom && node.childNodes && node.childNodes.length && console.group('subTree: ', node);\n\t  findAllElements(node, function(e) {\n\t    if (cb(e)) {\n\t      return true;\n\t    }\n\t    forRoots(e, cb);\n\t  });\n\t  forRoots(node, cb);\n\t  //flags.dom && node.childNodes && node.childNodes.length && console.groupEnd();\n\t}\n\t\n\t\n\t// walk the subtree rooted at node, applying 'find(element, data)' function\n\t// to each element\n\t// if 'find' returns true for 'element', do not search element's subtree\n\tfunction findAllElements(node, find, data) {\n\t  var e = node.firstElementChild;\n\t  if (!e) {\n\t    e = node.firstChild;\n\t    while (e && e.nodeType !== Node.ELEMENT_NODE) {\n\t      e = e.nextSibling;\n\t    }\n\t  }\n\t  while (e) {\n\t    if (find(e, data) !== true) {\n\t      findAllElements(e, find, data);\n\t    }\n\t    e = e.nextElementSibling;\n\t  }\n\t  return null;\n\t}\n\t\n\t// walk all shadowRoots on a given node.\n\tfunction forRoots(node, cb) {\n\t  var root = node.shadowRoot;\n\t  while(root) {\n\t    forSubtree(root, cb);\n\t    root = root.olderShadowRoot;\n\t  }\n\t}\n\t\n\tfunction forDocumentTree(doc, cb) {\n\t  _forDocumentTree(doc, cb, []);\n\t}\n\t\n\t\n\tfunction _forDocumentTree(doc, cb, processingDocuments) {\n\t  doc = window.wrap(doc);\n\t  if (processingDocuments.indexOf(doc) >= 0) {\n\t    return;\n\t  }\n\t  processingDocuments.push(doc);\n\t  var imports = doc.querySelectorAll('link[rel=' + IMPORT_LINK_TYPE + ']');\n\t  for (var i=0, l=imports.length, n; (i<l) && (n=imports[i]); i++) {\n\t    if (n.import) {\n\t      _forDocumentTree(n.import, cb, processingDocuments);\n\t    }\n\t  }\n\t  cb(doc);\n\t}\n\t\n\t// exports\n\tscope.forDocumentTree = forDocumentTree;\n\tscope.forSubtree = forSubtree;\n\t\n\t\n\t});\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\t\n\t/**\n\t * Implements custom element observation and attached/detached callbacks\n\t * @module observe\n\t*/\n\t\n\twindow.CustomElements.addModule(function(scope){\n\t\n\t// imports\n\tvar flags = scope.flags;\n\tvar forSubtree = scope.forSubtree;\n\tvar forDocumentTree = scope.forDocumentTree;\n\t\n\t/*\n\t  Manage nodes attached to document trees\n\t*/\n\t\n\t// manage lifecycle on added node and it's subtree; upgrade the node and\n\t// entire subtree if necessary and process attached for the node and entire\n\t// subtree\n\tfunction addedNode(node, isAttached) {\n\t  return added(node, isAttached) || addedSubtree(node, isAttached);\n\t}\n\t\n\t// manage lifecycle on added node; upgrade if necessary and process attached\n\tfunction added(node, isAttached) {\n\t  if (scope.upgrade(node, isAttached)) {\n\t    // Return true to indicate\n\t    return true;\n\t  }\n\t  if (isAttached) {\n\t    attached(node);\n\t  }\n\t}\n\t\n\t// manage lifecycle on added node's subtree only; allows the entire subtree\n\t// to upgrade if necessary and process attached\n\tfunction addedSubtree(node, isAttached) {\n\t  forSubtree(node, function(e) {\n\t    if (added(e, isAttached)) {\n\t      return true;\n\t    }\n\t  });\n\t}\n\t\n\t// On platforms without MutationObserver, mutations may not be\n\t// reliable and therefore attached/detached are not reliable. We think this\n\t// occurs sometimes under heavy DOM operation load, but it is not easy to\n\t// reproduce.\n\t// To make these callbacks less likely to fail in this scenario,\n\t// we *optionally* defer all inserts and removes\n\t// to give a chance for elements to be attached into dom.\n\t// This helps ensure attachedCallback fires for elements that are created and\n\t// immediately added to dom.\n\t// This change can significantly alter the performance characteristics\n\t// of attaching elements and therefore we only enable it if the user has\n\t// explicitly provided the `throttle-attached` flag.\n\tvar hasThrottledAttached = (window.MutationObserver._isPolyfilled &&\n\t    flags['throttle-attached']);\n\t// bc\n\tscope.hasPolyfillMutations = hasThrottledAttached;\n\t// exposed for testing\n\tscope.hasThrottledAttached = hasThrottledAttached;\n\t\n\tvar isPendingMutations = false;\n\tvar pendingMutations = [];\n\tfunction deferMutation(fn) {\n\t  pendingMutations.push(fn);\n\t  if (!isPendingMutations) {\n\t    isPendingMutations = true;\n\t    setTimeout(takeMutations);\n\t  }\n\t}\n\t\n\tfunction takeMutations() {\n\t  isPendingMutations = false;\n\t  var $p = pendingMutations;\n\t  for (var i=0, l=$p.length, p; (i<l) && (p=$p[i]); i++) {\n\t    p();\n\t  }\n\t  pendingMutations = [];\n\t}\n\t\n\tfunction attached(element) {\n\t  if (hasThrottledAttached) {\n\t    deferMutation(function() {\n\t      _attached(element);\n\t    });\n\t  } else {\n\t    _attached(element);\n\t  }\n\t}\n\t\n\t// NOTE: due to how MO works (see comments below), an element may be attached\n\t// multiple times so we protect against extra processing here.\n\tfunction _attached(element) {\n\t  // track element for insertion if it's upgraded and cares about insertion\n\t  // bail if the element is already marked as attached\n\t  if (element.__upgraded__ && !element.__attached) {\n\t    element.__attached = true;\n\t    if (element.attachedCallback) {\n\t      element.attachedCallback();\n\t    }\n\t  }\n\t}\n\t\n\t/*\n\t  Manage nodes detached from document trees\n\t*/\n\t\n\t// manage lifecycle on detached node and it's subtree; process detached\n\t// for the node and entire subtree\n\tfunction detachedNode(node) {\n\t  detached(node);\n\t  forSubtree(node, function(e) {\n\t    detached(e);\n\t  });\n\t}\n\t\n\tfunction detached(element) {\n\t  if (hasThrottledAttached) {\n\t    deferMutation(function() {\n\t      _detached(element);\n\t    });\n\t  } else {\n\t    _detached(element);\n\t  }\n\t}\n\t\n\t// NOTE: due to how MO works (see comments below), an element may be detached\n\t// multiple times so we protect against extra processing here.\n\tfunction _detached(element) {\n\t  // track element for removal if it's upgraded and cares about removal\n\t  // bail if the element is already marked as not attached\n\t  if (element.__upgraded__ && element.__attached) {\n\t    element.__attached = false;\n\t    if (element.detachedCallback) {\n\t      element.detachedCallback();\n\t    }\n\t  }\n\t}\n\t\n\t// recurse up the tree to check if an element is actually in the main document.\n\tfunction inDocument(element) {\n\t  var p = element;\n\t  var doc = window.wrap(document);\n\t  while (p) {\n\t    if (p == doc) {\n\t      return true;\n\t    }\n\t    p = p.parentNode || ((p.nodeType === Node.DOCUMENT_FRAGMENT_NODE) && p.host);\n\t  }\n\t}\n\t\n\t//  Install an element observer on all shadowRoots owned by node.\n\tfunction watchShadow(node) {\n\t  if (node.shadowRoot && !node.shadowRoot.__watched) {\n\t    flags.dom && console.log('watching shadow-root for: ', node.localName);\n\t    // watch all unwatched roots...\n\t    var root = node.shadowRoot;\n\t    while (root) {\n\t      observe(root);\n\t      root = root.olderShadowRoot;\n\t    }\n\t  }\n\t}\n\t\n\t/*\n\t  NOTE: In order to process all mutations, it's necessary to recurse into\n\t  any added nodes. However, it's not possible to determine a priori if a node\n\t  will get its own mutation record. This means\n\t  *nodes can be seen multiple times*.\n\t\n\t  Here's an example:\n\t\n\t  (1) In this case, recursion is required to see `child`:\n\t\n\t      node.innerHTML = '<div><child></child></div>'\n\t\n\t  (2) In this case, child will get its own mutation record:\n\t\n\t      node.appendChild(div).appendChild(child);\n\t\n\t  We cannot know ahead of time if we need to walk into the node in (1) so we\n\t  do and see child; however, if it was added via case (2) then it will have its\n\t  own record and therefore be seen 2x.\n\t*/\n\tfunction handler(root, mutations) {\n\t  // for logging only\n\t  if (flags.dom) {\n\t    var mx = mutations[0];\n\t    if (mx && mx.type === 'childList' && mx.addedNodes) {\n\t        if (mx.addedNodes) {\n\t          var d = mx.addedNodes[0];\n\t          while (d && d !== document && !d.host) {\n\t            d = d.parentNode;\n\t          }\n\t          var u = d && (d.URL || d._URL || (d.host && d.host.localName)) || '';\n\t          u = u.split('/?').shift().split('/').pop();\n\t        }\n\t    }\n\t    console.group('mutations (%d) [%s]', mutations.length, u || '');\n\t  }\n\t  // handle mutations\n\t  // NOTE: do an `inDocument` check dynamically here. It's possible that `root`\n\t  // is a document in which case the answer here can never change; however\n\t  // `root` may be an element like a shadowRoot that can be added/removed\n\t  // from the main document.\n\t  var isAttached = inDocument(root);\n\t  mutations.forEach(function(mx) {\n\t    if (mx.type === 'childList') {\n\t      forEach(mx.addedNodes, function(n) {\n\t        if (!n.localName) {\n\t          return;\n\t        }\n\t        addedNode(n, isAttached);\n\t      });\n\t      forEach(mx.removedNodes, function(n) {\n\t        if (!n.localName) {\n\t          return;\n\t        }\n\t        detachedNode(n);\n\t      });\n\t    }\n\t  });\n\t  flags.dom && console.groupEnd();\n\t};\n\t\n\t\n\t/*\n\t  When elements are added to the dom, upgrade and attached/detached may be\n\t  asynchronous. `CustomElements.takeRecords` can be called to process any\n\t  pending upgrades and attached/detached callbacks synchronously.\n\t*/\n\tfunction takeRecords(node) {\n\t  node = window.wrap(node);\n\t  // If the optional node is not supplied, assume we mean the whole document.\n\t  if (!node) {\n\t    node = window.wrap(document);\n\t  }\n\t  // Find the root of the tree, which will be an Document or ShadowRoot.\n\t  while (node.parentNode) {\n\t    node = node.parentNode;\n\t  }\n\t  var observer = node.__observer;\n\t  if (observer) {\n\t    handler(node, observer.takeRecords());\n\t    takeMutations();\n\t  }\n\t}\n\t\n\tvar forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\n\t\n\t\n\t// observe a node tree; bail if it's already being observed.\n\tfunction observe(inRoot) {\n\t  if (inRoot.__observer) {\n\t    return;\n\t  }\n\t  // For each ShadowRoot, we create a new MutationObserver, so the root can be\n\t  // garbage collected once all references to the `inRoot` node are gone.\n\t  // Give the handler access to the root so that an 'in document' check can\n\t  // be done.\n\t  var observer = new MutationObserver(handler.bind(this, inRoot));\n\t  observer.observe(inRoot, {childList: true, subtree: true});\n\t  inRoot.__observer = observer;\n\t}\n\t\n\t// upgrade an entire document and observe it for elements changes.\n\tfunction upgradeDocument(doc) {\n\t  doc = window.wrap(doc);\n\t  flags.dom && console.group('upgradeDocument: ', (doc.baseURI).split('/').pop());\n\t  var isMainDocument = (doc === window.wrap(document));\n\t  addedNode(doc, isMainDocument);\n\t  observe(doc);\n\t  flags.dom && console.groupEnd();\n\t}\n\t\n\t/*\n\tThis method is intended to be called when the document tree (including imports)\n\thas pending custom elements to upgrade. It can be called multiple times and\n\tshould do nothing if no elements are in need of upgrade.\n\t*/\n\tfunction upgradeDocumentTree(doc) {\n\t  forDocumentTree(doc, upgradeDocument);\n\t}\n\t\n\t\n\t// Patch `createShadowRoot()` if Shadow DOM is available, otherwise leave\n\t// undefined to aid feature detection of Shadow DOM.\n\tvar originalCreateShadowRoot = Element.prototype.createShadowRoot;\n\tif (originalCreateShadowRoot) {\n\t  Element.prototype.createShadowRoot = function() {\n\t    var root = originalCreateShadowRoot.call(this);\n\t    window.CustomElements.watchShadow(this);\n\t    return root;\n\t  };\n\t}\n\t\n\t// exports\n\tscope.watchShadow = watchShadow;\n\tscope.upgradeDocumentTree = upgradeDocumentTree;\n\tscope.upgradeDocument = upgradeDocument;\n\tscope.upgradeSubtree = addedSubtree;\n\tscope.upgradeAll = addedNode;\n\tscope.attached = attached;\n\tscope.takeRecords = takeRecords;\n\t\n\t});\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\t\n\t/**\n\t * Implements custom element upgrading\n\t * @module upgrade\n\t*/\n\t\n\twindow.CustomElements.addModule(function(scope) {\n\t\n\t// imports\n\tvar flags = scope.flags;\n\t\n\t/**\n\t * Upgrade an element to a custom element. Upgrading an element\n\t * causes the custom prototype to be applied, an `is` attribute\n\t * to be attached (as needed), and invocation of the `readyCallback`.\n\t * If the element is in the main document, the `attachedkCallback` method\n\t * will be invoked.\n\t * `upgrade` does nothing if the element is already upgraded, or\n\t * if it matches no registered custom tag name.\n\t *\n\t * @method ugprade\n\t * @param {Element} element The element to upgrade.\n\t * @return {Element} The upgraded element.\n\t */\n\t// Upgrade a node if it can be upgraded and is not already.\n\tfunction upgrade(node, isAttached) {\n\t  // upgrade template elements before custom elements\n\t  if (node.localName === 'template') {\n\t    if (window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n\t      HTMLTemplateElement.decorate(node);\n\t    }\n\t  }\n\t  if (!node.__upgraded__ && (node.nodeType === Node.ELEMENT_NODE)) {\n\t    var is = node.getAttribute('is');\n\t    // find definition first by localName and secondarily by is attribute\n\t    var definition = scope.getRegisteredDefinition(node.localName) ||\n\t      scope.getRegisteredDefinition(is);\n\t    if (definition) {\n\t      // upgrade with is iff the definition tag matches the element tag\n\t      // and don't upgrade if there's an is and the definition does not extend\n\t      // a native element\n\t      if ((is && definition.tag == node.localName) ||\n\t        (!is && !definition.extends)) {\n\t        return upgradeWithDefinition(node, definition, isAttached);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction upgradeWithDefinition(element, definition, isAttached) {\n\t  flags.upgrade && console.group('upgrade:', element.localName);\n\t  // some definitions specify an 'is' attribute\n\t  if (definition.is) {\n\t    element.setAttribute('is', definition.is);\n\t  }\n\t  // make 'element' implement definition.prototype\n\t  implementPrototype(element, definition);\n\t  // flag as upgraded\n\t  element.__upgraded__ = true;\n\t  // lifecycle management\n\t  created(element);\n\t  // attachedCallback fires in tree order, call before recursing\n\t  if (isAttached) {\n\t    scope.attached(element);\n\t  }\n\t  // there should never be a shadow root on element at this point\n\t  scope.upgradeSubtree(element, isAttached);\n\t  flags.upgrade && console.groupEnd();\n\t  // OUTPUT\n\t  return element;\n\t}\n\t\n\t//  Set __proto__ on supported platforms and use a mixin strategy when\n\t//  this is not supported; e.g. on IE10.\n\tfunction implementPrototype(element, definition) {\n\t  // prototype swizzling is best\n\t  if (Object.__proto__) {\n\t    element.__proto__ = definition.prototype;\n\t  } else {\n\t    // where above we can re-acquire inPrototype via\n\t    // getPrototypeOf(Element), we cannot do so when\n\t    // we use mixin, so we install a magic reference\n\t    customMixin(element, definition.prototype, definition.native);\n\t    element.__proto__ = definition.prototype;\n\t  }\n\t}\n\t\n\tfunction customMixin(inTarget, inSrc, inNative) {\n\t  // TODO(sjmiles): 'used' allows us to only copy the 'youngest' version of\n\t  // any property. This set should be precalculated. We also need to\n\t  // consider this for supporting 'super'.\n\t  var used = {};\n\t  // start with inSrc\n\t  var p = inSrc;\n\t  // The default is HTMLElement.prototype, so we add a test to avoid mixing in\n\t  // native prototypes\n\t  while (p !== inNative && p !== HTMLElement.prototype) {\n\t    var keys = Object.getOwnPropertyNames(p);\n\t    for (var i=0, k; k=keys[i]; i++) {\n\t      if (!used[k]) {\n\t        Object.defineProperty(inTarget, k,\n\t            Object.getOwnPropertyDescriptor(p, k));\n\t        used[k] = 1;\n\t      }\n\t    }\n\t    p = Object.getPrototypeOf(p);\n\t  }\n\t}\n\t\n\tfunction created(element) {\n\t  // invoke createdCallback\n\t  if (element.createdCallback) {\n\t    element.createdCallback();\n\t  }\n\t}\n\t\n\tscope.upgrade = upgrade;\n\tscope.upgradeWithDefinition = upgradeWithDefinition;\n\tscope.implementPrototype = implementPrototype;\n\t\n\t});\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\t\n\t/**\n\t * Implements `document.registerElement`\n\t * @module register\n\t*/\n\t\n\t/**\n\t * Polyfilled extensions to the `document` object.\n\t * @class Document\n\t*/\n\t\n\twindow.CustomElements.addModule(function(scope) {\n\t\n\t// imports\n\tvar isIE = scope.isIE;\n\tvar upgradeDocumentTree = scope.upgradeDocumentTree;\n\tvar upgradeAll = scope.upgradeAll;\n\tvar upgradeWithDefinition = scope.upgradeWithDefinition;\n\tvar implementPrototype = scope.implementPrototype;\n\tvar useNative = scope.useNative;\n\t\n\t/**\n\t * Registers a custom tag name with the document.\n\t *\n\t * When a registered element is created, a `readyCallback` method is called\n\t * in the scope of the element. The `readyCallback` method can be specified on\n\t * either `options.prototype` or `options.lifecycle` with the latter taking\n\t * precedence.\n\t *\n\t * @method register\n\t * @param {String} name The tag name to register. Must include a dash ('-'),\n\t *    for example 'x-component'.\n\t * @param {Object} options\n\t *    @param {String} [options.extends]\n\t *      (_off spec_) Tag name of an element to extend (or blank for a new\n\t *      element). This parameter is not part of the specification, but instead\n\t *      is a hint for the polyfill because the extendee is difficult to infer.\n\t *      Remember that the input prototype must chain to the extended element's\n\t *      prototype (or HTMLElement.prototype) regardless of the value of\n\t *      `extends`.\n\t *    @param {Object} options.prototype The prototype to use for the new\n\t *      element. The prototype must inherit from HTMLElement.\n\t *    @param {Object} [options.lifecycle]\n\t *      Callbacks that fire at important phases in the life of the custom\n\t *      element.\n\t *\n\t * @example\n\t *      FancyButton = document.registerElement(\"fancy-button\", {\n\t *        extends: 'button',\n\t *        prototype: Object.create(HTMLButtonElement.prototype, {\n\t *          readyCallback: {\n\t *            value: function() {\n\t *              console.log(\"a fancy-button was created\",\n\t *            }\n\t *          }\n\t *        })\n\t *      });\n\t * @return {Function} Constructor for the newly registered type.\n\t */\n\tfunction register(name, options) {\n\t  //console.warn('document.registerElement(\"' + name + '\", ', options, ')');\n\t  // construct a defintion out of options\n\t  // TODO(sjmiles): probably should clone options instead of mutating it\n\t  var definition = options || {};\n\t  if (!name) {\n\t    throw new Error('document.registerElement: first argument `name` must not be empty');\n\t  }\n\t  if (name.indexOf('-') < 0) {\n\t    throw new Error('document.registerElement: first argument (\\'name\\') must contain a dash (\\'-\\'). Argument provided was \\'' + String(name) + '\\'.');\n\t  }\n\t  // prevent registering reserved names\n\t  if (isReservedTag(name)) {\n\t    throw new Error('Failed to execute \\'registerElement\\' on \\'Document\\': Registration failed for type \\'' + String(name) + '\\'. The type name is invalid.');\n\t  }\n\t  // elements may only be registered once\n\t  if (getRegisteredDefinition(name)) {\n\t    throw new Error('DuplicateDefinitionError: a type with name \\'' + String(name) + '\\' is already registered');\n\t  }\n\t  // prototype is optional, default to an extension of HTMLElement\n\t  if (!definition.prototype) {\n\t    definition.prototype = Object.create(HTMLElement.prototype);\n\t  }\n\t  // record name\n\t  definition.__name = name.toLowerCase();\n\t  // ensure a lifecycle object so we don't have to null test it\n\t  definition.lifecycle = definition.lifecycle || {};\n\t  // build a list of ancestral custom elements (for native base detection)\n\t  // TODO(sjmiles): we used to need to store this, but current code only\n\t  // uses it in 'resolveTagName': it should probably be inlined\n\t  definition.ancestry = ancestry(definition.extends);\n\t  // extensions of native specializations of HTMLElement require localName\n\t  // to remain native, and use secondary 'is' specifier for extension type\n\t  resolveTagName(definition);\n\t  // some platforms require modifications to the user-supplied prototype\n\t  // chain\n\t  resolvePrototypeChain(definition);\n\t  // overrides to implement attributeChanged callback\n\t  overrideAttributeApi(definition.prototype);\n\t  // 7.1.5: Register the DEFINITION with DOCUMENT\n\t  registerDefinition(definition.__name, definition);\n\t  // 7.1.7. Run custom element constructor generation algorithm with PROTOTYPE\n\t  // 7.1.8. Return the output of the previous step.\n\t  definition.ctor = generateConstructor(definition);\n\t  definition.ctor.prototype = definition.prototype;\n\t  // force our .constructor to be our actual constructor\n\t  definition.prototype.constructor = definition.ctor;\n\t  // if initial parsing is complete\n\t  if (scope.ready) {\n\t    // upgrade any pre-existing nodes of this type\n\t    upgradeDocumentTree(document);\n\t  }\n\t  return definition.ctor;\n\t}\n\t\n\t// attribute watching\n\tfunction overrideAttributeApi(prototype) {\n\t  // overrides to implement callbacks\n\t  // TODO(sjmiles): should support access via .attributes NamedNodeMap\n\t  // TODO(sjmiles): preserves user defined overrides, if any\n\t  if (prototype.setAttribute._polyfilled) {\n\t    return;\n\t  }\n\t  var setAttribute = prototype.setAttribute;\n\t  prototype.setAttribute = function(name, value) {\n\t    changeAttribute.call(this, name, value, setAttribute);\n\t  };\n\t  var removeAttribute = prototype.removeAttribute;\n\t  prototype.removeAttribute = function(name) {\n\t    changeAttribute.call(this, name, null, removeAttribute);\n\t  };\n\t  prototype.setAttribute._polyfilled = true;\n\t}\n\t\n\t// https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/\n\t// index.html#dfn-attribute-changed-callback\n\tfunction changeAttribute(name, value, operation) {\n\t  name = name.toLowerCase();\n\t  var oldValue = this.getAttribute(name);\n\t  operation.apply(this, arguments);\n\t  var newValue = this.getAttribute(name);\n\t  if (this.attributeChangedCallback &&\n\t      (newValue !== oldValue)) {\n\t    this.attributeChangedCallback(name, oldValue, newValue);\n\t  }\n\t}\n\t\n\tfunction isReservedTag(name) {\n\t  for (var i = 0; i < reservedTagList.length; i++) {\n\t    if (name === reservedTagList[i]) {\n\t      return true;\n\t    }\n\t  }\n\t}\n\t\n\tvar reservedTagList = [\n\t  'annotation-xml', 'color-profile', 'font-face', 'font-face-src',\n\t  'font-face-uri', 'font-face-format', 'font-face-name', 'missing-glyph'\n\t];\n\t\n\tfunction ancestry(extnds) {\n\t  var extendee = getRegisteredDefinition(extnds);\n\t  if (extendee) {\n\t    return ancestry(extendee.extends).concat([extendee]);\n\t  }\n\t  return [];\n\t}\n\t\n\tfunction resolveTagName(definition) {\n\t  // if we are explicitly extending something, that thing is our\n\t  // baseTag, unless it represents a custom component\n\t  var baseTag = definition.extends;\n\t  // if our ancestry includes custom components, we only have a\n\t  // baseTag if one of them does\n\t  for (var i=0, a; (a=definition.ancestry[i]); i++) {\n\t    baseTag = a.is && a.tag;\n\t  }\n\t  // our tag is our baseTag, if it exists, and otherwise just our name\n\t  definition.tag = baseTag || definition.__name;\n\t  if (baseTag) {\n\t    // if there is a base tag, use secondary 'is' specifier\n\t    definition.is = definition.__name;\n\t  }\n\t}\n\t\n\tfunction resolvePrototypeChain(definition) {\n\t  // if we don't support __proto__ we need to locate the native level\n\t  // prototype for precise mixing in\n\t  if (!Object.__proto__) {\n\t    // default prototype\n\t    var nativePrototype = HTMLElement.prototype;\n\t    // work out prototype when using type-extension\n\t    if (definition.is) {\n\t      var inst = document.createElement(definition.tag);\n\t      nativePrototype = Object.getPrototypeOf(inst);\n\t    }\n\t    // ensure __proto__ reference is installed at each point on the prototype\n\t    // chain.\n\t    // NOTE: On platforms without __proto__, a mixin strategy is used instead\n\t    // of prototype swizzling. In this case, this generated __proto__ provides\n\t    // limited support for prototype traversal.\n\t    var proto = definition.prototype, ancestor;\n\t    var foundPrototype = false;\n\t    while (proto) {\n\t      if (proto == nativePrototype) {\n\t        foundPrototype = true;\n\t      }\n\t      ancestor = Object.getPrototypeOf(proto);\n\t      if (ancestor) {\n\t        proto.__proto__ = ancestor;\n\t      }\n\t      proto = ancestor;\n\t    }\n\t    if (!foundPrototype) {\n\t      // Note the spec actually allows this, but it results in broken elements\n\t      // and is difficult to polyfill correctly, so we throw\n\t      console.warn(definition.tag + ' prototype not found in prototype chain for ' +\n\t        definition.is);\n\t    }\n\t    // cache this in case of mixin\n\t    definition.native = nativePrototype;\n\t  }\n\t}\n\t\n\t// SECTION 4\n\t\n\tfunction instantiate(definition) {\n\t  // 4.a.1. Create a new object that implements PROTOTYPE\n\t  // 4.a.2. Let ELEMENT by this new object\n\t  //\n\t  // the custom element instantiation algorithm must also ensure that the\n\t  // output is a valid DOM element with the proper wrapper in place.\n\t  //\n\t  return upgradeWithDefinition(domCreateElement(definition.tag), definition);\n\t}\n\t\n\t// element registry (maps tag names to definitions)\n\t\n\tvar registry = {};\n\t\n\tfunction getRegisteredDefinition(name) {\n\t  if (name) {\n\t    return registry[name.toLowerCase()];\n\t  }\n\t}\n\t\n\tfunction registerDefinition(name, definition) {\n\t  registry[name] = definition;\n\t}\n\t\n\tfunction generateConstructor(definition) {\n\t  return function() {\n\t    return instantiate(definition);\n\t  };\n\t}\n\t\n\tvar HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n\tfunction createElementNS(namespace, tag, typeExtension) {\n\t  // NOTE: we do not support non-HTML elements,\n\t  // just call createElementNS for non HTML Elements\n\t  if (namespace === HTML_NAMESPACE) {\n\t    return createElement(tag, typeExtension);\n\t  } else {\n\t    return domCreateElementNS(namespace, tag);\n\t  }\n\t}\n\t\n\tfunction createElement(tag, typeExtension) {\n\t  // TODO(sjmiles): ignore 'tag' when using 'typeExtension', we could\n\t  // error check it, or perhaps there should only ever be one argument\n\t  if (tag) {\n\t    tag = tag.toLowerCase();\n\t  }\n\t  if (typeExtension) {\n\t    typeExtension = typeExtension.toLowerCase();\n\t  }\n\t  var definition = getRegisteredDefinition(typeExtension || tag);\n\t  if (definition) {\n\t    if (tag == definition.tag && typeExtension == definition.is) {\n\t      return new definition.ctor();\n\t    }\n\t    // Handle empty string for type extension.\n\t    if (!typeExtension && !definition.is) {\n\t      return new definition.ctor();\n\t    }\n\t  }\n\t  var element;\n\t  if (typeExtension) {\n\t    element = createElement(tag);\n\t    element.setAttribute('is', typeExtension);\n\t    return element;\n\t  }\n\t  element = domCreateElement(tag);\n\t  // Custom tags should be HTMLElements even if not upgraded.\n\t  if (tag.indexOf('-') >= 0) {\n\t    implementPrototype(element, HTMLElement);\n\t  }\n\t  return element;\n\t}\n\t\n\t// capture native createElement before we override it\n\tvar domCreateElement = document.createElement.bind(document);\n\tvar domCreateElementNS = document.createElementNS.bind(document);\n\t\n\t// Create a custom 'instanceof'. This is necessary when CustomElements\n\t// are implemented via a mixin strategy, as for example on IE10.\n\tvar isInstance;\n\tif (!Object.__proto__ && !useNative) {\n\t  isInstance = function(obj, ctor) {\n\t    // Allows instanceof(<div>, HTMLElement.prototype) to work\n\t    if (obj instanceof ctor) {\n\t      return true;\n\t    }\n\t    var p = obj;\n\t    while (p) {\n\t      // NOTE: this is not technically correct since we're not checking if\n\t      // an object is an instance of a constructor; however, this should\n\t      // be good enough for the mixin strategy.\n\t      if (p === ctor.prototype) {\n\t        return true;\n\t      }\n\t      p = p.__proto__;\n\t    }\n\t    return false;\n\t  };\n\t} else {\n\t  isInstance = function(obj, base) {\n\t    return obj instanceof base;\n\t  };\n\t}\n\t\n\t// wrap a dom object method that works on nodes such that it forces upgrade\n\tfunction wrapDomMethodToForceUpgrade(obj, methodName) {\n\t  var orig = obj[methodName];\n\t  obj[methodName] = function() {\n\t    var n = orig.apply(this, arguments);\n\t    upgradeAll(n);\n\t    return n;\n\t  };\n\t}\n\t\n\twrapDomMethodToForceUpgrade(Node.prototype, 'cloneNode');\n\twrapDomMethodToForceUpgrade(document, 'importNode');\n\t\n\t// Patch document.importNode to work around IE11 bug that\n\t// casues children of a document fragment imported while\n\t// there is a mutation observer to not have a parentNode (!?!)\n\tif (isIE) {\n\t  (function() {\n\t    var importNode = document.importNode;\n\t    document.importNode = function() {\n\t      var n = importNode.apply(document, arguments);\n\t      // Copy all children to a new document fragment since\n\t      // this one may be broken\n\t      if (n.nodeType == n.DOCUMENT_FRAGMENT_NODE) {\n\t        var f = document.createDocumentFragment();\n\t        f.appendChild(n);\n\t        return f;\n\t      } else {\n\t        return n;\n\t      }\n\t    };\n\t  })();\n\t}\n\t\n\t// exports\n\tdocument.registerElement = register;\n\tdocument.createElement = createElement; // override\n\tdocument.createElementNS = createElementNS; // override\n\tscope.registry = registry;\n\tscope.instanceof = isInstance;\n\tscope.reservedTagList = reservedTagList;\n\tscope.getRegisteredDefinition = getRegisteredDefinition;\n\t\n\t// bc\n\tdocument.register = document.registerElement;\n\t\n\t});\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\t(function(scope){\n\t\n\t// imports\n\tvar useNative = scope.useNative;\n\tvar initializeModules = scope.initializeModules;\n\t\n\tvar isIE = scope.isIE;\n\t\n\t// If native, setup stub api and bail.\n\t// NOTE: we fire `WebComponentsReady` under native for api compatibility\n\tif (useNative) {\n\t  // stub\n\t  var nop = function() {};\n\t\n\t  // exports\n\t  scope.watchShadow = nop;\n\t  scope.upgrade = nop;\n\t  scope.upgradeAll = nop;\n\t  scope.upgradeDocumentTree = nop;\n\t  scope.upgradeSubtree = nop;\n\t  scope.takeRecords = nop;\n\t\n\t  scope.instanceof = function(obj, base) {\n\t    return obj instanceof base;\n\t  };\n\t\n\t} else {\n\t  // Initialize polyfill modules. Note, polyfill modules are loaded but not\n\t  // executed; this is a convenient way to control which modules run when\n\t  // the polyfill is required and allows the polyfill to load even when it's\n\t  // not needed.\n\t  initializeModules();\n\t}\n\t\n\t// imports\n\tvar upgradeDocumentTree = scope.upgradeDocumentTree;\n\tvar upgradeDocument = scope.upgradeDocument;\n\t\n\t// ShadowDOM polyfill wraps elements but some elements like `document`\n\t// cannot be wrapped so we help the polyfill by wrapping some elements.\n\tif (!window.wrap) {\n\t  if (window.ShadowDOMPolyfill) {\n\t    window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded;\n\t    window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded;\n\t  } else {\n\t    window.wrap = window.unwrap = function(node) {\n\t      return node;\n\t    };\n\t  }\n\t}\n\t\n\t// eagarly upgrade imported documents\n\tif (window.HTMLImports) {\n\t  window.HTMLImports.__importsParsingHook = function(elt) {\n\t    if (elt.import) {\n\t      upgradeDocument(wrap(elt.import));\n\t    }\n\t  };\n\t}\n\t\n\t// bootstrap parsing\n\tfunction bootstrap() {\n\t  // one more upgrade to catch out of order registrations\n\t  upgradeDocumentTree(window.wrap(document));\n\t  // install upgrade hook if HTMLImports are available\n\t  // set internal 'ready' flag, now document.registerElement will trigger\n\t  // synchronous upgrades\n\t  window.CustomElements.ready = true;\n\t  // async to ensure *native* custom elements upgrade prior to this\n\t  // DOMContentLoaded can fire before elements upgrade (e.g. when there's\n\t  // an external script)\n\t  // Delay doubly to help workaround\n\t  // https://code.google.com/p/chromium/issues/detail?id=516550.\n\t  // CustomElements must use requestAnimationFrame in attachedCallback\n\t  // to query style/layout data. The WebComponentsReady event is intended\n\t  // to convey overall readiness, which ideally should be after elements\n\t  // are attached. Adding a slight extra delay to WebComponentsReady\n\t  // helps preserve this guarantee.\n\t  var requestAnimationFrame = window.requestAnimationFrame || function(f) {\n\t    setTimeout(f, 16);\n\t  };\n\t  requestAnimationFrame(function() {\n\t    setTimeout(function() {\n\t      // capture blunt profiling data\n\t      window.CustomElements.readyTime = Date.now();\n\t      if (window.HTMLImports) {\n\t        window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime;\n\t      }\n\t      // notify the system that we are bootstrapped\n\t      document.dispatchEvent(\n\t        new CustomEvent('WebComponentsReady', {bubbles: true})\n\t      );\n\t    });\n\t  });\n\t}\n\t\n\t// When loading at readyState complete time (or via flag), boot custom elements\n\t// immediately.\n\t// If relevant, HTMLImports must already be loaded.\n\tif (document.readyState === 'complete' || scope.flags.eager) {\n\t  bootstrap();\n\t// When loading at readyState interactive time, bootstrap only if HTMLImports\n\t// are not pending. Also avoid IE as the semantics of this state are unreliable.\n\t} else if (document.readyState === 'interactive' && !window.attachEvent &&\n\t    (!window.HTMLImports || window.HTMLImports.ready)) {\n\t  bootstrap();\n\t// When loading at other readyStates, wait for the appropriate DOM event to\n\t// bootstrap.\n\t} else {\n\t  var loadEvent = window.HTMLImports && !window.HTMLImports.ready ?\n\t      'HTMLImportsLoaded' : 'DOMContentLoaded';\n\t  window.addEventListener(loadEvent, bootstrap);\n\t}\n\t\n\t})(window.CustomElements);\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\t\n\t/*\n\t * PLEASE NOTE: This file is duplicated within Polymer. Please keep it in sync!\n\t * https://github.com/Polymer/polymer/blob/master/src/system/HTMLImports/base.js\n\t */\n\t\n\t/*\n\t\tCreate polyfill scope and feature detect native support.\n\t*/\n\twindow.HTMLImports = window.HTMLImports || {flags:{}};\n\t\n\t(function(scope) {\n\t\n\t/**\n\t\tBasic setup and simple module executer. We collect modules and then execute\n\t  the code later, only if it's necessary for polyfilling.\n\t*/\n\tvar IMPORT_LINK_TYPE = 'import';\n\tvar useNative = Boolean(IMPORT_LINK_TYPE in document.createElement('link'));\n\t\n\t/**\n\t  Support `currentScript` on all browsers as `document._currentScript.`\n\t\n\t  NOTE: We cannot polyfill `document.currentScript` because it's not possible\n\t  both to override and maintain the ability to capture the native value.\n\t  Therefore we choose to expose `_currentScript` both when native imports\n\t  and the polyfill are in use.\n\t*/\n\t// NOTE: ShadowDOMPolyfill intrusion.\n\tvar hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);\n\tvar wrap = function(node) {\n\t  return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;\n\t};\n\tvar rootDocument = wrap(document);\n\t\n\tvar currentScriptDescriptor = {\n\t  get: function() {\n\t    var script = window.HTMLImports.currentScript || document.currentScript ||\n\t        // NOTE: only works when called in synchronously executing code.\n\t        // readyState should check if `loading` but IE10 is\n\t        // interactive when scripts run so we cheat.\n\t        (document.readyState !== 'complete' ?\n\t        document.scripts[document.scripts.length - 1] : null);\n\t    return wrap(script);\n\t  },\n\t  configurable: true\n\t};\n\t\n\tObject.defineProperty(document, '_currentScript', currentScriptDescriptor);\n\tObject.defineProperty(rootDocument, '_currentScript', currentScriptDescriptor);\n\t\n\t/**\n\t  Add support for the `HTMLImportsLoaded` event and the `HTMLImports.whenReady`\n\t  method. This api is necessary because unlike the native implementation,\n\t  script elements do not force imports to resolve. Instead, users should wrap\n\t  code in either an `HTMLImportsLoaded` handler or after load time in an\n\t  `HTMLImports.whenReady(callback)` call.\n\t\n\t  NOTE: This module also supports these apis under the native implementation.\n\t  Therefore, if this file is loaded, the same code can be used under both\n\t  the polyfill and native implementation.\n\t */\n\t\n\tvar isIE = /Trident/.test(navigator.userAgent);\n\t\n\t// call a callback when all HTMLImports in the document at call time\n\t// (or at least document ready) have loaded.\n\t// 1. ensure the document is in a ready state (has dom), then\n\t// 2. watch for loading of imports and call callback when done\n\tfunction whenReady(callback, doc) {\n\t  doc = doc || rootDocument;\n\t  // if document is loading, wait and try again\n\t  whenDocumentReady(function() {\n\t    watchImportsLoad(callback, doc);\n\t  }, doc);\n\t}\n\t\n\t// call the callback when the document is in a ready state (has dom)\n\tvar requiredReadyState = isIE ? 'complete' : 'interactive';\n\tvar READY_EVENT = 'readystatechange';\n\tfunction isDocumentReady(doc) {\n\t  return (doc.readyState === 'complete' ||\n\t      doc.readyState === requiredReadyState);\n\t}\n\t\n\t// call <callback> when we ensure the document is in a ready state\n\tfunction whenDocumentReady(callback, doc) {\n\t  if (!isDocumentReady(doc)) {\n\t    var checkReady = function() {\n\t      if (doc.readyState === 'complete' ||\n\t          doc.readyState === requiredReadyState) {\n\t        doc.removeEventListener(READY_EVENT, checkReady);\n\t        whenDocumentReady(callback, doc);\n\t      }\n\t    };\n\t    doc.addEventListener(READY_EVENT, checkReady);\n\t  } else if (callback) {\n\t    callback();\n\t  }\n\t}\n\t\n\tfunction markTargetLoaded(event) {\n\t  event.target.__loaded = true;\n\t}\n\t\n\t// call <callback> when we ensure all imports have loaded\n\tfunction watchImportsLoad(callback, doc) {\n\t  var imports = doc.querySelectorAll('link[rel=import]');\n\t  var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];\n\t  function checkDone() {\n\t    if (parsedCount == importCount && callback) {\n\t      callback({\n\t        allImports: imports,\n\t        loadedImports: newImports,\n\t        errorImports: errorImports\n\t      });\n\t    }\n\t  }\n\t  function loadedImport(e) {\n\t    markTargetLoaded(e);\n\t    newImports.push(this);\n\t    parsedCount++;\n\t    checkDone();\n\t  }\n\t  function errorLoadingImport(e) {\n\t    errorImports.push(this);\n\t    parsedCount++;\n\t    checkDone();\n\t  }\n\t  if (importCount) {\n\t    for (var i=0, imp; i<importCount && (imp=imports[i]); i++) {\n\t      if (isImportLoaded(imp)) {\n\t        parsedCount++;\n\t        checkDone();\n\t      } else {\n\t        imp.addEventListener('load', loadedImport);\n\t        imp.addEventListener('error', errorLoadingImport);\n\t      }\n\t    }\n\t  } else {\n\t    checkDone();\n\t  }\n\t}\n\t\n\t// NOTE: test for native imports loading is based on explicitly watching\n\t// all imports (see below).\n\t// However, we cannot rely on this entirely without watching the entire document\n\t// for import links. For perf reasons, currently only head is watched.\n\t// Instead, we fallback to checking if the import property is available\n\t// and the document is not itself loading.\n\tfunction isImportLoaded(link) {\n\t  return useNative ? link.__loaded ||\n\t      (link.import && link.import.readyState !== 'loading') :\n\t      link.__importParsed;\n\t}\n\t\n\t// TODO(sorvell): Workaround for\n\t// https://www.w3.org/Bugs/Public/show_bug.cgi?id=25007, should be removed when\n\t// this bug is addressed.\n\t// (1) Install a mutation observer to see when HTMLImports have loaded\n\t// (2) if this script is run during document load it will watch any existing\n\t// imports for loading.\n\t//\n\t// NOTE: The workaround has restricted functionality: (1) it's only compatible\n\t// with imports that are added to document.head since the mutation observer\n\t// watches only head for perf reasons, (2) it requires this script\n\t// to run before any imports have completed loading.\n\tif (useNative) {\n\t  new MutationObserver(function(mxns) {\n\t    for (var i=0, l=mxns.length, m; (i < l) && (m=mxns[i]); i++) {\n\t      if (m.addedNodes) {\n\t        handleImports(m.addedNodes);\n\t      }\n\t    }\n\t  }).observe(document.head, {childList: true});\n\t\n\t  function handleImports(nodes) {\n\t    for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {\n\t      if (isImport(n)) {\n\t        handleImport(n);\n\t      }\n\t    }\n\t  }\n\t\n\t  function isImport(element) {\n\t    return element.localName === 'link' && element.rel === 'import';\n\t  }\n\t\n\t  function handleImport(element) {\n\t    var loaded = element.import;\n\t    if (loaded) {\n\t      markTargetLoaded({target: element});\n\t    } else {\n\t      element.addEventListener('load', markTargetLoaded);\n\t      element.addEventListener('error', markTargetLoaded);\n\t    }\n\t  }\n\t\n\t  // make sure to catch any imports that are in the process of loading\n\t  // when this script is run.\n\t  (function() {\n\t    if (document.readyState === 'loading') {\n\t      var imports = document.querySelectorAll('link[rel=import]');\n\t      for (var i=0, l=imports.length, imp; (i<l) && (imp=imports[i]); i++) {\n\t        handleImport(imp);\n\t      }\n\t    }\n\t  })();\n\t\n\t}\n\t\n\t// Fire the 'HTMLImportsLoaded' event when imports in document at load time\n\t// have loaded. This event is required to simulate the script blocking\n\t// behavior of native imports. A main document script that needs to be sure\n\t// imports have loaded should wait for this event.\n\twhenReady(function(detail) {\n\t  window.HTMLImports.ready = true;\n\t  window.HTMLImports.readyTime = new Date().getTime();\n\t  var evt = rootDocument.createEvent(\"CustomEvent\");\n\t  evt.initCustomEvent(\"HTMLImportsLoaded\", true, true, detail);\n\t  rootDocument.dispatchEvent(evt);\n\t});\n\t\n\t// exports\n\tscope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;\n\tscope.useNative = useNative;\n\tscope.rootDocument = rootDocument;\n\tscope.whenReady = whenReady;\n\tscope.isIE = isIE;\n\t\n\t})(window.HTMLImports);\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\t(function(scope) {\n\t\n\t// world's simplest module initializer\n\tvar modules = [];\n\tvar addModule = function(module) {\n\t\tmodules.push(module);\n\t};\n\t\n\tvar initializeModules = function() {\n\t\tmodules.forEach(function(module) {\n\t\t\tmodule(scope);\n\t\t});\n\t};\n\t\n\t// exports\n\tscope.addModule = addModule;\n\tscope.initializeModules = initializeModules;\n\t\n\t})(window.HTMLImports);\n\t\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\twindow.HTMLImports.addModule(function(scope) {\n\t\n\tvar CSS_URL_REGEXP = /(url\\()([^)]*)(\\))/g;\n\tvar CSS_IMPORT_REGEXP = /(@import[\\s]+(?!url\\())([^;]*)(;)/g;\n\t\n\t// path fixup: style elements in imports must be made relative to the main\n\t// document. We fixup url's in url() and @import.\n\tvar path = {\n\t\n\t  resolveUrlsInStyle: function(style, linkUrl) {\n\t    var doc = style.ownerDocument;\n\t    var resolver = doc.createElement('a');\n\t    style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);\n\t    return style;\n\t  },\n\t\n\t  resolveUrlsInCssText: function(cssText, linkUrl, urlObj) {\n\t    var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);\n\t    r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);\n\t    return r;\n\t  },\n\t\n\t  replaceUrls: function(text, urlObj, linkUrl, regexp) {\n\t    return text.replace(regexp, function(m, pre, url, post) {\n\t      var urlPath = url.replace(/[\"']/g, '');\n\t      if (linkUrl) {\n\t        urlPath = (new URL(urlPath, linkUrl)).href;\n\t      }\n\t      urlObj.href = urlPath;\n\t      urlPath = urlObj.href;\n\t      return pre + '\\'' + urlPath + '\\'' + post;\n\t    });\n\t  }\n\t\n\t};\n\t\n\t// exports\n\tscope.path = path;\n\t\n\t});\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\twindow.HTMLImports.addModule(function(scope) {\n\t\n\t/*\n\t  xhr processor.\n\t*/\n\tvar xhr = {\n\t  async: true,\n\t\n\t  ok: function(request) {\n\t    return (request.status >= 200 && request.status < 300)\n\t        || (request.status === 304)\n\t        || (request.status === 0);\n\t  },\n\t\n\t  load: function(url, next, nextContext) {\n\t    var request = new XMLHttpRequest();\n\t    if (scope.flags.debug || scope.flags.bust) {\n\t      url += '?' + Math.random();\n\t    }\n\t    request.open('GET', url, xhr.async);\n\t    request.addEventListener('readystatechange', function(e) {\n\t      if (request.readyState === 4) {\n\t        // Servers redirecting an import can add a Location header to help us\n\t        // polyfill correctly.\n\t        var redirectedUrl = null;\n\t        try {\n\t          var locationHeader = request.getResponseHeader(\"Location\");\n\t          if (locationHeader) {\n\t            redirectedUrl = (locationHeader.substr( 0, 1 ) === \"/\")\n\t              ? location.origin + locationHeader  // Location is a relative path\n\t              : locationHeader;                   // Full path\n\t          }\n\t        } catch ( e ) {\n\t            console.error( e.message );\n\t        }\n\t        next.call(nextContext, !xhr.ok(request) && request,\n\t            request.response || request.responseText, redirectedUrl);\n\t      }\n\t    });\n\t    request.send();\n\t    return request;\n\t  },\n\t\n\t  loadDocument: function(url, next, nextContext) {\n\t    this.load(url, next, nextContext).responseType = 'document';\n\t  }\n\t\n\t};\n\t\n\t// exports\n\tscope.xhr = xhr;\n\t\n\t});\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\twindow.HTMLImports.addModule(function(scope) {\n\t\n\t// imports\n\tvar xhr = scope.xhr;\n\tvar flags = scope.flags;\n\t\n\t// This loader supports a dynamic list of urls\n\t// and an oncomplete callback that is called when the loader is done.\n\t// NOTE: The polyfill currently does *not* need this dynamism or the\n\t// onComplete concept. Because of this, the loader could be simplified\n\t// quite a bit.\n\tvar Loader = function(onLoad, onComplete) {\n\t  this.cache = {};\n\t  this.onload = onLoad;\n\t  this.oncomplete = onComplete;\n\t  this.inflight = 0;\n\t  this.pending = {};\n\t};\n\t\n\tLoader.prototype = {\n\t\n\t  addNodes: function(nodes) {\n\t    // number of transactions to complete\n\t    this.inflight += nodes.length;\n\t    // commence transactions\n\t    for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {\n\t      this.require(n);\n\t    }\n\t    // anything to do?\n\t    this.checkDone();\n\t  },\n\t\n\t  addNode: function(node) {\n\t    // number of transactions to complete\n\t    this.inflight++;\n\t    // commence transactions\n\t    this.require(node);\n\t    // anything to do?\n\t    this.checkDone();\n\t  },\n\t\n\t  require: function(elt) {\n\t    var url = elt.src || elt.href;\n\t    // ensure we have a standard url that can be used\n\t    // reliably for deduping.\n\t    // TODO(sjmiles): ad-hoc\n\t    elt.__nodeUrl = url;\n\t    // deduplication\n\t    if (!this.dedupe(url, elt)) {\n\t      // fetch this resource\n\t      this.fetch(url, elt);\n\t    }\n\t  },\n\t\n\t  dedupe: function(url, elt) {\n\t    if (this.pending[url]) {\n\t      // add to list of nodes waiting for inUrl\n\t      this.pending[url].push(elt);\n\t      // don't need fetch\n\t      return true;\n\t    }\n\t    var resource;\n\t    if (this.cache[url]) {\n\t      this.onload(url, elt, this.cache[url]);\n\t      // finished this transaction\n\t      this.tail();\n\t      // don't need fetch\n\t      return true;\n\t    }\n\t    // first node waiting for inUrl\n\t    this.pending[url] = [elt];\n\t    // need fetch (not a dupe)\n\t    return false;\n\t  },\n\t\n\t  fetch: function(url, elt) {\n\t    flags.load && console.log('fetch', url, elt);\n\t    if (!url) {\n\t      setTimeout(function() {\n\t        this.receive(url, elt, {error: 'href must be specified'}, null);\n\t      }.bind(this), 0);\n\t    } else if (url.match(/^data:/)) {\n\t      // Handle Data URI Scheme\n\t      var pieces = url.split(',');\n\t      var header = pieces[0];\n\t      var body = pieces[1];\n\t      if(header.indexOf(';base64') > -1) {\n\t        body = atob(body);\n\t      } else {\n\t        body = decodeURIComponent(body);\n\t      }\n\t      setTimeout(function() {\n\t          this.receive(url, elt, null, body);\n\t      }.bind(this), 0);\n\t    } else {\n\t      var receiveXhr = function(err, resource, redirectedUrl) {\n\t        this.receive(url, elt, err, resource, redirectedUrl);\n\t      }.bind(this);\n\t      xhr.load(url, receiveXhr);\n\t    }\n\t  },\n\t\n\t  receive: function(url, elt, err, resource, redirectedUrl) {\n\t    this.cache[url] = resource;\n\t    var $p = this.pending[url];\n\t    for (var i=0, l=$p.length, p; (i<l) && (p=$p[i]); i++) {\n\t      // If url was redirected, use the redirected location so paths are\n\t      // calculated relative to that.\n\t      this.onload(url, p, resource, err, redirectedUrl);\n\t      this.tail();\n\t    }\n\t    this.pending[url] = null;\n\t  },\n\t\n\t  tail: function() {\n\t    --this.inflight;\n\t    this.checkDone();\n\t  },\n\t\n\t  checkDone: function() {\n\t    if (!this.inflight) {\n\t      this.oncomplete();\n\t    }\n\t  }\n\t\n\t};\n\t\n\t// exports\n\tscope.Loader = Loader;\n\t\n\t});\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\twindow.HTMLImports.addModule(function(scope) {\n\t\n\t/*\n\t  Use a mutation observer to call a callback for all added nodes.\n\t*/\n\tvar Observer = function(addCallback) {\n\t  this.addCallback = addCallback;\n\t  this.mo = new MutationObserver(this.handler.bind(this));\n\t};\n\t\n\tObserver.prototype = {\n\t\n\t  // we track mutations for addedNodes, looking for imports\n\t  handler: function(mutations) {\n\t    for (var i=0, l=mutations.length, m; (i<l) && (m=mutations[i]); i++) {\n\t      if (m.type === 'childList' && m.addedNodes.length) {\n\t        this.addedNodes(m.addedNodes);\n\t      }\n\t    }\n\t  },\n\t\n\t  addedNodes: function(nodes) {\n\t    if (this.addCallback) {\n\t      this.addCallback(nodes);\n\t    }\n\t    for (var i=0, l=nodes.length, n, loading; (i<l) && (n=nodes[i]); i++) {\n\t      if (n.children && n.children.length) {\n\t        this.addedNodes(n.children);\n\t      }\n\t    }\n\t  },\n\t\n\t  observe: function(root) {\n\t    this.mo.observe(root, {childList: true, subtree: true});\n\t  }\n\t\n\t};\n\t\n\t// exports\n\tscope.Observer = Observer;\n\t\n\t});\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\twindow.HTMLImports.addModule(function(scope) {\n\t\n\t// imports\n\tvar path = scope.path;\n\tvar rootDocument = scope.rootDocument;\n\tvar flags = scope.flags;\n\tvar isIE = scope.isIE;\n\tvar IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\n\tvar IMPORT_SELECTOR = 'link[rel=' + IMPORT_LINK_TYPE + ']';\n\t\n\t// importParser\n\t// highlander object to manage parsing of imports\n\t// parses import related elements and ensures proper parse order\n\t// parse order is enforced by crawling the tree and monitoring which elements\n\t// have been parsed;\n\t// elements can be dynamically added to imports. These are maintained in a\n\t// separate queue and parsed after all other elements.\n\tvar importParser = {\n\t\n\t  // parse selectors for main document elements\n\t  documentSelectors: IMPORT_SELECTOR,\n\t\n\t  // parse selectors for import document elements\n\t  importsSelectors: [\n\t    IMPORT_SELECTOR,\n\t    'link[rel=stylesheet]:not([type])',\n\t    'style:not([type])',\n\t    'script:not([type])',\n\t    'script[type=\"application/javascript\"]',\n\t    'script[type=\"text/javascript\"]'\n\t  ].join(','),\n\t\n\t  map: {\n\t    link: 'parseLink',\n\t    script: 'parseScript',\n\t    style: 'parseStyle'\n\t  },\n\t\n\t  dynamicElements: [],\n\t\n\t  // try to parse the next import in the tree\n\t  parseNext: function() {\n\t    var next = this.nextToParse();\n\t    if (next) {\n\t      this.parse(next);\n\t    }\n\t  },\n\t\n\t  parse: function(elt) {\n\t    if (this.isParsed(elt)) {\n\t      flags.parse && console.log('[%s] is already parsed', elt.localName);\n\t      return;\n\t    }\n\t    var fn = this[this.map[elt.localName]];\n\t    if (fn) {\n\t      this.markParsing(elt);\n\t      fn.call(this, elt);\n\t    }\n\t  },\n\t\n\t  // marks an element for dynamic parsing and attempts to parse the next element\n\t  parseDynamic: function(elt, quiet) {\n\t    this.dynamicElements.push(elt);\n\t    if (!quiet) {\n\t      this.parseNext();\n\t    }\n\t  },\n\t\n\t  // only 1 element may be parsed at a time; parsing is async so each\n\t  // parsing implementation must inform the system that parsing is complete\n\t  // via markParsingComplete.\n\t  // To prompt the system to parse the next element, parseNext should then be\n\t  // called.\n\t  // Note, parseNext used to be included at the end of markParsingComplete, but\n\t  // we must not do this so that, for example, we can (1) mark parsing complete\n\t  // then (2) fire an import load event, and then (3) parse the next resource.\n\t  markParsing: function(elt) {\n\t    flags.parse && console.log('parsing', elt);\n\t    this.parsingElement = elt;\n\t  },\n\t\n\t  markParsingComplete: function(elt) {\n\t    elt.__importParsed = true;\n\t    this.markDynamicParsingComplete(elt);\n\t    if (elt.__importElement) {\n\t      elt.__importElement.__importParsed = true;\n\t      this.markDynamicParsingComplete(elt.__importElement);\n\t    }\n\t    this.parsingElement = null;\n\t    flags.parse && console.log('completed', elt);\n\t  },\n\t\n\t  markDynamicParsingComplete: function(elt) {\n\t    var i = this.dynamicElements.indexOf(elt);\n\t    if (i >= 0) {\n\t      this.dynamicElements.splice(i, 1);\n\t    }\n\t  },\n\t\n\t  parseImport: function(elt) {\n\t    elt.import = elt.__doc;\n\t    if (window.HTMLImports.__importsParsingHook) {\n\t      window.HTMLImports.__importsParsingHook(elt);\n\t    }\n\t    if (elt.import) {\n\t      elt.import.__importParsed = true;\n\t    }\n\t    this.markParsingComplete(elt);\n\t    // fire load event\n\t    if (elt.__resource && !elt.__error) {\n\t      elt.dispatchEvent(new CustomEvent('load', {bubbles: false}));\n\t    } else {\n\t      elt.dispatchEvent(new CustomEvent('error', {bubbles: false}));\n\t    }\n\t    // TODO(sorvell): workaround for Safari addEventListener not working\n\t    // for elements not in the main document.\n\t    if (elt.__pending) {\n\t      var fn;\n\t      while (elt.__pending.length) {\n\t        fn = elt.__pending.shift();\n\t        if (fn) {\n\t          fn({target: elt});\n\t        }\n\t      }\n\t    }\n\t    this.parseNext();\n\t  },\n\t\n\t  parseLink: function(linkElt) {\n\t    if (nodeIsImport(linkElt)) {\n\t      this.parseImport(linkElt);\n\t    } else {\n\t      // make href absolute\n\t      linkElt.href = linkElt.href;\n\t      this.parseGeneric(linkElt);\n\t    }\n\t  },\n\t\n\t  parseStyle: function(elt) {\n\t    // TODO(sorvell): style element load event can just not fire so clone styles\n\t    var src = elt;\n\t    elt = cloneStyle(elt);\n\t    src.__appliedElement = elt;\n\t    elt.__importElement = src;\n\t    this.parseGeneric(elt);\n\t  },\n\t\n\t  parseGeneric: function(elt) {\n\t    this.trackElement(elt);\n\t    this.addElementToDocument(elt);\n\t  },\n\t\n\t  rootImportForElement: function(elt) {\n\t    var n = elt;\n\t    while (n.ownerDocument.__importLink) {\n\t      n = n.ownerDocument.__importLink;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  addElementToDocument: function(elt) {\n\t    var port = this.rootImportForElement(elt.__importElement || elt);\n\t    port.parentNode.insertBefore(elt, port);\n\t  },\n\t\n\t  // tracks when a loadable element has loaded\n\t  trackElement: function(elt, callback) {\n\t    var self = this;\n\t    var done = function(e) {\n\t      // make sure we don't get multiple load/error signals (FF seems to do\n\t      // this sometimes when <style> elments change)\n\t      elt.removeEventListener('load', done);\n\t      elt.removeEventListener('error', done);\n\t      if (callback) {\n\t        callback(e);\n\t      }\n\t      self.markParsingComplete(elt);\n\t      self.parseNext();\n\t    };\n\t    elt.addEventListener('load', done);\n\t    elt.addEventListener('error', done);\n\t\n\t    // NOTE: IE does not fire \"load\" event for styles that have already loaded\n\t    // This is in violation of the spec, so we try our hardest to work around it\n\t    if (isIE && elt.localName === 'style') {\n\t      var fakeLoad = false;\n\t      // If there's not @import in the textContent, assume it has loaded\n\t      if (elt.textContent.indexOf('@import') == -1) {\n\t        fakeLoad = true;\n\t      // if we have a sheet, we have been parsed\n\t      } else if (elt.sheet) {\n\t        fakeLoad = true;\n\t        var csr = elt.sheet.cssRules;\n\t        var len = csr ? csr.length : 0;\n\t        // search the rules for @import's\n\t        for (var i = 0, r; (i < len) && (r = csr[i]); i++) {\n\t          if (r.type === CSSRule.IMPORT_RULE) {\n\t            // if every @import has resolved, fake the load\n\t            fakeLoad = fakeLoad && Boolean(r.styleSheet);\n\t          }\n\t        }\n\t      }\n\t      // dispatch a fake load event and continue parsing\n\t      if (fakeLoad) {\n\t        // Fire async, to prevent reentrancy\n\t        setTimeout(function() {\n\t          elt.dispatchEvent(new CustomEvent('load', {bubbles: false}));\n\t        });\n\t      }\n\t    }\n\t  },\n\t\n\t  // NOTE: execute scripts by injecting them and watching for the load/error\n\t  // event. Inline scripts are handled via dataURL's because browsers tend to\n\t  // provide correct parsing errors in this case. If this has any compatibility\n\t  // issues, we can switch to injecting the inline script with textContent.\n\t  parseScript: function(scriptElt) {\n\t    var script = document.createElement('script');\n\t    script.__importElement = scriptElt;\n\t    script.src = scriptElt.src ? scriptElt.src :\n\t        generateScriptDataUrl(scriptElt);\n\t    // keep track of executing script to help polyfill `document.currentScript`\n\t    scope.currentScript = scriptElt;\n\t    this.trackElement(script, function(e) {\n\t      if (script.parentNode) {\n\t        script.parentNode.removeChild(script);\n\t      }\n\t      scope.currentScript = null;\n\t    });\n\t    this.addElementToDocument(script);\n\t  },\n\t\n\t  // determine the next element in the tree which should be parsed\n\t  // crawl the document tree to find the next unparsed element\n\t  // then process any dynamically added elements (these should process in 'add'\n\t  // order.\n\t  nextToParse: function() {\n\t    this._mayParse = [];\n\t    return !this.parsingElement && (this.nextToParseInDoc(rootDocument) ||\n\t        this.nextToParseDynamic());\n\t  },\n\t\n\t  nextToParseInDoc: function(doc, link) {\n\t    // use `marParse` list to avoid looping into the same document again\n\t    // since it could cause an iloop.\n\t    if (doc && this._mayParse.indexOf(doc) < 0) {\n\t      this._mayParse.push(doc);\n\t      var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));\n\t      for (var i=0, l=nodes.length, p=0, n; (i<l) && (n=nodes[i]); i++) {\n\t        if (!this.isParsed(n)) {\n\t          if (this.hasResource(n)) {\n\t            return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;\n\t          } else {\n\t            return;\n\t          }\n\t        }\n\t      }\n\t    }\n\t    // all nodes have been parsed, ready to parse import, if any\n\t    return link;\n\t  },\n\t\n\t  // note dynamically added elements are stored in a separate queue\n\t  nextToParseDynamic: function() {\n\t    return this.dynamicElements[0];\n\t  },\n\t\n\t  // return the set of parse selectors relevant for this node.\n\t  parseSelectorsForNode: function(node) {\n\t    var doc = node.ownerDocument || node;\n\t    return doc === rootDocument ? this.documentSelectors :\n\t        this.importsSelectors;\n\t  },\n\t\n\t  isParsed: function(node) {\n\t    return node.__importParsed;\n\t  },\n\t\n\t  needsDynamicParsing: function(elt) {\n\t    return (this.dynamicElements.indexOf(elt) >= 0);\n\t  },\n\t\n\t  hasResource: function(node) {\n\t    if (nodeIsImport(node) && (node.__doc === undefined)) {\n\t      return false;\n\t    }\n\t    return true;\n\t  }\n\t\n\t};\n\t\n\tfunction nodeIsImport(elt) {\n\t  return (elt.localName === 'link') && (elt.rel === IMPORT_LINK_TYPE);\n\t}\n\t\n\tfunction generateScriptDataUrl(script) {\n\t  var scriptContent = generateScriptContent(script);\n\t  return 'data:text/javascript;charset=utf-8,' + encodeURIComponent(scriptContent);\n\t}\n\t\n\tfunction generateScriptContent(script) {\n\t  return script.textContent + generateSourceMapHint(script);\n\t}\n\t\n\t// calculate source map hint\n\tfunction generateSourceMapHint(script) {\n\t  var owner = script.ownerDocument;\n\t  owner.__importedScripts = owner.__importedScripts || 0;\n\t  var moniker = script.ownerDocument.baseURI;\n\t  var num = owner.__importedScripts ? '-' + owner.__importedScripts : '';\n\t  owner.__importedScripts++;\n\t  return '\\n//# sourceURL=' + moniker + num + '.js\\n';\n\t}\n\t\n\t// style/stylesheet handling\n\t\n\t// clone style with proper path resolution for main document\n\t// NOTE: styles are the only elements that require direct path fixup.\n\tfunction cloneStyle(style) {\n\t  var clone = style.ownerDocument.createElement('style');\n\t  clone.textContent = style.textContent;\n\t  path.resolveUrlsInStyle(clone);\n\t  return clone;\n\t}\n\t\n\t// exports\n\tscope.parser = importParser;\n\tscope.IMPORT_SELECTOR = IMPORT_SELECTOR;\n\t\n\t});\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\twindow.HTMLImports.addModule(function(scope) {\n\t\n\t// imports\n\tvar flags = scope.flags;\n\tvar IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\n\tvar IMPORT_SELECTOR = scope.IMPORT_SELECTOR;\n\tvar rootDocument = scope.rootDocument;\n\tvar Loader = scope.Loader;\n\tvar Observer = scope.Observer;\n\tvar parser = scope.parser;\n\t\n\t// importer\n\t// highlander object to manage loading of imports\n\t// for any document, importer:\n\t// - loads any linked import documents (with deduping)\n\t// - whenever an import is loaded, prompts the parser to try to parse\n\t// - observes imported documents for new elements (these are handled via the\n\t// dynamic importer)\n\tvar importer = {\n\t\n\t  documents: {},\n\t\n\t  // nodes to load in the mian document\n\t  documentPreloadSelectors: IMPORT_SELECTOR,\n\t\n\t  // nodes to load in imports\n\t  importsPreloadSelectors: [\n\t    IMPORT_SELECTOR\n\t  ].join(','),\n\t\n\t  loadNode: function(node) {\n\t    importLoader.addNode(node);\n\t  },\n\t\n\t  // load all loadable elements within the parent element\n\t  loadSubtree: function(parent) {\n\t    var nodes = this.marshalNodes(parent);\n\t    // add these nodes to loader's queue\n\t    importLoader.addNodes(nodes);\n\t  },\n\t\n\t  marshalNodes: function(parent) {\n\t    // all preloadable nodes in inDocument\n\t    return parent.querySelectorAll(this.loadSelectorsForNode(parent));\n\t  },\n\t\n\t  // find the proper set of load selectors for a given node\n\t  loadSelectorsForNode: function(node) {\n\t    var doc = node.ownerDocument || node;\n\t    return doc === rootDocument ? this.documentPreloadSelectors :\n\t        this.importsPreloadSelectors;\n\t  },\n\t\n\t  loaded: function(url, elt, resource, err, redirectedUrl) {\n\t    flags.load && console.log('loaded', url, elt);\n\t    // store generic resource\n\t    // TODO(sorvell): fails for nodes inside <template>.content\n\t    // see https://code.google.com/p/chromium/issues/detail?id=249381.\n\t    elt.__resource = resource;\n\t    elt.__error = err;\n\t    if (isImportLink(elt)) {\n\t      var doc = this.documents[url];\n\t      // if we've never seen a document at this url\n\t      if (doc === undefined) {\n\t        // generate an HTMLDocument from data\n\t        doc = err ? null : makeDocument(resource, redirectedUrl || url);\n\t        if (doc) {\n\t          doc.__importLink = elt;\n\t          // note, we cannot use MO to detect parsed nodes because\n\t          // SD polyfill does not report these as mutations.\n\t          this.bootDocument(doc);\n\t        }\n\t        // cache document\n\t        this.documents[url] = doc;\n\t      }\n\t      // don't store import record until we're actually loaded\n\t      // store document resource\n\t      elt.__doc = doc;\n\t    }\n\t    parser.parseNext();\n\t  },\n\t\n\t  bootDocument: function(doc) {\n\t    this.loadSubtree(doc);\n\t    // observe documents for new elements being added\n\t    this.observer.observe(doc);\n\t    parser.parseNext();\n\t  },\n\t\n\t  loadedAll: function() {\n\t    parser.parseNext();\n\t  }\n\t\n\t};\n\t\n\t// loader singleton to handle loading imports\n\tvar importLoader = new Loader(importer.loaded.bind(importer),\n\t    importer.loadedAll.bind(importer));\n\t\n\t// observer singleton to handle observing elements in imports\n\t// NOTE: the observer has a node added callback and this is set\n\t// by the dynamic importer module.\n\timporter.observer = new Observer();\n\t\n\tfunction isImportLink(elt) {\n\t  return isLinkRel(elt, IMPORT_LINK_TYPE);\n\t}\n\t\n\tfunction isLinkRel(elt, rel) {\n\t  return elt.localName === 'link' && elt.getAttribute('rel') === rel;\n\t}\n\t\n\tfunction hasBaseURIAccessor(doc) {\n\t  return !! Object.getOwnPropertyDescriptor(doc, 'baseURI');\n\t}\n\t\n\tfunction makeDocument(resource, url) {\n\t  // create a new HTML document\n\t  var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);\n\t  // cache the new document's source url\n\t  doc._URL = url;\n\t  // establish a relative path via <base>\n\t  var base = doc.createElement('base');\n\t  base.setAttribute('href', url);\n\t  // add baseURI support to browsers (IE) that lack it.\n\t  if (!doc.baseURI && !hasBaseURIAccessor(doc)) {\n\t    // Use defineProperty since Safari throws an exception when using assignment.\n\t    Object.defineProperty(doc, 'baseURI', {value:url});\n\t  }\n\t  // ensure UTF-8 charset\n\t  var meta = doc.createElement('meta');\n\t  meta.setAttribute('charset', 'utf-8');\n\t\n\t  doc.head.appendChild(meta);\n\t  doc.head.appendChild(base);\n\t  // install html\n\t  doc.body.innerHTML = resource;\n\t  // TODO(sorvell): ideally this code is not aware of Template polyfill,\n\t  // but for now the polyfill needs help to bootstrap these templates\n\t  if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {\n\t    HTMLTemplateElement.bootstrap(doc);\n\t  }\n\t  return doc;\n\t}\n\t\n\t// Polyfill document.baseURI for browsers without it.\n\tif (!document.baseURI) {\n\t  var baseURIDescriptor = {\n\t    get: function() {\n\t      var base = document.querySelector('base');\n\t      return base ? base.href : window.location.href;\n\t    },\n\t    configurable: true\n\t  };\n\t\n\t  Object.defineProperty(document, 'baseURI', baseURIDescriptor);\n\t  Object.defineProperty(rootDocument, 'baseURI', baseURIDescriptor);\n\t}\n\t\n\t// exports\n\tscope.importer = importer;\n\tscope.importLoader = importLoader;\n\t\n\t});\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\twindow.HTMLImports.addModule(function(scope) {\n\t\n\t// imports\n\tvar parser = scope.parser;\n\tvar importer = scope.importer;\n\t\n\t// dynamic\n\t// highlander object to manage elements dynamically added to imports\n\t// for any observed document, dynamic:\n\t// - tells the importer to load any imports that are added.\n\t// - tells the parser to parse any added elements that need to be parsed.\n\t// dynamic importer)\n\tvar dynamic = {\n\t  // process (load/parse) any nodes added to imported documents.\n\t  added: function(nodes) {\n\t    var owner, parsed, loading;\n\t    for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {\n\t      if (!owner) {\n\t        owner = n.ownerDocument;\n\t        parsed = parser.isParsed(owner);\n\t      }\n\t      // note: the act of loading kicks the parser, so we use parseDynamic's\n\t      // 2nd argument to control if this added node needs to kick the parser.\n\t      loading = this.shouldLoadNode(n);\n\t      if (loading) {\n\t        importer.loadNode(n);\n\t      }\n\t      if (this.shouldParseNode(n) && parsed) {\n\t        parser.parseDynamic(n, loading);\n\t      }\n\t    }\n\t  },\n\t\n\t  shouldLoadNode: function(node) {\n\t    return (node.nodeType === 1) && matches.call(node,\n\t        importer.loadSelectorsForNode(node));\n\t  },\n\t\n\t  shouldParseNode: function(node) {\n\t    return (node.nodeType === 1) && matches.call(node,\n\t        parser.parseSelectorsForNode(node));\n\t  }\n\t\n\t};\n\t\n\t// let the dynamic element helper tie into the import observer.\n\timporter.observer.addCallback = dynamic.added.bind(dynamic);\n\t\n\t// x-plat matches\n\tvar matches = HTMLElement.prototype.matches ||\n\t    HTMLElement.prototype.matchesSelector ||\n\t    HTMLElement.prototype.webkitMatchesSelector ||\n\t    HTMLElement.prototype.mozMatchesSelector ||\n\t    HTMLElement.prototype.msMatchesSelector;\n\t\n\t});\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t */\n\t(function(scope){\n\t\n\t// imports\n\tvar initializeModules = scope.initializeModules;\n\tvar isIE = scope.isIE;\n\t\n\t/*\n\tNOTE: Even when native HTMLImports exists, the following api is available by\n\tloading the polyfill. This provides api compatibility where the polyfill\n\tcannot be \"correct\":\n\t\n\t  * `document._currentScript`\n\t  * `HTMLImportsLoaded` event\n\t  * `HTMLImports.whenReady(callback)\n\t*/\n\tif (scope.useNative) {\n\t  return;\n\t}\n\t\n\t// Initialize polyfill modules. Note, polyfill modules are loaded but not\n\t// executed; this is a convenient way to control which modules run when\n\t// the polyfill is required and allows the polyfill to load even when it's\n\t// not needed.\n\tinitializeModules();\n\t\n\t// imports\n\tvar rootDocument = scope.rootDocument;\n\t\n\t/*\n\t  Bootstrap the imports machine.\n\t*/\n\tfunction bootstrap() {\n\t  window.HTMLImports.importer.bootDocument(rootDocument);\n\t}\n\t\n\t// TODO(sorvell): SD polyfill does *not* generate mutations for nodes added\n\t// by the parser. For this reason, we must wait until the dom exists to\n\t// bootstrap.\n\tif (document.readyState === 'complete' ||\n\t    (document.readyState === 'interactive' && !window.attachEvent)) {\n\t  bootstrap();\n\t} else {\n\t  document.addEventListener('DOMContentLoaded', bootstrap);\n\t}\n\t\n\t})(window.HTMLImports);\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\tvar HANDJS = HANDJS || {};\r\n\t\r\n\t(function () {\r\n\t    // If the user agent already supports Pointer Events, do nothing\r\n\t    if (window.PointerEvent)\r\n\t        return;\r\n\t\r\n\t    // Polyfilling indexOf for old browsers\r\n\t    if (!Array.prototype.indexOf) {\r\n\t        Array.prototype.indexOf = function (searchElement) {\r\n\t            var t = Object(this);\r\n\t            var len = t.length >>> 0;\r\n\t            if (len === 0) {\r\n\t                return -1;\r\n\t            }\r\n\t            var n = 0;\r\n\t            if (arguments.length > 0) {\r\n\t                n = Number(arguments[1]);\r\n\t                if (n !== n) { // shortcut for verifying if it's NaN\r\n\t                    n = 0;\r\n\t                } else if (n !== 0 && n !== Infinity && n !== -Infinity) {\r\n\t                    n = (n > 0 || -1) * Math.floor(Math.abs(n));\r\n\t                }\r\n\t            }\r\n\t            if (n >= len) {\r\n\t                return -1;\r\n\t            }\r\n\t            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\r\n\t            for (; k < len; k++) {\r\n\t                if (k in t && t[k] === searchElement) {\r\n\t                    return k;\r\n\t                }\r\n\t            }\r\n\t            return -1;\r\n\t        };\r\n\t    }\r\n\t    //Polyfilling forEach for old browsers\r\n\t    if (!Array.prototype.forEach) {\r\n\t        Array.prototype.forEach = function (method, thisArg) {\r\n\t            if (!this || !(method instanceof Function))\r\n\t                throw new TypeError();\r\n\t            for (var i = 0; i < this.length; i++)\r\n\t                method.call(thisArg, this[i], i, this);\r\n\t        };\r\n\t    }\r\n\t\t// Polyfilling trim for old browsers\r\n\t\tif (!String.prototype.trim) {\r\n\t\t\tString.prototype.trim = function () {\r\n\t\t\t\treturn this.replace(/^\\s+|\\s+$/, '');\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t    // Installing Hand.js\r\n\t    var supportedEventsNames = [\"pointerdown\", \"pointerup\", \"pointermove\", \"pointerover\", \"pointerout\", \"pointercancel\", \"pointerenter\", \"pointerleave\"];\r\n\t    var upperCaseEventsNames = [\"PointerDown\", \"PointerUp\", \"PointerMove\", \"PointerOver\", \"PointerOut\", \"PointerCancel\", \"PointerEnter\", \"PointerLeave\"];\r\n\t\r\n\t    var POINTER_TYPE_TOUCH = \"touch\";\r\n\t    var POINTER_TYPE_PEN = \"pen\";\r\n\t    var POINTER_TYPE_MOUSE = \"mouse\";\r\n\t\r\n\t    var previousTargets = {};\r\n\t\r\n\t    var checkPreventDefault = function (node) {\r\n\t        while (node && !node.handjs_forcePreventDefault) {\r\n\t            node = node.parentNode;\r\n\t        }\r\n\t        return !!node || window.handjs_forcePreventDefault;\r\n\t    };\r\n\t\r\n\t    // Touch events\r\n\t    var generateTouchClonedEvent = function (sourceEvent, newName, canBubble, target, relatedTarget) {\r\n\t        // Considering touch events are almost like super mouse events\r\n\t        var evObj;\r\n\t        \r\n\t        if (document.createEvent) {\r\n\t            evObj = document.createEvent('MouseEvents');\r\n\t            evObj.initMouseEvent(newName, canBubble, true, window, 1, sourceEvent.screenX, sourceEvent.screenY,\r\n\t                sourceEvent.clientX, sourceEvent.clientY, sourceEvent.ctrlKey, sourceEvent.altKey,\r\n\t                sourceEvent.shiftKey, sourceEvent.metaKey, sourceEvent.button, relatedTarget || sourceEvent.relatedTarget);\r\n\t        }\r\n\t        else {\r\n\t            evObj = document.createEventObject();\r\n\t            evObj.screenX = sourceEvent.screenX;\r\n\t            evObj.screenY = sourceEvent.screenY;\r\n\t            evObj.clientX = sourceEvent.clientX;\r\n\t            evObj.clientY = sourceEvent.clientY;\r\n\t            evObj.ctrlKey = sourceEvent.ctrlKey;\r\n\t            evObj.altKey = sourceEvent.altKey;\r\n\t            evObj.shiftKey = sourceEvent.shiftKey;\r\n\t            evObj.metaKey = sourceEvent.metaKey;\r\n\t            evObj.button = sourceEvent.button;\r\n\t            evObj.relatedTarget = relatedTarget || sourceEvent.relatedTarget;\r\n\t        }\r\n\t        // offsets\r\n\t        if (evObj.offsetX === undefined) {\r\n\t            if (sourceEvent.offsetX !== undefined) {\r\n\t\r\n\t                // For Opera which creates readonly properties\r\n\t                if (Object && Object.defineProperty !== undefined) {\r\n\t                    Object.defineProperty(evObj, \"offsetX\", {\r\n\t                        writable: true\r\n\t                    });\r\n\t                    Object.defineProperty(evObj, \"offsetY\", {\r\n\t                        writable: true\r\n\t                    });\r\n\t                }\r\n\t\r\n\t                evObj.offsetX = sourceEvent.offsetX;\r\n\t                evObj.offsetY = sourceEvent.offsetY;\r\n\t            } else if (Object && Object.defineProperty !== undefined) {\r\n\t                Object.defineProperty(evObj, \"offsetX\", {\r\n\t                    get: function () {\r\n\t                        if (this.currentTarget && this.currentTarget.offsetLeft) {\r\n\t                            return sourceEvent.clientX - this.currentTarget.offsetLeft;\r\n\t                        }\r\n\t                        return sourceEvent.clientX;\r\n\t                    }\r\n\t                });\r\n\t                Object.defineProperty(evObj, \"offsetY\", {\r\n\t                    get: function () {\r\n\t                        if (this.currentTarget && this.currentTarget.offsetTop) {\r\n\t                            return sourceEvent.clientY - this.currentTarget.offsetTop;\r\n\t                        }\r\n\t                        return sourceEvent.clientY;\r\n\t                    }\r\n\t                });\r\n\t            }\r\n\t            else if (sourceEvent.layerX !== undefined) {\r\n\t                evObj.offsetX = sourceEvent.layerX - sourceEvent.currentTarget.offsetLeft;\r\n\t                evObj.offsetY = sourceEvent.layerY - sourceEvent.currentTarget.offsetTop;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        // adding missing properties\r\n\t\r\n\t        if (sourceEvent.isPrimary !== undefined)\r\n\t            evObj.isPrimary = sourceEvent.isPrimary;\r\n\t        else\r\n\t            evObj.isPrimary = true;\r\n\t\r\n\t        if (sourceEvent.pressure)\r\n\t            evObj.pressure = sourceEvent.pressure;\r\n\t        else {\r\n\t            var button = 0;\r\n\t\r\n\t            if (sourceEvent.which !== undefined)\r\n\t                button = sourceEvent.which;\r\n\t            else if (sourceEvent.button !== undefined) {\r\n\t                button = sourceEvent.button;\r\n\t            }\r\n\t            evObj.pressure = (button === 0) ? 0 : 0.5;\r\n\t        }\r\n\t\r\n\t\r\n\t        if (sourceEvent.rotation)\r\n\t            evObj.rotation = sourceEvent.rotation;\r\n\t        else\r\n\t            evObj.rotation = 0;\r\n\t\r\n\t        // Timestamp\r\n\t        if (sourceEvent.hwTimestamp)\r\n\t            evObj.hwTimestamp = sourceEvent.hwTimestamp;\r\n\t        else\r\n\t            evObj.hwTimestamp = 0;\r\n\t\r\n\t        // Tilts\r\n\t        if (sourceEvent.tiltX)\r\n\t            evObj.tiltX = sourceEvent.tiltX;\r\n\t        else\r\n\t            evObj.tiltX = 0;\r\n\t\r\n\t        if (sourceEvent.tiltY)\r\n\t            evObj.tiltY = sourceEvent.tiltY;\r\n\t        else\r\n\t            evObj.tiltY = 0;\r\n\t\r\n\t        // Width and Height\r\n\t        if (sourceEvent.height)\r\n\t            evObj.height = sourceEvent.height;\r\n\t        else\r\n\t            evObj.height = 0;\r\n\t\r\n\t        if (sourceEvent.width)\r\n\t            evObj.width = sourceEvent.width;\r\n\t        else\r\n\t            evObj.width = 0;\r\n\t\r\n\t        // preventDefault\r\n\t        evObj.preventDefault = function () {\r\n\t            if (sourceEvent.preventDefault !== undefined)\r\n\t                sourceEvent.preventDefault();\r\n\t        };\r\n\t\r\n\t        // stopPropagation\r\n\t        if (evObj.stopPropagation !== undefined) {\r\n\t            var current = evObj.stopPropagation;\r\n\t            evObj.stopPropagation = function () {\r\n\t                if (sourceEvent.stopPropagation !== undefined)\r\n\t                    sourceEvent.stopPropagation();\r\n\t                current.call(this);\r\n\t            };\r\n\t        }\r\n\t\r\n\t        // Pointer values\r\n\t        evObj.pointerId = sourceEvent.pointerId;\r\n\t        evObj.pointerType = sourceEvent.pointerType;\r\n\t\r\n\t        switch (evObj.pointerType) {// Old spec version check\r\n\t            case 2:\r\n\t                evObj.pointerType = POINTER_TYPE_TOUCH;\r\n\t                break;\r\n\t            case 3:\r\n\t                evObj.pointerType = POINTER_TYPE_PEN;\r\n\t                break;\r\n\t            case 4:\r\n\t                evObj.pointerType = POINTER_TYPE_MOUSE;\r\n\t                break;\r\n\t        }\r\n\t\r\n\t        // Fire event\r\n\t        if (target)\r\n\t            target.dispatchEvent(evObj);\r\n\t        else if (sourceEvent.target) {\r\n\t            sourceEvent.target.dispatchEvent(evObj);\r\n\t        } else {\r\n\t            sourceEvent.srcElement.fireEvent(\"on\" + getMouseEquivalentEventName(newName), evObj); // We must fallback to mouse event for very old browsers\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var generateMouseProxy = function (evt, eventName, canBubble, target, relatedTarget) {\r\n\t        evt.pointerId = 1;\r\n\t        evt.pointerType = POINTER_TYPE_MOUSE;\r\n\t        generateTouchClonedEvent(evt, eventName, canBubble, target, relatedTarget);\r\n\t    };\r\n\t\r\n\t    var generateTouchEventProxy = function (name, touchPoint, target, eventObject, canBubble, relatedTarget) {\r\n\t        var touchPointId = touchPoint.identifier + 2; // Just to not override mouse id\r\n\t\r\n\t        touchPoint.pointerId = touchPointId;\r\n\t        touchPoint.pointerType = POINTER_TYPE_TOUCH;\r\n\t        touchPoint.currentTarget = target;\r\n\t\r\n\t        if (eventObject.preventDefault !== undefined) {\r\n\t            touchPoint.preventDefault = function () {\r\n\t                eventObject.preventDefault();\r\n\t            };\r\n\t        }\r\n\t\r\n\t        generateTouchClonedEvent(touchPoint, name, canBubble, target, relatedTarget);\r\n\t    };\r\n\t\r\n\t    var checkEventRegistration = function (node, eventName) {\r\n\t        return node.__handjsGlobalRegisteredEvents && node.__handjsGlobalRegisteredEvents[eventName];\r\n\t    };\r\n\t    var findEventRegisteredNode = function (node, eventName) {\r\n\t        while (node && !checkEventRegistration(node, eventName))\r\n\t            node = node.parentNode;\r\n\t        if (node)\r\n\t            return node;\r\n\t        else if (checkEventRegistration(window, eventName))\r\n\t            return window;\r\n\t    };\r\n\t\r\n\t    var generateTouchEventProxyIfRegistered = function (eventName, touchPoint, target, eventObject, canBubble, relatedTarget) { // Check if user registered this event\r\n\t        if (findEventRegisteredNode(target, eventName)) {\r\n\t            generateTouchEventProxy(eventName, touchPoint, target, eventObject, canBubble, relatedTarget);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    //var handleOtherEvent = function (eventObject, name, useLocalTarget, checkRegistration) {\r\n\t    //    if (eventObject.preventManipulation)\r\n\t    //        eventObject.preventManipulation();\r\n\t\r\n\t    //    for (var i = 0; i < eventObject.changedTouches.length; ++i) {\r\n\t    //        var touchPoint = eventObject.changedTouches[i];\r\n\t\r\n\t    //        if (useLocalTarget) {\r\n\t    //            previousTargets[touchPoint.identifier] = touchPoint.target;\r\n\t    //        }\r\n\t\r\n\t    //        if (checkRegistration) {\r\n\t    //            generateTouchEventProxyIfRegistered(name, touchPoint, previousTargets[touchPoint.identifier], eventObject, true);\r\n\t    //        } else {\r\n\t    //            generateTouchEventProxy(name, touchPoint, previousTargets[touchPoint.identifier], eventObject, true);\r\n\t    //        }\r\n\t    //    }\r\n\t    //};\r\n\t\r\n\t    var getMouseEquivalentEventName = function (eventName) {\r\n\t        return eventName.toLowerCase().replace(\"pointer\", \"mouse\");\r\n\t    };\r\n\t\r\n\t    var getPrefixEventName = function (prefix, eventName) {\r\n\t        var upperCaseIndex = supportedEventsNames.indexOf(eventName);\r\n\t        var newEventName = prefix + upperCaseEventsNames[upperCaseIndex];\r\n\t\r\n\t        return newEventName;\r\n\t    };\r\n\t\r\n\t    var registerOrUnregisterEvent = function (item, name, func, enable) {\r\n\t        if (item.__handjsRegisteredEvents === undefined) {\r\n\t            item.__handjsRegisteredEvents = [];\r\n\t        }\r\n\t\r\n\t        if (enable) {\r\n\t            if (item.__handjsRegisteredEvents[name] !== undefined) {\r\n\t                item.__handjsRegisteredEvents[name]++;\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            item.__handjsRegisteredEvents[name] = 1;\r\n\t            item.addEventListener(name, func, false);\r\n\t        } else {\r\n\t\r\n\t            if (item.__handjsRegisteredEvents.indexOf(name) !== -1) {\r\n\t                item.__handjsRegisteredEvents[name]--;\r\n\t\r\n\t                if (item.__handjsRegisteredEvents[name] !== 0) {\r\n\t                    return;\r\n\t                }\r\n\t            }\r\n\t            item.removeEventListener(name, func);\r\n\t            item.__handjsRegisteredEvents[name] = 0;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var setTouchAware = function (item, eventName, enable) {\r\n\t        // Leaving tokens\r\n\t        if (!item.__handjsGlobalRegisteredEvents) {\r\n\t            item.__handjsGlobalRegisteredEvents = [];\r\n\t        }\r\n\t        if (enable) {\r\n\t            if (item.__handjsGlobalRegisteredEvents[eventName] !== undefined) {\r\n\t                item.__handjsGlobalRegisteredEvents[eventName]++;\r\n\t                return;\r\n\t            }\r\n\t            item.__handjsGlobalRegisteredEvents[eventName] = 1;\r\n\t        } else {\r\n\t            if (item.__handjsGlobalRegisteredEvents[eventName] !== undefined) {\r\n\t                item.__handjsGlobalRegisteredEvents[eventName]--;\r\n\t                if (item.__handjsGlobalRegisteredEvents[eventName] < 0) {\r\n\t                    item.__handjsGlobalRegisteredEvents[eventName] = 0;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        var nameGenerator;\r\n\t        var eventGenerator;\r\n\t        if (window.MSPointerEvent) {\r\n\t            nameGenerator = function (name) { return getPrefixEventName(\"MS\", name); };\r\n\t            eventGenerator = generateTouchClonedEvent;\r\n\t        }\r\n\t        else {\r\n\t            nameGenerator = getMouseEquivalentEventName;\r\n\t            eventGenerator = generateMouseProxy;\r\n\t        }\r\n\t        switch (eventName) {\r\n\t            case \"pointerenter\":\r\n\t            case \"pointerleave\":\r\n\t                var targetEvent = nameGenerator(eventName);\r\n\t                if (item['on' + targetEvent.toLowerCase()] !== undefined) {\r\n\t                    registerOrUnregisterEvent(item, targetEvent, function (evt) { eventGenerator(evt, eventName); }, enable);\r\n\t                }\r\n\t                break;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    // Intercept addEventListener calls by changing the prototype\r\n\t    var interceptAddEventListener = function (root) {\r\n\t        var current = root.prototype ? root.prototype.addEventListener : root.addEventListener;\r\n\t\r\n\t        var customAddEventListener = function (name, func, capture) {\r\n\t            // Branch when a PointerXXX is used\r\n\t            if (supportedEventsNames.indexOf(name) !== -1) {\r\n\t                setTouchAware(this, name, true);\r\n\t            }\r\n\t\r\n\t            if (current === undefined) {\r\n\t                this.attachEvent(\"on\" + getMouseEquivalentEventName(name), func);\r\n\t            } else {\r\n\t                current.call(this, name, func, capture);\r\n\t            }\r\n\t        };\r\n\t\r\n\t        if (root.prototype) {\r\n\t            root.prototype.addEventListener = customAddEventListener;\r\n\t        } else {\r\n\t            root.addEventListener = customAddEventListener;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    // Intercept removeEventListener calls by changing the prototype\r\n\t    var interceptRemoveEventListener = function (root) {\r\n\t        var current = root.prototype ? root.prototype.removeEventListener : root.removeEventListener;\r\n\t\r\n\t        var customRemoveEventListener = function (name, func, capture) {\r\n\t            // Release when a PointerXXX is used\r\n\t            if (supportedEventsNames.indexOf(name) !== -1) {\r\n\t                setTouchAware(this, name, false);\r\n\t            }\r\n\t\r\n\t            if (current === undefined) {\r\n\t                this.detachEvent(getMouseEquivalentEventName(name), func);\r\n\t            } else {\r\n\t                current.call(this, name, func, capture);\r\n\t            }\r\n\t        };\r\n\t        if (root.prototype) {\r\n\t            root.prototype.removeEventListener = customRemoveEventListener;\r\n\t        } else {\r\n\t            root.removeEventListener = customRemoveEventListener;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    // Hooks\r\n\t    interceptAddEventListener(window);\r\n\t    interceptAddEventListener(window.HTMLElement || window.Element);\r\n\t    interceptAddEventListener(document);\r\n\t    if (!navigator.isCocoonJS){\r\n\t        interceptAddEventListener(HTMLBodyElement);\r\n\t        interceptAddEventListener(HTMLDivElement);\r\n\t        interceptAddEventListener(HTMLImageElement);\r\n\t        interceptAddEventListener(HTMLUListElement);\r\n\t        interceptAddEventListener(HTMLAnchorElement);\r\n\t        interceptAddEventListener(HTMLLIElement);\r\n\t        interceptAddEventListener(HTMLTableElement);\r\n\t        if (window.HTMLSpanElement) {\r\n\t            interceptAddEventListener(HTMLSpanElement);\r\n\t        }\r\n\t    }\r\n\t    if (window.HTMLCanvasElement) {\r\n\t        interceptAddEventListener(HTMLCanvasElement);\r\n\t    }\r\n\t    if (!navigator.isCocoonJS && window.SVGElement) {\r\n\t        interceptAddEventListener(SVGElement);\r\n\t    }\r\n\t\r\n\t    interceptRemoveEventListener(window);\r\n\t    interceptRemoveEventListener(window.HTMLElement || window.Element);\r\n\t    interceptRemoveEventListener(document);\r\n\t    if (!navigator.isCocoonJS){\r\n\t        interceptRemoveEventListener(HTMLBodyElement);\r\n\t        interceptRemoveEventListener(HTMLDivElement);\r\n\t        interceptRemoveEventListener(HTMLImageElement);\r\n\t        interceptRemoveEventListener(HTMLUListElement);\r\n\t        interceptRemoveEventListener(HTMLAnchorElement);\r\n\t        interceptRemoveEventListener(HTMLLIElement);\r\n\t        interceptRemoveEventListener(HTMLTableElement);\r\n\t        if (window.HTMLSpanElement) {\r\n\t            interceptRemoveEventListener(HTMLSpanElement);\r\n\t        }\r\n\t    }\r\n\t    if (window.HTMLCanvasElement) {\r\n\t        interceptRemoveEventListener(HTMLCanvasElement);\r\n\t    }\r\n\t    if (!navigator.isCocoonJS && window.SVGElement) {\r\n\t        interceptRemoveEventListener(SVGElement);\r\n\t    }\r\n\t\r\n\t    // Prevent mouse event from being dispatched after Touch Events action\r\n\t    var touching = false;\r\n\t    var touchTimer = -1;\r\n\t\r\n\t    function setTouchTimer() {\r\n\t        touching = true;\r\n\t        clearTimeout(touchTimer);\r\n\t        touchTimer = setTimeout(function () {\r\n\t            touching = false;\r\n\t        }, 700);\r\n\t        // 1. Mobile browsers dispatch mouse events 300ms after touchend\r\n\t        // 2. Chrome for Android dispatch mousedown for long-touch about 650ms\r\n\t        // Result: Blocking Mouse Events for 700ms.\r\n\t    }\r\n\t\r\n\t    function getFirstCommonNode(x, y) {\r\n\t        while (x) {\r\n\t            if (x.contains(y))\r\n\t                return x;\r\n\t            x = x.parentNode;\r\n\t        }\r\n\t        return null;\r\n\t    }\r\n\t\r\n\t    //generateProxy receives a node to dispatch the event\r\n\t    function dispatchPointerEnter(currentTarget, relatedTarget, generateProxy) {\r\n\t        var commonParent = getFirstCommonNode(currentTarget, relatedTarget);\r\n\t        var node = currentTarget;\r\n\t        var nodelist = [];\r\n\t        while (node && node !== commonParent) {//target range: this to the direct child of parent relatedTarget\r\n\t            if (checkEventRegistration(node, \"pointerenter\")) //check if any parent node has pointerenter\r\n\t                nodelist.push(node);\r\n\t            node = node.parentNode;\r\n\t        }\r\n\t        while (nodelist.length > 0)\r\n\t            generateProxy(nodelist.pop());\r\n\t    }\r\n\t\r\n\t    //generateProxy receives a node to dispatch the event\r\n\t    function dispatchPointerLeave(currentTarget, relatedTarget, generateProxy) {\r\n\t        var commonParent = getFirstCommonNode(currentTarget, relatedTarget);\r\n\t        var node = currentTarget;\r\n\t        while (node && node !== commonParent) {//target range: this to the direct child of parent relatedTarget\r\n\t            if (checkEventRegistration(node, \"pointerleave\"))//check if any parent node has pointerleave\r\n\t                generateProxy(node);\r\n\t            node = node.parentNode;\r\n\t        }\r\n\t    }\r\n\t    \r\n\t    // Handling events on window to prevent unwanted super-bubbling\r\n\t    // All mouse events are affected by touch fallback\r\n\t    function applySimpleEventTunnels(nameGenerator, eventGenerator) {\r\n\t        [\"pointerdown\", \"pointermove\", \"pointerup\", \"pointerover\", \"pointerout\"].forEach(function (eventName) {\r\n\t            window.addEventListener(nameGenerator(eventName), function (evt) {\r\n\t                if (!touching && findEventRegisteredNode(evt.target, eventName))\r\n\t                    eventGenerator(evt, eventName, true);\r\n\t            });\r\n\t        });\r\n\t        if (window['on' + nameGenerator(\"pointerenter\").toLowerCase()] === undefined)\r\n\t            window.addEventListener(nameGenerator(\"pointerover\"), function (evt) {\r\n\t                if (touching)\r\n\t                    return;\r\n\t                var foundNode = findEventRegisteredNode(evt.target, \"pointerenter\");\r\n\t                if (!foundNode || foundNode === window)\r\n\t                    return;\r\n\t                else if (!foundNode.contains(evt.relatedTarget)) {\r\n\t                    dispatchPointerEnter(foundNode, evt.relatedTarget, function (targetNode) {\r\n\t                        eventGenerator(evt, \"pointerenter\", false, targetNode, evt.relatedTarget);\r\n\t                    });\r\n\t                }\r\n\t            });\r\n\t        if (window['on' + nameGenerator(\"pointerleave\").toLowerCase()] === undefined)\r\n\t            window.addEventListener(nameGenerator(\"pointerout\"), function (evt) {\r\n\t                if (touching)\r\n\t                    return;\r\n\t                var foundNode = findEventRegisteredNode(evt.target, \"pointerleave\");\r\n\t                if (!foundNode || foundNode === window)\r\n\t                    return;\r\n\t                else if (!foundNode.contains(evt.relatedTarget)) {\r\n\t                    dispatchPointerLeave(foundNode, evt.relatedTarget, function (targetNode) {\r\n\t                        eventGenerator(evt, \"pointerleave\", false, targetNode, evt.relatedTarget);\r\n\t                    });\r\n\t                }\r\n\t            });\r\n\t    }\r\n\t\r\n\t    (function () {\r\n\t        if (window.MSPointerEvent) {\r\n\t            //IE 10\r\n\t            applySimpleEventTunnels(\r\n\t                function (name) { return getPrefixEventName(\"MS\", name); },\r\n\t                generateTouchClonedEvent);\r\n\t        }\r\n\t        else {\r\n\t            applySimpleEventTunnels(getMouseEquivalentEventName, generateMouseProxy);\r\n\t\r\n\t            // Handling move on window to detect pointerleave/out/over\r\n\t            if (window.ontouchstart !== undefined) {\r\n\t                window.addEventListener('touchstart', function (eventObject) {\r\n\t                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {\r\n\t                        var touchPoint = eventObject.changedTouches[i];\r\n\t                        previousTargets[touchPoint.identifier] = touchPoint.target;\r\n\t\r\n\t                        generateTouchEventProxyIfRegistered(\"pointerover\", touchPoint, touchPoint.target, eventObject, true);\r\n\t\r\n\t                        //pointerenter should not be bubbled\r\n\t                        dispatchPointerEnter(touchPoint.target, null, function (targetNode) {\r\n\t                            generateTouchEventProxy(\"pointerenter\", touchPoint, targetNode, eventObject, false);\r\n\t                        });\r\n\t\r\n\t                        generateTouchEventProxyIfRegistered(\"pointerdown\", touchPoint, touchPoint.target, eventObject, true);\r\n\t                    }\r\n\t                    setTouchTimer();\r\n\t                });\r\n\t\r\n\t                window.addEventListener('touchend', function (eventObject) {\r\n\t                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {\r\n\t                        var touchPoint = eventObject.changedTouches[i];\r\n\t                        var currentTarget = previousTargets[touchPoint.identifier];\r\n\t\r\n\t                        generateTouchEventProxyIfRegistered(\"pointerup\", touchPoint, currentTarget, eventObject, true);\r\n\t                        generateTouchEventProxyIfRegistered(\"pointerout\", touchPoint, currentTarget, eventObject, true);\r\n\t\r\n\t                        //pointerleave should not be bubbled\r\n\t                        dispatchPointerLeave(currentTarget, null, function (targetNode) {\r\n\t                            generateTouchEventProxy(\"pointerleave\", touchPoint, targetNode, eventObject, false);\r\n\t                        });\r\n\t                    }\r\n\t                    setTouchTimer();\r\n\t                });\r\n\t\r\n\t                window.addEventListener('touchmove', function (eventObject) {\r\n\t                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {\r\n\t                        var touchPoint = eventObject.changedTouches[i];\r\n\t                        var newTarget = document.elementFromPoint(touchPoint.clientX, touchPoint.clientY);\r\n\t                        var currentTarget = previousTargets[touchPoint.identifier];\r\n\t\r\n\t                        // If force preventDefault\r\n\t                        if (currentTarget && checkPreventDefault(currentTarget) === true)\r\n\t                            eventObject.preventDefault();\r\n\t\r\n\t                        generateTouchEventProxyIfRegistered(\"pointermove\", touchPoint, currentTarget, eventObject, true);\r\n\t                        if (!navigator.isCocoonJS){\r\n\t                            var newTarget = document.elementFromPoint(touchPoint.clientX, touchPoint.clientY);\r\n\t                            if (currentTarget === newTarget) {\r\n\t                                continue; // We can skip this as the pointer is effectively over the current target\r\n\t                            }\r\n\t\r\n\t                            if (currentTarget) {\r\n\t                                // Raise out\r\n\t                                generateTouchEventProxyIfRegistered(\"pointerout\", touchPoint, currentTarget, eventObject, true, newTarget);\r\n\t\r\n\t                                // Raise leave\r\n\t                                if (!currentTarget.contains(newTarget)) { // Leave must be called if the new target is not a child of the current\r\n\t                                    dispatchPointerLeave(currentTarget, newTarget, function (targetNode) {\r\n\t                                        generateTouchEventProxy(\"pointerleave\", touchPoint, targetNode, eventObject, false, newTarget);\r\n\t                                    });\r\n\t                                }\r\n\t                            }\r\n\t\r\n\t                            if (newTarget) {\r\n\t                                // Raise over\r\n\t                                generateTouchEventProxyIfRegistered(\"pointerover\", touchPoint, newTarget, eventObject, true, currentTarget);\r\n\t\r\n\t                                // Raise enter\r\n\t                                if (!newTarget.contains(currentTarget)) { // Leave must be called if the new target is not the parent of the current\r\n\t                                    dispatchPointerEnter(newTarget, currentTarget, function (targetNode) {\r\n\t                                        generateTouchEventProxy(\"pointerenter\", touchPoint, targetNode, eventObject, false, currentTarget);\r\n\t                                    })\r\n\t                                }\r\n\t                            }\r\n\t                            previousTargets[touchPoint.identifier] = newTarget;\r\n\t                        }\r\n\t                    }\r\n\t                    setTouchTimer();\r\n\t                });\r\n\t\r\n\t                window.addEventListener('touchcancel', function (eventObject) {\r\n\t                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {\r\n\t                        var touchPoint = eventObject.changedTouches[i];\r\n\t\r\n\t                        generateTouchEventProxyIfRegistered(\"pointercancel\", touchPoint, previousTargets[touchPoint.identifier], eventObject, true);\r\n\t                    }\r\n\t                });\r\n\t            }\r\n\t        }\r\n\t    })();\r\n\t    \r\n\t\r\n\t    // Extension to navigator\r\n\t    if (navigator.pointerEnabled === undefined) {\r\n\t\r\n\t        // Indicates if the browser will fire pointer events for pointing input\r\n\t        navigator.pointerEnabled = true;\r\n\t\r\n\t        // IE\r\n\t        if (navigator.msPointerEnabled) {\r\n\t            navigator.maxTouchPoints = navigator.msMaxTouchPoints;\r\n\t        }\r\n\t    }\r\n\t})();\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function () {\n\t\n\t/*** Variables ***/\n\t\n\t  var win = window,\n\t    doc = document,\n\t    attrProto = {\n\t      setAttribute: Element.prototype.setAttribute,\n\t      removeAttribute: Element.prototype.removeAttribute\n\t    },\n\t    hasShadow = Element.prototype.createShadowRoot,\n\t    container = doc.createElement('div'),\n\t    noop = function(){},\n\t    trueop = function(){ return true; },\n\t    regexReplaceCommas = /,/g,\n\t    regexCamelToDash = /([a-z])([A-Z])/g,\n\t    regexPseudoParens = /\\(|\\)/g,\n\t    regexPseudoCapture = /:(\\w+)\\u276A(.+?(?=\\u276B))|:(\\w+)/g,\n\t    regexDigits = /(\\d+)/g,\n\t    keypseudo = {\n\t      action: function (pseudo, event) {\n\t        return pseudo.value.match(regexDigits).indexOf(String(event.keyCode)) > -1 == (pseudo.name == 'keypass') || null;\n\t      }\n\t    },\n\t    /*\n\t      - The prefix object generated here is added to the xtag object as xtag.prefix later in the code\n\t      - Prefix provides a variety of prefix variations for the browser in which your code is running\n\t      - The 4 variations of prefix are as follows:\n\t        * prefix.dom: the correct prefix case and form when used on DOM elements/style properties\n\t        * prefix.lowercase: a lowercase version of the prefix for use in various user-code situations\n\t        * prefix.css: the lowercase, dashed version of the prefix\n\t        * prefix.js: addresses prefixed APIs present in global and non-Element contexts\n\t    */\n\t    prefix = (function () {\n\t      var styles = win.getComputedStyle(doc.documentElement, ''),\n\t          pre = (Array.prototype.slice\n\t            .call(styles)\n\t            .join('')\n\t            .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])\n\t          )[1];\n\t      return {\n\t        dom: pre == 'ms' ? 'MS' : pre,\n\t        lowercase: pre,\n\t        css: '-' + pre + '-',\n\t        js: pre == 'ms' ? pre : pre[0].toUpperCase() + pre.substr(1)\n\t      };\n\t    })(),\n\t    matchSelector = Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype[prefix.lowercase + 'MatchesSelector'];\n\t\n\t  var issetCustomEvent = false;\n\t  var customEvent;\n\t  try {\n\t    customEvent = doc.createEvent('CustomEvent');\n\t    issetCustomEvent = true;\n\t  } catch(e) {\n\t    customEvent = doc.createEvent('Event');\n\t  }\n\t\n\t/*** Functions ***/\n\t\n\t// Utilities\n\t\n\t  /*\n\t    This is an enhanced typeof check for all types of objects. Where typeof would normaly return\n\t    'object' for many common DOM objects (like NodeLists and HTMLCollections).\n\t    - For example: typeOf(document.children) will correctly return 'htmlcollection'\n\t  */\n\t  var typeCache = {},\n\t      typeString = typeCache.toString,\n\t      typeRegexp = /\\s([a-zA-Z]+)/;\n\t  function typeOf(obj) {\n\t    var type = typeString.call(obj);\n\t    return typeCache[type] || (typeCache[type] = type.match(typeRegexp)[1].toLowerCase());\n\t  }\n\t\n\t  function clone(item, type){\n\t    var fn = clone[type || typeOf(item)];\n\t    return fn ? fn(item) : item;\n\t  }\n\t    clone.object = function(src){\n\t      var obj = {};\n\t      for (var key in src) obj[key] = clone(src[key]);\n\t      return obj;\n\t    };\n\t    clone.array = function(src){\n\t      var i = src.length, array = new Array(i);\n\t      while (i--) array[i] = clone(src[i]);\n\t      return array;\n\t    };\n\t\n\t  /*\n\t    The toArray() method allows for conversion of any object to a true array. For types that\n\t    cannot be converted to an array, the method returns a 1 item array containing the passed-in object.\n\t  */\n\t  var unsliceable = { 'undefined': 1, 'null': 1, 'number': 1, 'boolean': 1, 'string': 1, 'function': 1 };\n\t  function toArray(obj){\n\t    return unsliceable[typeOf(obj)] ? [obj] : Array.prototype.slice.call(obj, 0);\n\t  }\n\t\n\t// DOM\n\t\n\t  var str = '';\n\t  function query(element, selector){\n\t    return (selector || str).length ? toArray(element.querySelectorAll(selector)) : [];\n\t  }\n\t\n\t// Pseudos\n\t\n\t  function parsePseudo(fn){fn();}\n\t\n\t// Mixins\n\t\n\t  function mergeOne(source, key, current){\n\t    var type = typeOf(current);\n\t    if (type == 'object' && typeOf(source[key]) == 'object') xtag.merge(source[key], current);\n\t    else source[key] = clone(current, type);\n\t    return source;\n\t  }\n\t\n\t  function mergeMixin(tag, original, mixin, name) {\n\t    var key, keys = {};\n\t    for (var z in original) keys[z.split(':')[0]] = z;\n\t    for (z in mixin) {\n\t      key = keys[z.split(':')[0]];\n\t      if (typeof original[key] == 'function') {\n\t        if (!key.match(':mixins')) {\n\t          original[key + ':mixins'] = original[key];\n\t          delete original[key];\n\t          key = key + ':mixins';\n\t        }\n\t        original[key].__mixin__ = xtag.applyPseudos(z + (z.match(':mixins') ? '' : ':mixins'), mixin[z], tag.pseudos, original[key].__mixin__);\n\t      }\n\t      else {\n\t        original[z] = mixin[z];\n\t        delete original[key];\n\t      }\n\t    }\n\t  }\n\t\n\t  var uniqueMixinCount = 0;\n\t  function addMixin(tag, original, mixin){\n\t    for (var z in mixin){\n\t      original[z + ':__mixin__(' + (uniqueMixinCount++) + ')'] = xtag.applyPseudos(z, mixin[z], tag.pseudos);\n\t    }\n\t  }\n\t\n\t  function resolveMixins(mixins, output){\n\t    var index = mixins.length;\n\t    while (index--){\n\t      output.unshift(mixins[index]);\n\t      if (xtag.mixins[mixins[index]].mixins) resolveMixins(xtag.mixins[mixins[index]].mixins, output);\n\t    }\n\t    return output;\n\t  }\n\t\n\t  function applyMixins(tag) {\n\t    resolveMixins(tag.mixins, []).forEach(function(name){\n\t      var mixin = xtag.mixins[name];\n\t      for (var type in mixin) {\n\t        var item = mixin[type],\n\t            original = tag[type];\n\t        if (!original) tag[type] = item;\n\t        else {\n\t          switch (type){\n\t            case 'mixins': break;\n\t            case 'events': addMixin(tag, original, item); break;\n\t            case 'accessors':\n\t            case 'prototype':\n\t              for (var z in item) {\n\t                if (!original[z]) original[z] = item[z];\n\t                else mergeMixin(tag, original[z], item[z], name);\n\t              }\n\t              break;\n\t            default: mergeMixin(tag, original, item, name);\n\t          }\n\t        }\n\t      }\n\t    });\n\t    return tag;\n\t  }\n\t\n\t// Events\n\t\n\t  function delegateAction(pseudo, event) {\n\t    var match,\n\t        target = event.target,\n\t        root = event.currentTarget;\n\t    while (!match && target && target != root) {\n\t      if (target.tagName && matchSelector.call(target, pseudo.value)) match = target;\n\t      target = target.parentNode;\n\t    }\n\t    if (!match && root.tagName && matchSelector.call(root, pseudo.value)) match = root;\n\t    return match ? pseudo.listener = pseudo.listener.bind(match) : null;\n\t  }\n\t\n\t  function touchFilter(event){\n\t    return event.button === 0;\n\t  }\n\t\n\t  function writeProperty(key, event, base, desc){\n\t    if (desc) event[key] = base[key];\n\t    else Object.defineProperty(event, key, {\n\t      writable: true,\n\t      enumerable: true,\n\t      value: base[key]\n\t    });\n\t  }\n\t\n\t  var skipProps = {};\n\t  for (var z in customEvent) skipProps[z] = 1;\n\t  function inheritEvent(event, base){\n\t    var desc = Object.getOwnPropertyDescriptor(event, 'target');\n\t    for (var z in base) {\n\t      if (!skipProps[z]) writeProperty(z, event, base, desc);\n\t    }\n\t    event.baseEvent = base;\n\t  }\n\t\n\t// Accessors\n\t\n\t  function modAttr(element, attr, name, value, method){\n\t    attrProto[method].call(element, name, attr && attr.boolean ? '' : value);\n\t  }\n\t\n\t  function syncAttr(element, attr, name, value, method){\n\t    if (attr && (attr.property || attr.selector)) {\n\t      var nodes = attr.property ? [element.xtag[attr.property]] : attr.selector ? xtag.query(element, attr.selector) : [],\n\t          index = nodes.length;\n\t      while (index--) nodes[index][method](name, value);\n\t    }\n\t  }\n\t\n\t  function attachProperties(tag, prop, z, accessor, attr, name){\n\t    var key = z.split(':'), type = key[0];\n\t    if (type == 'get') {\n\t      key[0] = prop;\n\t      tag.prototype[prop].get = xtag.applyPseudos(key.join(':'), accessor[z], tag.pseudos, accessor[z]);\n\t    }\n\t    else if (type == 'set') {\n\t      key[0] = prop;\n\t      var setter = tag.prototype[prop].set = xtag.applyPseudos(key.join(':'), attr ? function(value){\n\t        var old, method = 'setAttribute';\n\t        if (attr.boolean){\n\t          value = !!value;\n\t          old = this.hasAttribute(name);\n\t          if (!value) method = 'removeAttribute';\n\t        }\n\t        else {\n\t          value = attr.validate ? attr.validate.call(this, value) : value;\n\t          old = this.getAttribute(name);\n\t        }\n\t        modAttr(this, attr, name, value, method);\n\t        accessor[z].call(this, value, old);\n\t        syncAttr(this, attr, name, value, method);\n\t      } : accessor[z] ? function(value){\n\t        accessor[z].call(this, value);\n\t      } : null, tag.pseudos, accessor[z]);\n\t\n\t      if (attr) attr.setter = accessor[z];\n\t    }\n\t    else tag.prototype[prop][z] = accessor[z];\n\t  }\n\t\n\t  function parseAccessor(tag, prop){\n\t    tag.prototype[prop] = {};\n\t    var accessor = tag.accessors[prop],\n\t        attr = accessor.attribute,\n\t        name;\n\t\n\t    if (attr) {\n\t      name = attr.name = (attr ? (attr.name || prop.replace(regexCamelToDash, '$1-$2')) : prop).toLowerCase();\n\t      attr.key = prop;\n\t      tag.attributes[name] = attr;\n\t    }\n\t\n\t    for (var z in accessor) attachProperties(tag, prop, z, accessor, attr, name);\n\t\n\t    if (attr) {\n\t      if (!tag.prototype[prop].get) {\n\t        var method = (attr.boolean ? 'has' : 'get') + 'Attribute';\n\t        tag.prototype[prop].get = function(){\n\t          return this[method](name);\n\t        };\n\t      }\n\t      if (!tag.prototype[prop].set) tag.prototype[prop].set = function(value){\n\t        value = attr.boolean ? !!value : attr.validate ? attr.validate.call(this, value) : value;\n\t        var method = attr.boolean ? (value ? 'setAttribute' : 'removeAttribute') : 'setAttribute';\n\t        modAttr(this, attr, name, value, method);\n\t        syncAttr(this, attr, name, value, method);\n\t      };\n\t    }\n\t  }\n\t\n\t  var unwrapComment = /\\/\\*!?(?:\\@preserve)?[ \\t]*(?:\\r\\n|\\n)([\\s\\S]*?)(?:\\r\\n|\\n)\\s*\\*\\//;\n\t  function parseMultiline(fn){\n\t    return typeof fn == 'function' ? unwrapComment.exec(fn.toString())[1] : fn;\n\t  }\n\t\n\t/*** X-Tag Object Definition ***/\n\t\n\t  var xtag = {\n\t    tags: {},\n\t    defaultOptions: {\n\t      pseudos: [],\n\t      mixins: [],\n\t      events: {},\n\t      methods: {},\n\t      accessors: {},\n\t      lifecycle: {},\n\t      attributes: {},\n\t      'prototype': {\n\t        xtag: {\n\t          get: function(){\n\t            return this.__xtag__ ? this.__xtag__ : (this.__xtag__ = { data: {} });\n\t          }\n\t        }\n\t      }\n\t    },\n\t    register: function (name, options) {\n\t      var _name;\n\t      if (typeof name == 'string') _name = name.toLowerCase();\n\t      else throw 'First argument must be a Custom Element string name';\n\t      xtag.tags[_name] = options || {};\n\t\n\t      var basePrototype = options.prototype;\n\t      delete options.prototype;\n\t      var tag = xtag.tags[_name].compiled = applyMixins(xtag.merge({}, xtag.defaultOptions, options));\n\t\n\t      for (var z in tag.events) tag.events[z] = xtag.parseEvent(z, tag.events[z]);\n\t      for (z in tag.lifecycle) tag.lifecycle[z.split(':')[0]] = xtag.applyPseudos(z, tag.lifecycle[z], tag.pseudos, tag.lifecycle[z]);\n\t      for (z in tag.methods) tag.prototype[z.split(':')[0]] = { value: xtag.applyPseudos(z, tag.methods[z], tag.pseudos, tag.methods[z]), enumerable: true };\n\t      for (z in tag.accessors) parseAccessor(tag, z);\n\t\n\t      if (tag.shadow) tag.shadow = tag.shadow.nodeName ? tag.shadow : xtag.createFragment(tag.shadow);\n\t      if (tag.content) tag.content = tag.content.nodeName ? tag.content.innerHTML : parseMultiline(tag.content);\n\t      var created = tag.lifecycle.created;\n\t      var finalized = tag.lifecycle.finalized;\n\t      tag.prototype.createdCallback = {\n\t        enumerable: true,\n\t        value: function(){\n\t          var element = this;\n\t          if (tag.shadow && hasShadow) this.createShadowRoot().appendChild(tag.shadow.cloneNode(true));\n\t          if (tag.content) this.appendChild(document.createElement('div')).outerHTML = tag.content;\n\t          var output = created ? created.apply(this, arguments) : null;\n\t          xtag.addEvents(this, tag.events);\n\t          for (var name in tag.attributes) {\n\t            var attr = tag.attributes[name],\n\t                hasAttr = this.hasAttribute(name),\n\t                hasDefault = attr.def !== undefined;\n\t            if (hasAttr || attr.boolean || hasDefault) {\n\t              this[attr.key] = attr.boolean ? hasAttr : !hasAttr && hasDefault ? attr.def : this.getAttribute(name);\n\t            }\n\t          }\n\t          tag.pseudos.forEach(function(obj){\n\t            obj.onAdd.call(element, obj);\n\t          });\n\t          this.xtagComponentReady = true;\n\t          if (finalized) finalized.apply(this, arguments);\n\t          return output;\n\t        }\n\t      };\n\t\n\t      var inserted = tag.lifecycle.inserted,\n\t          removed = tag.lifecycle.removed;\n\t      if (inserted || removed) {\n\t        tag.prototype.attachedCallback = { value: function(){\n\t          if (removed) this.xtag.__parentNode__ = this.parentNode;\n\t          if (inserted) return inserted.apply(this, arguments);\n\t        }, enumerable: true };\n\t      }\n\t      if (removed) {\n\t        tag.prototype.detachedCallback = { value: function(){\n\t          var args = toArray(arguments);\n\t          args.unshift(this.xtag.__parentNode__);\n\t          var output = removed.apply(this, args);\n\t          delete this.xtag.__parentNode__;\n\t          return output;\n\t        }, enumerable: true };\n\t      }\n\t      if (tag.lifecycle.attributeChanged) tag.prototype.attributeChangedCallback = { value: tag.lifecycle.attributeChanged, enumerable: true };\n\t\n\t      tag.prototype.setAttribute = {\n\t        writable: true,\n\t        enumerable: true,\n\t        value: function (name, value){\n\t          var old;\n\t          var _name = name.toLowerCase();\n\t          var attr = tag.attributes[_name];\n\t          if (attr) {\n\t            old = this.getAttribute(_name);\n\t            value = attr.boolean ? '' : attr.validate ? attr.validate.call(this, value) : value;\n\t          }\n\t          modAttr(this, attr, _name, value, 'setAttribute');\n\t          if (attr) {\n\t            if (attr.setter) attr.setter.call(this, attr.boolean ? true : value, old);\n\t            syncAttr(this, attr, _name, value, 'setAttribute');\n\t          }\n\t        }\n\t      };\n\t\n\t      tag.prototype.removeAttribute = {\n\t        writable: true,\n\t        enumerable: true,\n\t        value: function (name){\n\t          var _name = name.toLowerCase();\n\t          var attr = tag.attributes[_name];\n\t          var old = this.hasAttribute(_name);\n\t          modAttr(this, attr, _name, '', 'removeAttribute');\n\t          if (attr) {\n\t            if (attr.setter) attr.setter.call(this, attr.boolean ? false : undefined, old);\n\t            syncAttr(this, attr, _name, '', 'removeAttribute');\n\t          }\n\t        }\n\t      };\n\t\n\t      var elementProto = basePrototype ?\n\t            basePrototype :\n\t            tag['extends'] ?\n\t            Object.create(doc.createElement(tag['extends']).constructor).prototype :\n\t            win.HTMLElement.prototype;\n\t\n\t      var definition = {\n\t        'prototype': Object.create(elementProto, tag.prototype)\n\t      };\n\t      if (tag['extends']) {\n\t        definition['extends'] = tag['extends'];\n\t      }\n\t      var reg = doc.registerElement(_name, definition);\n\t      return reg;\n\t    },\n\t\n\t    /* Exposed Variables */\n\t\n\t    mixins: {},\n\t    prefix: prefix,\n\t    captureEvents: { focus: 1, blur: 1, scroll: 1, DOMMouseScroll: 1 },\n\t    customEvents: {\n\t      animationstart: {\n\t        attach: [prefix.dom + 'AnimationStart']\n\t      },\n\t      animationend: {\n\t        attach: [prefix.dom + 'AnimationEnd']\n\t      },\n\t      transitionend: {\n\t        attach: [prefix.dom + 'TransitionEnd']\n\t      },\n\t      move: {\n\t        attach: ['pointermove']\n\t      },\n\t      enter: {\n\t        attach: ['pointerenter']\n\t      },\n\t      leave: {\n\t        attach: ['pointerleave']\n\t      },\n\t      scrollwheel: {\n\t        attach: ['DOMMouseScroll', 'mousewheel'],\n\t        condition: function(event){\n\t          event.delta = event.wheelDelta ? event.wheelDelta / 40 : Math.round(event.detail / 3.5 * -1);\n\t          return true;\n\t        }\n\t      },\n\t      tap: {\n\t        attach: ['pointerdown', 'pointerup'],\n\t        condition: function(event, custom){\n\t          if (event.type == 'pointerdown') {\n\t            custom.startX = event.clientX;\n\t            custom.startY = event.clientY;\n\t          }\n\t          else if (event.button === 0 &&\n\t                   Math.abs(custom.startX - event.clientX) < 10 &&\n\t                   Math.abs(custom.startY - event.clientY) < 10) return true;\n\t        }\n\t      },\n\t      tapstart: {\n\t        attach: ['pointerdown'],\n\t        condition: touchFilter\n\t      },\n\t      tapend: {\n\t        attach: ['pointerup'],\n\t        condition: touchFilter\n\t      },\n\t      tapmove: {\n\t        attach: ['pointerdown', 'pointerup'],\n\t        condition: function(event, custom){\n\t          if (event.type == 'pointerdown') {\n\t            if (!custom.moveListener) custom.moveListener = xtag.addEvent(this, 'pointermove', custom.listener);\n\t          }\n\t          else if (event.type == 'pointerup') {\n\t            xtag.removeEvent(this, custom.moveListener);\n\t            custom.moveListener = null;\n\t          }\n\t          else return true;\n\t        }\n\t      },\n\t      taphold: {\n\t        attach: ['pointerdown', 'pointerup'],\n\t        condition: function(event, custom){\n\t          if (event.type == 'pointerdown') {\n\t            (custom.pointers = custom.pointers || {})[event.pointerId] = setTimeout(\n\t              xtag.fireEvent.bind(null, this, 'taphold'),\n\t              custom.duration || 1000\n\t            );\n\t          }\n\t          else if (event.type == 'pointerup') {\n\t            if (custom.pointers) {\n\t              clearTimeout(custom.pointers[event.pointerId]);\n\t              delete custom.pointers[event.pointerId];\n\t            }\n\t          }\n\t          else return true;\n\t        }\n\t      }\n\t    },\n\t    pseudos: {\n\t      __mixin__: {},\n\t      mixins: {\n\t        onCompiled: function(fn, pseudo){\n\t          var mixin = pseudo.source && pseudo.source.__mixin__ || pseudo.source;\n\t          if (mixin) switch (pseudo.value) {\n\t            case null: case '': case 'before': return function(){\n\t              mixin.apply(this, arguments);\n\t              return fn.apply(this, arguments);\n\t            };\n\t            case 'after': return function(){\n\t              var returns = fn.apply(this, arguments);\n\t              mixin.apply(this, arguments);\n\t              return returns;\n\t            };\n\t            case 'none': return fn;\n\t          }\n\t          else return fn;\n\t        }\n\t      },\n\t      keypass: keypseudo,\n\t      keyfail: keypseudo,\n\t      delegate: {\n\t        action: delegateAction\n\t      },\n\t      preventable: {\n\t        action: function (pseudo, event) {\n\t          return !event.defaultPrevented;\n\t        }\n\t      },\n\t      duration: {\n\t        onAdd: function(pseudo){\n\t          pseudo.source.duration = Number(pseudo.value);\n\t        }\n\t      },\n\t      capture: {\n\t        onCompiled: function(fn, pseudo){\n\t          if (pseudo.source) pseudo.source.capture = true;\n\t        }\n\t      }\n\t    },\n\t\n\t    /* UTILITIES */\n\t\n\t    clone: clone,\n\t    typeOf: typeOf,\n\t    toArray: toArray,\n\t\n\t    wrap: function (original, fn) {\n\t      return function(){\n\t        var output = original.apply(this, arguments);\n\t        fn.apply(this, arguments);\n\t        return output;\n\t      };\n\t    },\n\t    /*\n\t      Recursively merges one object with another. The first argument is the destination object,\n\t      all other objects passed in as arguments are merged from right to left, conflicts are overwritten\n\t    */\n\t    merge: function(source, k, v){\n\t      if (typeOf(k) == 'string') return mergeOne(source, k, v);\n\t      for (var i = 1, l = arguments.length; i < l; i++){\n\t        var object = arguments[i];\n\t        for (var key in object) mergeOne(source, key, object[key]);\n\t      }\n\t      return source;\n\t    },\n\t\n\t    /*\n\t      ----- This should be simplified! -----\n\t      Generates a random ID string\n\t    */\n\t    uid: function(){\n\t      return Math.random().toString(36).substr(2,10);\n\t    },\n\t\n\t    /* DOM */\n\t\n\t    query: query,\n\t\n\t    skipTransition: function(element, fn, bind){\n\t      var prop = prefix.js + 'TransitionProperty';\n\t      element.style[prop] = element.style.transitionProperty = 'none';\n\t      var callback = fn ? fn.call(bind || element) : null;\n\t      return xtag.skipFrame(function(){\n\t        element.style[prop] = element.style.transitionProperty = '';\n\t        if (callback) callback.call(bind || element);\n\t      });\n\t    },\n\t\n\t    requestFrame: (function(){\n\t      var raf = win.requestAnimationFrame ||\n\t                win[prefix.lowercase + 'RequestAnimationFrame'] ||\n\t                function(fn){ return win.setTimeout(fn, 20); };\n\t      return function(fn){ return raf(fn); };\n\t    })(),\n\t\n\t    cancelFrame: (function(){\n\t      var cancel = win.cancelAnimationFrame ||\n\t                   win[prefix.lowercase + 'CancelAnimationFrame'] ||\n\t                   win.clearTimeout;\n\t      return function(id){ return cancel(id); };\n\t    })(),\n\t\n\t    skipFrame: function(fn){\n\t      var id = xtag.requestFrame(function(){ id = xtag.requestFrame(fn); });\n\t      return id;\n\t    },\n\t\n\t    matchSelector: function (element, selector) {\n\t      return matchSelector.call(element, selector);\n\t    },\n\t\n\t    set: function (element, method, value) {\n\t      element[method] = value;\n\t      if (window.CustomElements) CustomElements.upgradeAll(element);\n\t    },\n\t\n\t    innerHTML: function(el, html){\n\t      xtag.set(el, 'innerHTML', html);\n\t    },\n\t\n\t    hasClass: function (element, klass) {\n\t      return element.className.split(' ').indexOf(klass.trim())>-1;\n\t    },\n\t\n\t    addClass: function (element, klass) {\n\t      var list = element.className.trim().split(' ');\n\t      klass.trim().split(' ').forEach(function (name) {\n\t        if (!~list.indexOf(name)) list.push(name);\n\t      });\n\t      element.className = list.join(' ').trim();\n\t      return element;\n\t    },\n\t\n\t    removeClass: function (element, klass) {\n\t      var classes = klass.trim().split(' ');\n\t      element.className = element.className.trim().split(' ').filter(function (name) {\n\t        return name && !~classes.indexOf(name);\n\t      }).join(' ');\n\t      return element;\n\t    },\n\t\n\t    toggleClass: function (element, klass) {\n\t      return xtag[xtag.hasClass(element, klass) ? 'removeClass' : 'addClass'].call(null, element, klass);\n\t    },\n\t\n\t    /*\n\t      Runs a query on only the children of an element\n\t    */\n\t    queryChildren: function (element, selector) {\n\t      var id = element.id,\n\t          attr = '#' + (element.id = id || 'x_' + xtag.uid()) + ' > ',\n\t          parent = element.parentNode || !container.appendChild(element);\n\t      selector = attr + (selector + '').replace(regexReplaceCommas, ',' + attr);\n\t      var result = element.parentNode.querySelectorAll(selector);\n\t      if (!id) element.removeAttribute('id');\n\t      if (!parent) container.removeChild(element);\n\t      return toArray(result);\n\t    },\n\t\n\t    /*\n\t      Creates a document fragment with the content passed in - content can be\n\t      a string of HTML, an element, or an array/collection of elements\n\t    */\n\t    createFragment: function(content) {\n\t      var template = document.createElement('template');\n\t      if (content) {\n\t        if (content.nodeName) toArray(arguments).forEach(function(e){\n\t          template.content.appendChild(e);\n\t        });\n\t        else template.innerHTML = parseMultiline(content);\n\t      }\n\t      return template.content;\n\t    },\n\t\n\t    /*\n\t      Removes an element from the DOM for more performant node manipulation. The element\n\t      is placed back into the DOM at the place it was taken from.\n\t    */\n\t    manipulate: function(element, fn){\n\t      var next = element.nextSibling,\n\t          parent = element.parentNode,\n\t          returned = fn.call(element) || element;\n\t      if (next) parent.insertBefore(returned, next);\n\t      else parent.appendChild(returned);\n\t    },\n\t\n\t    /* PSEUDOS */\n\t\n\t    applyPseudos: function(key, fn, target, source) {\n\t      var listener = fn,\n\t          pseudos = {};\n\t      if (key.match(':')) {\n\t        var matches = [],\n\t            valueFlag = 0;\n\t        key.replace(regexPseudoParens, function(match){\n\t          if (match == '(') return ++valueFlag == 1 ? '\\u276A' : '(';\n\t          return !--valueFlag ? '\\u276B' : ')';\n\t        }).replace(regexPseudoCapture, function(z, name, value, solo){\n\t          matches.push([name || solo, value]);\n\t        });\n\t        var i = matches.length;\n\t        while (i--) parsePseudo(function(){\n\t          var name = matches[i][0],\n\t              value = matches[i][1];\n\t          if (!xtag.pseudos[name]) throw \"pseudo not found: \" + name + \" \" + value;\n\t          value = (value === '' || typeof value == 'undefined') ? null : value;\n\t          var pseudo = pseudos[i] = Object.create(xtag.pseudos[name]);\n\t          pseudo.key = key;\n\t          pseudo.name = name;\n\t          pseudo.value = value;\n\t          pseudo['arguments'] = (value || '').split(',');\n\t          pseudo.action = pseudo.action || trueop;\n\t          pseudo.source = source;\n\t          pseudo.onAdd = pseudo.onAdd || noop;\n\t          pseudo.onRemove = pseudo.onRemove || noop;\n\t          var original = pseudo.listener = listener;\n\t          listener = function(){\n\t            var output = pseudo.action.apply(this, [pseudo].concat(toArray(arguments)));\n\t            if (output === null || output === false) return output;\n\t            output = pseudo.listener.apply(this, arguments);\n\t            pseudo.listener = original;\n\t            return output;\n\t          };\n\t          if (!target) pseudo.onAdd.call(fn, pseudo);\n\t          else target.push(pseudo);\n\t        });\n\t      }\n\t      for (var z in pseudos) {\n\t        if (pseudos[z].onCompiled) listener = pseudos[z].onCompiled(listener, pseudos[z]) || listener;\n\t      }\n\t      return listener;\n\t    },\n\t\n\t    removePseudos: function(target, pseudos){\n\t      pseudos.forEach(function(obj){\n\t        obj.onRemove.call(target, obj);\n\t      });\n\t    },\n\t\n\t  /*** Events ***/\n\t\n\t    parseEvent: function(type, fn) {\n\t      var pseudos = type.split(':'),\n\t          key = pseudos.shift(),\n\t          custom = xtag.customEvents[key],\n\t          event = xtag.merge({\n\t            type: key,\n\t            stack: noop,\n\t            condition: trueop,\n\t            capture: xtag.captureEvents[key],\n\t            attach: [],\n\t            _attach: [],\n\t            pseudos: '',\n\t            _pseudos: [],\n\t            onAdd: noop,\n\t            onRemove: noop\n\t          }, custom || {});\n\t      event.attach = toArray(event.base || event.attach);\n\t      event.chain = key + (event.pseudos.length ? ':' + event.pseudos : '') + (pseudos.length ? ':' + pseudos.join(':') : '');\n\t      var stack = xtag.applyPseudos(event.chain, fn, event._pseudos, event);\n\t      event.stack = function(e){\n\t        e.currentTarget = e.currentTarget || this;\n\t        var detail = e.detail || {};\n\t        if (!detail.__stack__) return stack.apply(this, arguments);\n\t        else if (detail.__stack__ == stack) {\n\t          e.stopPropagation();\n\t          e.cancelBubble = true;\n\t          return stack.apply(this, arguments);\n\t        }\n\t      };\n\t      event.listener = function(e){\n\t        var args = toArray(arguments),\n\t            output = event.condition.apply(this, args.concat([event]));\n\t        if (!output) return output;\n\t        // The second condition in this IF is to address the following Blink regression: https://code.google.com/p/chromium/issues/detail?id=367537\n\t        // Remove this when affected browser builds with this regression fall below 5% marketshare\n\t        if (e.type != key && (e.baseEvent && e.type != e.baseEvent.type)) {\n\t          xtag.fireEvent(e.target, key, {\n\t            baseEvent: e,\n\t            detail: output !== true && (output.__stack__ = stack) ? output : { __stack__: stack }\n\t          });\n\t        }\n\t        else return event.stack.apply(this, args);\n\t      };\n\t      event.attach.forEach(function(name) {\n\t        event._attach.push(xtag.parseEvent(name, event.listener));\n\t      });\n\t      return event;\n\t    },\n\t\n\t    addEvent: function (element, type, fn, capture) {\n\t      var event = typeof fn == 'function' ? xtag.parseEvent(type, fn) : fn;\n\t      event._pseudos.forEach(function(obj){\n\t        obj.onAdd.call(element, obj);\n\t      });\n\t      event._attach.forEach(function(obj) {\n\t        xtag.addEvent(element, obj.type, obj);\n\t      });\n\t      event.onAdd.call(element, event, event.listener);\n\t      element.addEventListener(event.type, event.stack, capture || event.capture);\n\t      return event;\n\t    },\n\t\n\t    addEvents: function (element, obj) {\n\t      var events = {};\n\t      for (var z in obj) {\n\t        events[z] = xtag.addEvent(element, z, obj[z]);\n\t      }\n\t      return events;\n\t    },\n\t\n\t    removeEvent: function (element, type, event) {\n\t      event = event || type;\n\t      event.onRemove.call(element, event, event.listener);\n\t      xtag.removePseudos(element, event._pseudos);\n\t      event._attach.forEach(function(obj) {\n\t        xtag.removeEvent(element, obj);\n\t      });\n\t      element.removeEventListener(event.type, event.stack, false);\n\t    },\n\t\n\t    removeEvents: function(element, obj){\n\t      for (var z in obj) xtag.removeEvent(element, obj[z]);\n\t    },\n\t\n\t    fireEvent: function(element, type, options){\n\t      options = options || {};\n\t\n\t      var event;\n\t      var bubbles = options.bubbles !== false;\n\t      var cancelable = options.cancelable !== false;\n\t\n\t      if (issetCustomEvent) {\n\t        event = doc.createEvent('CustomEvent');\n\t        event.initCustomEvent(type, bubbles, cancelable, options.detail);\n\t\n\t      } else {\n\t        event = doc.createEvent('Event');\n\t        event.initEvent(type, bubbles, cancelable);\n\t        event.detail = options.detail;\n\t      }\n\t\n\t      if (options.baseEvent) inheritEvent(event, options.baseEvent);\n\t\n\t      element.dispatchEvent(event);\n\t    }\n\t  };\n\t\n\t  if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (xtag), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  else if (typeof module !== 'undefined' && module.exports) module.exports = xtag;\n\t  else win.xtag = xtag;\n\t\n\t  doc.addEventListener('WebComponentsReady', function(){\n\t    xtag.fireEvent(doc.body, 'DOMComponentsLoaded');\n\t  }, false);\n\t\n\t})();\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** x-tag-core.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 947234f86f83a66d9b4d\n **/","import context from './context';\n\ncontext.Platform = {};\n\n/* eslint no-unused-vars:0 */\nvar logFlags = {\n    // dom: true\n    // data: true\n};\n\nimport './polyfills/performance';\nimport './polyfills/matches';\nimport './polyfills/CustomEvent';\nimport './polyfills/DOMAttrModified';\n\nimport 'dom-token-list-polyfill/src/token-list.js';\nimport 'webcomponents.js/src/WeakMap/WeakMap.js';\nimport 'webcomponents.js/src/MutationObserver/MutationObserver.js';\n\nimport 'webcomponents.js/src/CustomElements/base.js';\nimport 'webcomponents.js/src/CustomElements/traverse.js';\nimport 'webcomponents.js/src/CustomElements/observe.js';\nimport 'webcomponents.js/src/CustomElements/upgrade.js';\nimport 'webcomponents.js/src/CustomElements/register.js';\nimport 'webcomponents.js/src/CustomElements/boot.js';\n\nimport 'webcomponents.js/src/HTMLImports/base.js';\nimport 'webcomponents.js/src/HTMLImports/module.js';\nimport 'webcomponents.js/src/HTMLImports/path.js';\nimport 'webcomponents.js/src/HTMLImports/xhr.js';\nimport 'webcomponents.js/src/HTMLImports/Loader.js';\nimport 'webcomponents.js/src/HTMLImports/Observer.js';\nimport 'webcomponents.js/src/HTMLImports/parser.js';\nimport 'webcomponents.js/src/HTMLImports/importer.js';\nimport 'webcomponents.js/src/HTMLImports/dynamic.js';\nimport 'webcomponents.js/src/HTMLImports/boot.js';\n\nimport 'handjs/hand.base.js';\nimport xtag from 'x-tag/src/core.js';\n\ncontext.xtag = xtag;\n\nexport default xtag;\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/preprocess-loader?NODE_ENV=production!./xtag.js\n **/","var context = (function () {\n    return this || (1, eval)('this');\n})();\n\nexport default context;\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/preprocess-loader?NODE_ENV=production!./context.js\n **/","import context from '../context';\n\nif (typeof context.performance === 'undefined') {\n    context.performance = {};\n}\n\nif (!context.performance.now) {\n    var nowOffset;\n\n    if (context.performance.timing && context.performance.timing.navigationStart) {\n        nowOffset = context.performance.timing.navigationStar;\n\n    } else {\n        nowOffset = Date.now();\n    }\n\n    context.performance.now = function () {\n        return (Date.now() - nowOffset);\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/preprocess-loader?NODE_ENV=production!./polyfills/performance.js\n **/","import context from '../context';\n\nconst indexOf = Array.prototype.indexOf;\nconst proto = context.Element.prototype;\n\nproto.matches = proto.matches ||\n    proto.matchesSelector ||\n    proto.webkitMatchesSelector ||\n    proto.mozMatchesSelector ||\n    proto.msMatchesSelector ||\n    proto.oMatchesSelector ||\n    function (selector) {\n        return (indexOf.call((this.parentNode || this.ownerDocument).querySelectorAll(selector), this) !== -1);\n    };\n\nexport default proto.matches;\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/preprocess-loader?NODE_ENV=production!./polyfills/matches.js\n **/","/**\n * strange commit, checks CustomEvent only in IE\n * https://github.com/webcomponents/webcomponentsjs/commit/8d6a38aa6e3d03ff54a41db9e9725401bbc1446c\n */\n\nimport context from '../context';\n\nif (typeof context.CustomEvent !== 'function') {\n    context.CustomEvent = require('./CustomEventCommon');\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/preprocess-loader?NODE_ENV=production!./polyfills/CustomEvent.js\n **/","import context from '../context';\n\nvar CustomEventCommon;\nvar issetCustomEvent = false;\n\ntry {\n    issetCustomEvent = Boolean(context.document.createEvent('CustomEvent'));\n} catch (e) {\n    // do nothing\n}\n\nif (issetCustomEvent) {\n    CustomEventCommon = function (eventName, params) {\n        params = params || {};\n\n        var bubbles = Boolean(params.bubbles);\n        var cancelable = Boolean(params.cancelable);\n        var evt = context.document.createEvent('CustomEvent');\n\n        evt.initCustomEvent(eventName, bubbles, cancelable, params.detail);\n\n        return evt;\n    };\n\n} else {\n    CustomEventCommon = function (eventName, params) {\n        params = params || {};\n\n        var bubbles = Boolean(params.bubbles);\n        var cancelable = Boolean(params.cancelable);\n        var evt = context.document.createEvent('Event');\n\n        evt.initEvent(eventName, bubbles, cancelable);\n        evt.detail = params.detail;\n\n        return evt;\n    };\n}\n\nCustomEventCommon.prototype = context.Event.prototype;\n\nexport default CustomEventCommon;\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/preprocess-loader?NODE_ENV=production!./polyfills/CustomEventCommon.js\n **/","/**\n * @see http://engineering.silk.co/post/31921750832/mutation-events-what-happens\n */\n\nimport context from '../context';\n\nvar attrModifiedWorks = false;\nvar listener = function () {\n    attrModifiedWorks = true;\n};\n\nvar htmlElement = context.document.documentElement;\nhtmlElement.addEventListener('DOMAttrModified', listener, false);\nhtmlElement.setAttribute('___TEST___', true);\nhtmlElement.removeEventListener('DOMAttrModified', listener, false);\nhtmlElement.removeAttribute('___TEST___', true);\n\nif (!attrModifiedWorks) {\n    var proto = context.Element.prototype;\n\n    proto.__setAttribute = proto.setAttribute;\n    proto.setAttribute = function (attrName, newVal) {\n        var prevVal = this.getAttribute(attrName);\n        this.__setAttribute(attrName, newVal);\n        newVal = this.getAttribute(attrName);\n        if (newVal !== prevVal) {\n            var evt = context.document.createEvent('MutationEvent');\n            evt.initMutationEvent(\n                'DOMAttrModified',\n                true,\n                false,\n                this,\n                prevVal || '',\n                newVal || '',\n                attrName,\n                (prevVal === null) ? evt.ADDITION : evt.MODIFICATION\n            );\n            this.dispatchEvent(evt);\n        }\n    };\n\n    proto.__removeAttribute = proto.removeAttribute;\n    proto.removeAttribute = function (attrName) {\n        var prevVal = this.getAttribute(attrName);\n        this.__removeAttribute(attrName);\n        var evt = context.document.createEvent('MutationEvent');\n        evt.initMutationEvent(\n            'DOMAttrModified',\n            true,\n            false,\n            this,\n            prevVal,\n            '',\n            attrName,\n            evt.REMOVAL\n        );\n        this.dispatchEvent(evt);\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/preprocess-loader?NODE_ENV=production!./polyfills/DOMAttrModified.js\n **/","// DOMTokenList polyfill for IE9\n(function () {\n\nif (typeof window.Element === \"undefined\" || \"classList\" in document.documentElement) return;\n\nvar prototype = Array.prototype,\n    indexOf = prototype.indexOf,\n    slice = prototype.slice,\n    push = prototype.push,\n    splice = prototype.splice,\n    join = prototype.join;\n\nfunction DOMTokenList(el) {\n  this._element = el;\n  if (el.className != this._classCache) {\n    this._classCache = el.className;\n\n    if (!this._classCache) return;\n\n      // The className needs to be trimmed and split on whitespace\n      // to retrieve a list of classes.\n      var classes = this._classCache.replace(/^\\s+|\\s+$/g,'').split(/\\s+/),\n        i;\n    for (i = 0; i < classes.length; i++) {\n      push.call(this, classes[i]);\n    }\n  }\n};\n\nfunction setToClassName(el, classes) {\n  el.className = classes.join(' ');\n}\n\nDOMTokenList.prototype = {\n  add: function(token) {\n    if(this.contains(token)) return;\n    push.call(this, token);\n    setToClassName(this._element, slice.call(this, 0));\n  },\n  contains: function(token) {\n    return indexOf.call(this, token) !== -1;\n  },\n  item: function(index) {\n    return this[index] || null;\n  },\n  remove: function(token) {\n    var i = indexOf.call(this, token);\n     if (i === -1) {\n       return;\n     }\n    splice.call(this, i, 1);\n    setToClassName(this._element, slice.call(this, 0));\n  },\n  toString: function() {\n    return join.call(this, ' ');\n  },\n  toggle: function(token) {\n    if (indexOf.call(this, token) === -1) {\n      this.add(token);\n    } else {\n      this.remove(token);\n    }\n  }\n};\n\nwindow.DOMTokenList = DOMTokenList;\n\nfunction defineElementGetter (obj, prop, getter) {\n  if (Object.defineProperty) {\n    Object.defineProperty(obj, prop,{\n      get : getter\n    })\n  } else {\n    obj.__defineGetter__(prop, getter);\n  }\n}\n\ndefineElementGetter(Element.prototype, 'classList', function () {\n  return new DOMTokenList(this);\n});\n\n})();\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/dom-token-list-polyfill/src/token-list.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nif (typeof WeakMap === 'undefined') {\n  (function() {\n    var defineProperty = Object.defineProperty;\n    var counter = Date.now() % 1e9;\n\n    var WeakMap = function() {\n      this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');\n    };\n\n    WeakMap.prototype = {\n      set: function(key, value) {\n        var entry = key[this.name];\n        if (entry && entry[0] === key)\n          entry[1] = value;\n        else\n          defineProperty(key, this.name, {value: [key, value], writable: true});\n        return this;\n      },\n      get: function(key) {\n        var entry;\n        return (entry = key[this.name]) && entry[0] === key ?\n            entry[1] : undefined;\n      },\n      delete: function(key) {\n        var entry = key[this.name];\n        if (!entry || entry[0] !== key) return false;\n        entry[0] = entry[1] = undefined;\n        return true;\n      },\n      has: function(key) {\n        var entry = key[this.name];\n        if (!entry) return false;\n        return entry[0] === key;\n      }\n    };\n\n    window.WeakMap = WeakMap;\n  })();\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/WeakMap/WeakMap.js\n ** module id = 8\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(global) {\n\n  // Don't allow this object to be redefined.\n  if (global.JsMutationObserver) {\n    return;\n  }\n\n  var registrationsTable = new WeakMap();\n\n  var setImmediate;\n\n  // As much as we would like to use the native implementation, IE\n  // (all versions) suffers a rather annoying bug where it will drop or defer\n  // callbacks when heavy DOM operations are being performed concurrently.\n  //\n  // For a thorough discussion on this, see:\n  // http://codeforhire.com/2013/09/21/setimmediate-and-messagechannel-broken-on-internet-explorer-10/\n  if (/Trident|Edge/.test(navigator.userAgent)) {\n    // Sadly, this bug also affects postMessage and MessageQueues.\n    //\n    // We would like to use the onreadystatechange hack for IE <= 10, but it is\n    // dangerous in the polyfilled environment due to requiring that the\n    // observed script element be in the document.\n    setImmediate = setTimeout;\n\n  // If some other browser ever implements it, let's prefer their native\n  // implementation:\n  } else if (window.setImmediate) {\n    setImmediate = window.setImmediate;\n\n  // Otherwise, we fall back to postMessage as a means of emulating the next\n  // task semantics of setImmediate.\n  } else {\n    var setImmediateQueue = [];\n    var sentinel = String(Math.random());\n    window.addEventListener('message', function(e) {\n      if (e.data === sentinel) {\n        var queue = setImmediateQueue;\n        setImmediateQueue = [];\n        queue.forEach(function(func) {\n          func();\n        });\n      }\n    });\n    setImmediate = function(func) {\n      setImmediateQueue.push(func);\n      window.postMessage(sentinel, '*');\n    };\n  }\n\n  // This is used to ensure that we never schedule 2 callas to setImmediate\n  var isScheduled = false;\n\n  // Keep track of observers that needs to be notified next time.\n  var scheduledObservers = [];\n\n  /**\n   * Schedules |dispatchCallback| to be called in the future.\n   * @param {MutationObserver} observer\n   */\n  function scheduleCallback(observer) {\n    scheduledObservers.push(observer);\n    if (!isScheduled) {\n      isScheduled = true;\n      setImmediate(dispatchCallbacks);\n    }\n  }\n\n  function wrapIfNeeded(node) {\n    return window.ShadowDOMPolyfill &&\n        window.ShadowDOMPolyfill.wrapIfNeeded(node) ||\n        node;\n  }\n\n  function dispatchCallbacks() {\n    // http://dom.spec.whatwg.org/#mutation-observers\n\n    isScheduled = false; // Used to allow a new setImmediate call above.\n\n    var observers = scheduledObservers;\n    scheduledObservers = [];\n    // Sort observers based on their creation UID (incremental).\n    observers.sort(function(o1, o2) {\n      return o1.uid_ - o2.uid_;\n    });\n\n    var anyNonEmpty = false;\n    observers.forEach(function(observer) {\n\n      // 2.1, 2.2\n      var queue = observer.takeRecords();\n      // 2.3. Remove all transient registered observers whose observer is mo.\n      removeTransientObserversFor(observer);\n\n      // 2.4\n      if (queue.length) {\n        observer.callback_(queue, observer);\n        anyNonEmpty = true;\n      }\n    });\n\n    // 3.\n    if (anyNonEmpty)\n      dispatchCallbacks();\n  }\n\n  function removeTransientObserversFor(observer) {\n    observer.nodes_.forEach(function(node) {\n      var registrations = registrationsTable.get(node);\n      if (!registrations)\n        return;\n      registrations.forEach(function(registration) {\n        if (registration.observer === observer)\n          registration.removeTransientObservers();\n      });\n    });\n  }\n\n  /**\n   * This function is used for the \"For each registered observer observer (with\n   * observer's options as options) in target's list of registered observers,\n   * run these substeps:\" and the \"For each ancestor ancestor of target, and for\n   * each registered observer observer (with options options) in ancestor's list\n   * of registered observers, run these substeps:\" part of the algorithms. The\n   * |options.subtree| is checked to ensure that the callback is called\n   * correctly.\n   *\n   * @param {Node} target\n   * @param {function(MutationObserverInit):MutationRecord} callback\n   */\n  function forEachAncestorAndObserverEnqueueRecord(target, callback) {\n    for (var node = target; node; node = node.parentNode) {\n      var registrations = registrationsTable.get(node);\n\n      if (registrations) {\n        for (var j = 0; j < registrations.length; j++) {\n          var registration = registrations[j];\n          var options = registration.options;\n\n          // Only target ignores subtree.\n          if (node !== target && !options.subtree)\n            continue;\n\n          var record = callback(options);\n          if (record)\n            registration.enqueue(record);\n        }\n      }\n    }\n  }\n\n  var uidCounter = 0;\n\n  /**\n   * The class that maps to the DOM MutationObserver interface.\n   * @param {Function} callback.\n   * @constructor\n   */\n  function JsMutationObserver(callback) {\n    this.callback_ = callback;\n    this.nodes_ = [];\n    this.records_ = [];\n    this.uid_ = ++uidCounter;\n  }\n\n  JsMutationObserver.prototype = {\n    observe: function(target, options) {\n      target = wrapIfNeeded(target);\n\n      // 1.1\n      if (!options.childList && !options.attributes && !options.characterData ||\n\n          // 1.2\n          options.attributeOldValue && !options.attributes ||\n\n          // 1.3\n          options.attributeFilter && options.attributeFilter.length &&\n              !options.attributes ||\n\n          // 1.4\n          options.characterDataOldValue && !options.characterData) {\n\n        throw new SyntaxError();\n      }\n\n      var registrations = registrationsTable.get(target);\n      if (!registrations)\n        registrationsTable.set(target, registrations = []);\n\n      // 2\n      // If target's list of registered observers already includes a registered\n      // observer associated with the context object, replace that registered\n      // observer's options with options.\n      var registration;\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i].observer === this) {\n          registration = registrations[i];\n          registration.removeListeners();\n          registration.options = options;\n          break;\n        }\n      }\n\n      // 3.\n      // Otherwise, add a new registered observer to target's list of registered\n      // observers with the context object as the observer and options as the\n      // options, and add target to context object's list of nodes on which it\n      // is registered.\n      if (!registration) {\n        registration = new Registration(this, target, options);\n        registrations.push(registration);\n        this.nodes_.push(target);\n      }\n\n      registration.addListeners();\n    },\n\n    disconnect: function() {\n      this.nodes_.forEach(function(node) {\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          var registration = registrations[i];\n          if (registration.observer === this) {\n            registration.removeListeners();\n            registrations.splice(i, 1);\n            // Each node can only have one registered observer associated with\n            // this observer.\n            break;\n          }\n        }\n      }, this);\n      this.records_ = [];\n    },\n\n    takeRecords: function() {\n      var copyOfRecords = this.records_;\n      this.records_ = [];\n      return copyOfRecords;\n    }\n  };\n\n  /**\n   * @param {string} type\n   * @param {Node} target\n   * @constructor\n   */\n  function MutationRecord(type, target) {\n    this.type = type;\n    this.target = target;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.previousSibling = null;\n    this.nextSibling = null;\n    this.attributeName = null;\n    this.attributeNamespace = null;\n    this.oldValue = null;\n  }\n\n  function copyMutationRecord(original) {\n    var record = new MutationRecord(original.type, original.target);\n    record.addedNodes = original.addedNodes.slice();\n    record.removedNodes = original.removedNodes.slice();\n    record.previousSibling = original.previousSibling;\n    record.nextSibling = original.nextSibling;\n    record.attributeName = original.attributeName;\n    record.attributeNamespace = original.attributeNamespace;\n    record.oldValue = original.oldValue;\n    return record;\n  };\n\n  // We keep track of the two (possibly one) records used in a single mutation.\n  var currentRecord, recordWithOldValue;\n\n  /**\n   * Creates a record without |oldValue| and caches it as |currentRecord| for\n   * later use.\n   * @param {string} oldValue\n   * @return {MutationRecord}\n   */\n  function getRecord(type, target) {\n    return currentRecord = new MutationRecord(type, target);\n  }\n\n  /**\n   * Gets or creates a record with |oldValue| based in the |currentRecord|\n   * @param {string} oldValue\n   * @return {MutationRecord}\n   */\n  function getRecordWithOldValue(oldValue) {\n    if (recordWithOldValue)\n      return recordWithOldValue;\n    recordWithOldValue = copyMutationRecord(currentRecord);\n    recordWithOldValue.oldValue = oldValue;\n    return recordWithOldValue;\n  }\n\n  function clearRecords() {\n    currentRecord = recordWithOldValue = undefined;\n  }\n\n  /**\n   * @param {MutationRecord} record\n   * @return {boolean} Whether the record represents a record from the current\n   * mutation event.\n   */\n  function recordRepresentsCurrentMutation(record) {\n    return record === recordWithOldValue || record === currentRecord;\n  }\n\n  /**\n   * Selects which record, if any, to replace the last record in the queue.\n   * This returns |null| if no record should be replaced.\n   *\n   * @param {MutationRecord} lastRecord\n   * @param {MutationRecord} newRecord\n   * @param {MutationRecord}\n   */\n  function selectRecord(lastRecord, newRecord) {\n    if (lastRecord === newRecord)\n      return lastRecord;\n\n    // Check if the the record we are adding represents the same record. If\n    // so, we keep the one with the oldValue in it.\n    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))\n      return recordWithOldValue;\n\n    return null;\n  }\n\n  /**\n   * Class used to represent a registered observer.\n   * @param {MutationObserver} observer\n   * @param {Node} target\n   * @param {MutationObserverInit} options\n   * @constructor\n   */\n  function Registration(observer, target, options) {\n    this.observer = observer;\n    this.target = target;\n    this.options = options;\n    this.transientObservedNodes = [];\n  }\n\n  Registration.prototype = {\n    enqueue: function(record) {\n      var records = this.observer.records_;\n      var length = records.length;\n\n      // There are cases where we replace the last record with the new record.\n      // For example if the record represents the same mutation we need to use\n      // the one with the oldValue. If we get same record (this can happen as we\n      // walk up the tree) we ignore the new record.\n      if (records.length > 0) {\n        var lastRecord = records[length - 1];\n        var recordToReplaceLast = selectRecord(lastRecord, record);\n        if (recordToReplaceLast) {\n          records[length - 1] = recordToReplaceLast;\n          return;\n        }\n      } else {\n        scheduleCallback(this.observer);\n      }\n\n      records[length] = record;\n    },\n\n    addListeners: function() {\n      this.addListeners_(this.target);\n    },\n\n    addListeners_: function(node) {\n      var options = this.options;\n      if (options.attributes)\n        node.addEventListener('DOMAttrModified', this, true);\n\n      if (options.characterData)\n        node.addEventListener('DOMCharacterDataModified', this, true);\n\n      if (options.childList)\n        node.addEventListener('DOMNodeInserted', this, true);\n\n      if (options.childList || options.subtree)\n        node.addEventListener('DOMNodeRemoved', this, true);\n    },\n\n    removeListeners: function() {\n      this.removeListeners_(this.target);\n    },\n\n    removeListeners_: function(node) {\n      var options = this.options;\n      if (options.attributes)\n        node.removeEventListener('DOMAttrModified', this, true);\n\n      if (options.characterData)\n        node.removeEventListener('DOMCharacterDataModified', this, true);\n\n      if (options.childList)\n        node.removeEventListener('DOMNodeInserted', this, true);\n\n      if (options.childList || options.subtree)\n        node.removeEventListener('DOMNodeRemoved', this, true);\n    },\n\n    /**\n     * Adds a transient observer on node. The transient observer gets removed\n     * next time we deliver the change records.\n     * @param {Node} node\n     */\n    addTransientObserver: function(node) {\n      // Don't add transient observers on the target itself. We already have all\n      // the required listeners set up on the target.\n      if (node === this.target)\n        return;\n\n      this.addListeners_(node);\n      this.transientObservedNodes.push(node);\n      var registrations = registrationsTable.get(node);\n      if (!registrations)\n        registrationsTable.set(node, registrations = []);\n\n      // We know that registrations does not contain this because we already\n      // checked if node === this.target.\n      registrations.push(this);\n    },\n\n    removeTransientObservers: function() {\n      var transientObservedNodes = this.transientObservedNodes;\n      this.transientObservedNodes = [];\n\n      transientObservedNodes.forEach(function(node) {\n        // Transient observers are never added to the target.\n        this.removeListeners_(node);\n\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          if (registrations[i] === this) {\n            registrations.splice(i, 1);\n            // Each node can only have one registered observer associated with\n            // this observer.\n            break;\n          }\n        }\n      }, this);\n    },\n\n    handleEvent: function(e) {\n      // Stop propagation since we are managing the propagation manually.\n      // This means that other mutation events on the page will not work\n      // correctly but that is by design.\n      e.stopImmediatePropagation();\n\n      switch (e.type) {\n        case 'DOMAttrModified':\n          // http://dom.spec.whatwg.org/#concept-mo-queue-attributes\n\n          var name = e.attrName;\n          var namespace = e.relatedNode.namespaceURI;\n          var target = e.target;\n\n          // 1.\n          var record = new getRecord('attributes', target);\n          record.attributeName = name;\n          record.attributeNamespace = namespace;\n\n          // 2.\n          var oldValue =\n              e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n\n          forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n            // 3.1, 4.2\n            if (!options.attributes)\n              return;\n\n            // 3.2, 4.3\n            if (options.attributeFilter && options.attributeFilter.length &&\n                options.attributeFilter.indexOf(name) === -1 &&\n                options.attributeFilter.indexOf(namespace) === -1) {\n              return;\n            }\n            // 3.3, 4.4\n            if (options.attributeOldValue)\n              return getRecordWithOldValue(oldValue);\n\n            // 3.4, 4.5\n            return record;\n          });\n\n          break;\n\n        case 'DOMCharacterDataModified':\n          // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata\n          var target = e.target;\n\n          // 1.\n          var record = getRecord('characterData', target);\n\n          // 2.\n          var oldValue = e.prevValue;\n\n\n          forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n            // 3.1, 4.2\n            if (!options.characterData)\n              return;\n\n            // 3.2, 4.3\n            if (options.characterDataOldValue)\n              return getRecordWithOldValue(oldValue);\n\n            // 3.3, 4.4\n            return record;\n          });\n\n          break;\n\n        case 'DOMNodeRemoved':\n          this.addTransientObserver(e.target);\n          // Fall through.\n        case 'DOMNodeInserted':\n          // http://dom.spec.whatwg.org/#concept-mo-queue-childlist\n          var changedNode = e.target;\n          var addedNodes, removedNodes;\n          if (e.type === 'DOMNodeInserted') {\n            addedNodes = [changedNode];\n            removedNodes = [];\n          } else {\n\n            addedNodes = [];\n            removedNodes = [changedNode];\n          }\n          var previousSibling = changedNode.previousSibling;\n          var nextSibling = changedNode.nextSibling;\n\n          // 1.\n          var record = getRecord('childList', e.target.parentNode);\n          record.addedNodes = addedNodes;\n          record.removedNodes = removedNodes;\n          record.previousSibling = previousSibling;\n          record.nextSibling = nextSibling;\n\n          forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {\n            // 2.1, 3.2\n            if (!options.childList)\n              return;\n\n            // 2.2, 3.3\n            return record;\n          });\n\n      }\n\n      clearRecords();\n    }\n  };\n\n  global.JsMutationObserver = JsMutationObserver;\n\n  if (!global.MutationObserver) {\n    global.MutationObserver = JsMutationObserver;\n    // Explicltly mark MO as polyfilled for user reference.\n    JsMutationObserver._isPolyfilled = true;\n  }\n\n})(self);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/MutationObserver/MutationObserver.js\n ** module id = 9\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nwindow.CustomElements = window.CustomElements || {flags:{}};\n\n(function(scope) {\n\n// imports\nvar flags = scope.flags;\n\n// world's simplest module initializer\nvar modules = [];\nvar addModule = function(module) {\n\tmodules.push(module);\n};\n\nvar initializeModules = function() {\n\tmodules.forEach(function(module) {\n\t\tmodule(scope);\n\t});\n};\n\n// exports\nscope.addModule = addModule;\nscope.initializeModules = initializeModules;\nscope.hasNative = Boolean(document.registerElement);\nscope.isIE = /Trident/.test(navigator.userAgent);\n\n// NOTE: For consistent timing, use native custom elements only when not\n// polyfilling other key related web components features.\nscope.useNative = !flags.register && scope.hasNative &&\n\t\t!window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);\n\n})(window.CustomElements);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/CustomElements/base.js\n ** module id = 10\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n// helper methods for traversing through element trees\nwindow.CustomElements.addModule(function(scope){\n\n// imports\nvar IMPORT_LINK_TYPE = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : 'none';\n\n// walk the subtree rooted at node, including descent into shadow-roots,\n// applying 'cb' to each element\nfunction forSubtree(node, cb) {\n  //flags.dom && node.childNodes && node.childNodes.length && console.group('subTree: ', node);\n  findAllElements(node, function(e) {\n    if (cb(e)) {\n      return true;\n    }\n    forRoots(e, cb);\n  });\n  forRoots(node, cb);\n  //flags.dom && node.childNodes && node.childNodes.length && console.groupEnd();\n}\n\n\n// walk the subtree rooted at node, applying 'find(element, data)' function\n// to each element\n// if 'find' returns true for 'element', do not search element's subtree\nfunction findAllElements(node, find, data) {\n  var e = node.firstElementChild;\n  if (!e) {\n    e = node.firstChild;\n    while (e && e.nodeType !== Node.ELEMENT_NODE) {\n      e = e.nextSibling;\n    }\n  }\n  while (e) {\n    if (find(e, data) !== true) {\n      findAllElements(e, find, data);\n    }\n    e = e.nextElementSibling;\n  }\n  return null;\n}\n\n// walk all shadowRoots on a given node.\nfunction forRoots(node, cb) {\n  var root = node.shadowRoot;\n  while(root) {\n    forSubtree(root, cb);\n    root = root.olderShadowRoot;\n  }\n}\n\nfunction forDocumentTree(doc, cb) {\n  _forDocumentTree(doc, cb, []);\n}\n\n\nfunction _forDocumentTree(doc, cb, processingDocuments) {\n  doc = window.wrap(doc);\n  if (processingDocuments.indexOf(doc) >= 0) {\n    return;\n  }\n  processingDocuments.push(doc);\n  var imports = doc.querySelectorAll('link[rel=' + IMPORT_LINK_TYPE + ']');\n  for (var i=0, l=imports.length, n; (i<l) && (n=imports[i]); i++) {\n    if (n.import) {\n      _forDocumentTree(n.import, cb, processingDocuments);\n    }\n  }\n  cb(doc);\n}\n\n// exports\nscope.forDocumentTree = forDocumentTree;\nscope.forSubtree = forSubtree;\n\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/CustomElements/traverse.js\n ** module id = 11\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Implements custom element observation and attached/detached callbacks\n * @module observe\n*/\n\nwindow.CustomElements.addModule(function(scope){\n\n// imports\nvar flags = scope.flags;\nvar forSubtree = scope.forSubtree;\nvar forDocumentTree = scope.forDocumentTree;\n\n/*\n  Manage nodes attached to document trees\n*/\n\n// manage lifecycle on added node and it's subtree; upgrade the node and\n// entire subtree if necessary and process attached for the node and entire\n// subtree\nfunction addedNode(node, isAttached) {\n  return added(node, isAttached) || addedSubtree(node, isAttached);\n}\n\n// manage lifecycle on added node; upgrade if necessary and process attached\nfunction added(node, isAttached) {\n  if (scope.upgrade(node, isAttached)) {\n    // Return true to indicate\n    return true;\n  }\n  if (isAttached) {\n    attached(node);\n  }\n}\n\n// manage lifecycle on added node's subtree only; allows the entire subtree\n// to upgrade if necessary and process attached\nfunction addedSubtree(node, isAttached) {\n  forSubtree(node, function(e) {\n    if (added(e, isAttached)) {\n      return true;\n    }\n  });\n}\n\n// On platforms without MutationObserver, mutations may not be\n// reliable and therefore attached/detached are not reliable. We think this\n// occurs sometimes under heavy DOM operation load, but it is not easy to\n// reproduce.\n// To make these callbacks less likely to fail in this scenario,\n// we *optionally* defer all inserts and removes\n// to give a chance for elements to be attached into dom.\n// This helps ensure attachedCallback fires for elements that are created and\n// immediately added to dom.\n// This change can significantly alter the performance characteristics\n// of attaching elements and therefore we only enable it if the user has\n// explicitly provided the `throttle-attached` flag.\nvar hasThrottledAttached = (window.MutationObserver._isPolyfilled &&\n    flags['throttle-attached']);\n// bc\nscope.hasPolyfillMutations = hasThrottledAttached;\n// exposed for testing\nscope.hasThrottledAttached = hasThrottledAttached;\n\nvar isPendingMutations = false;\nvar pendingMutations = [];\nfunction deferMutation(fn) {\n  pendingMutations.push(fn);\n  if (!isPendingMutations) {\n    isPendingMutations = true;\n    setTimeout(takeMutations);\n  }\n}\n\nfunction takeMutations() {\n  isPendingMutations = false;\n  var $p = pendingMutations;\n  for (var i=0, l=$p.length, p; (i<l) && (p=$p[i]); i++) {\n    p();\n  }\n  pendingMutations = [];\n}\n\nfunction attached(element) {\n  if (hasThrottledAttached) {\n    deferMutation(function() {\n      _attached(element);\n    });\n  } else {\n    _attached(element);\n  }\n}\n\n// NOTE: due to how MO works (see comments below), an element may be attached\n// multiple times so we protect against extra processing here.\nfunction _attached(element) {\n  // track element for insertion if it's upgraded and cares about insertion\n  // bail if the element is already marked as attached\n  if (element.__upgraded__ && !element.__attached) {\n    element.__attached = true;\n    if (element.attachedCallback) {\n      element.attachedCallback();\n    }\n  }\n}\n\n/*\n  Manage nodes detached from document trees\n*/\n\n// manage lifecycle on detached node and it's subtree; process detached\n// for the node and entire subtree\nfunction detachedNode(node) {\n  detached(node);\n  forSubtree(node, function(e) {\n    detached(e);\n  });\n}\n\nfunction detached(element) {\n  if (hasThrottledAttached) {\n    deferMutation(function() {\n      _detached(element);\n    });\n  } else {\n    _detached(element);\n  }\n}\n\n// NOTE: due to how MO works (see comments below), an element may be detached\n// multiple times so we protect against extra processing here.\nfunction _detached(element) {\n  // track element for removal if it's upgraded and cares about removal\n  // bail if the element is already marked as not attached\n  if (element.__upgraded__ && element.__attached) {\n    element.__attached = false;\n    if (element.detachedCallback) {\n      element.detachedCallback();\n    }\n  }\n}\n\n// recurse up the tree to check if an element is actually in the main document.\nfunction inDocument(element) {\n  var p = element;\n  var doc = window.wrap(document);\n  while (p) {\n    if (p == doc) {\n      return true;\n    }\n    p = p.parentNode || ((p.nodeType === Node.DOCUMENT_FRAGMENT_NODE) && p.host);\n  }\n}\n\n//  Install an element observer on all shadowRoots owned by node.\nfunction watchShadow(node) {\n  if (node.shadowRoot && !node.shadowRoot.__watched) {\n    flags.dom && console.log('watching shadow-root for: ', node.localName);\n    // watch all unwatched roots...\n    var root = node.shadowRoot;\n    while (root) {\n      observe(root);\n      root = root.olderShadowRoot;\n    }\n  }\n}\n\n/*\n  NOTE: In order to process all mutations, it's necessary to recurse into\n  any added nodes. However, it's not possible to determine a priori if a node\n  will get its own mutation record. This means\n  *nodes can be seen multiple times*.\n\n  Here's an example:\n\n  (1) In this case, recursion is required to see `child`:\n\n      node.innerHTML = '<div><child></child></div>'\n\n  (2) In this case, child will get its own mutation record:\n\n      node.appendChild(div).appendChild(child);\n\n  We cannot know ahead of time if we need to walk into the node in (1) so we\n  do and see child; however, if it was added via case (2) then it will have its\n  own record and therefore be seen 2x.\n*/\nfunction handler(root, mutations) {\n  // for logging only\n  if (flags.dom) {\n    var mx = mutations[0];\n    if (mx && mx.type === 'childList' && mx.addedNodes) {\n        if (mx.addedNodes) {\n          var d = mx.addedNodes[0];\n          while (d && d !== document && !d.host) {\n            d = d.parentNode;\n          }\n          var u = d && (d.URL || d._URL || (d.host && d.host.localName)) || '';\n          u = u.split('/?').shift().split('/').pop();\n        }\n    }\n    console.group('mutations (%d) [%s]', mutations.length, u || '');\n  }\n  // handle mutations\n  // NOTE: do an `inDocument` check dynamically here. It's possible that `root`\n  // is a document in which case the answer here can never change; however\n  // `root` may be an element like a shadowRoot that can be added/removed\n  // from the main document.\n  var isAttached = inDocument(root);\n  mutations.forEach(function(mx) {\n    if (mx.type === 'childList') {\n      forEach(mx.addedNodes, function(n) {\n        if (!n.localName) {\n          return;\n        }\n        addedNode(n, isAttached);\n      });\n      forEach(mx.removedNodes, function(n) {\n        if (!n.localName) {\n          return;\n        }\n        detachedNode(n);\n      });\n    }\n  });\n  flags.dom && console.groupEnd();\n};\n\n\n/*\n  When elements are added to the dom, upgrade and attached/detached may be\n  asynchronous. `CustomElements.takeRecords` can be called to process any\n  pending upgrades and attached/detached callbacks synchronously.\n*/\nfunction takeRecords(node) {\n  node = window.wrap(node);\n  // If the optional node is not supplied, assume we mean the whole document.\n  if (!node) {\n    node = window.wrap(document);\n  }\n  // Find the root of the tree, which will be an Document or ShadowRoot.\n  while (node.parentNode) {\n    node = node.parentNode;\n  }\n  var observer = node.__observer;\n  if (observer) {\n    handler(node, observer.takeRecords());\n    takeMutations();\n  }\n}\n\nvar forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\n\n\n// observe a node tree; bail if it's already being observed.\nfunction observe(inRoot) {\n  if (inRoot.__observer) {\n    return;\n  }\n  // For each ShadowRoot, we create a new MutationObserver, so the root can be\n  // garbage collected once all references to the `inRoot` node are gone.\n  // Give the handler access to the root so that an 'in document' check can\n  // be done.\n  var observer = new MutationObserver(handler.bind(this, inRoot));\n  observer.observe(inRoot, {childList: true, subtree: true});\n  inRoot.__observer = observer;\n}\n\n// upgrade an entire document and observe it for elements changes.\nfunction upgradeDocument(doc) {\n  doc = window.wrap(doc);\n  flags.dom && console.group('upgradeDocument: ', (doc.baseURI).split('/').pop());\n  var isMainDocument = (doc === window.wrap(document));\n  addedNode(doc, isMainDocument);\n  observe(doc);\n  flags.dom && console.groupEnd();\n}\n\n/*\nThis method is intended to be called when the document tree (including imports)\nhas pending custom elements to upgrade. It can be called multiple times and\nshould do nothing if no elements are in need of upgrade.\n*/\nfunction upgradeDocumentTree(doc) {\n  forDocumentTree(doc, upgradeDocument);\n}\n\n\n// Patch `createShadowRoot()` if Shadow DOM is available, otherwise leave\n// undefined to aid feature detection of Shadow DOM.\nvar originalCreateShadowRoot = Element.prototype.createShadowRoot;\nif (originalCreateShadowRoot) {\n  Element.prototype.createShadowRoot = function() {\n    var root = originalCreateShadowRoot.call(this);\n    window.CustomElements.watchShadow(this);\n    return root;\n  };\n}\n\n// exports\nscope.watchShadow = watchShadow;\nscope.upgradeDocumentTree = upgradeDocumentTree;\nscope.upgradeDocument = upgradeDocument;\nscope.upgradeSubtree = addedSubtree;\nscope.upgradeAll = addedNode;\nscope.attached = attached;\nscope.takeRecords = takeRecords;\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/CustomElements/observe.js\n ** module id = 12\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Implements custom element upgrading\n * @module upgrade\n*/\n\nwindow.CustomElements.addModule(function(scope) {\n\n// imports\nvar flags = scope.flags;\n\n/**\n * Upgrade an element to a custom element. Upgrading an element\n * causes the custom prototype to be applied, an `is` attribute\n * to be attached (as needed), and invocation of the `readyCallback`.\n * If the element is in the main document, the `attachedkCallback` method\n * will be invoked.\n * `upgrade` does nothing if the element is already upgraded, or\n * if it matches no registered custom tag name.\n *\n * @method ugprade\n * @param {Element} element The element to upgrade.\n * @return {Element} The upgraded element.\n */\n// Upgrade a node if it can be upgraded and is not already.\nfunction upgrade(node, isAttached) {\n  // upgrade template elements before custom elements\n  if (node.localName === 'template') {\n    if (window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n      HTMLTemplateElement.decorate(node);\n    }\n  }\n  if (!node.__upgraded__ && (node.nodeType === Node.ELEMENT_NODE)) {\n    var is = node.getAttribute('is');\n    // find definition first by localName and secondarily by is attribute\n    var definition = scope.getRegisteredDefinition(node.localName) ||\n      scope.getRegisteredDefinition(is);\n    if (definition) {\n      // upgrade with is iff the definition tag matches the element tag\n      // and don't upgrade if there's an is and the definition does not extend\n      // a native element\n      if ((is && definition.tag == node.localName) ||\n        (!is && !definition.extends)) {\n        return upgradeWithDefinition(node, definition, isAttached);\n      }\n    }\n  }\n}\n\nfunction upgradeWithDefinition(element, definition, isAttached) {\n  flags.upgrade && console.group('upgrade:', element.localName);\n  // some definitions specify an 'is' attribute\n  if (definition.is) {\n    element.setAttribute('is', definition.is);\n  }\n  // make 'element' implement definition.prototype\n  implementPrototype(element, definition);\n  // flag as upgraded\n  element.__upgraded__ = true;\n  // lifecycle management\n  created(element);\n  // attachedCallback fires in tree order, call before recursing\n  if (isAttached) {\n    scope.attached(element);\n  }\n  // there should never be a shadow root on element at this point\n  scope.upgradeSubtree(element, isAttached);\n  flags.upgrade && console.groupEnd();\n  // OUTPUT\n  return element;\n}\n\n//  Set __proto__ on supported platforms and use a mixin strategy when\n//  this is not supported; e.g. on IE10.\nfunction implementPrototype(element, definition) {\n  // prototype swizzling is best\n  if (Object.__proto__) {\n    element.__proto__ = definition.prototype;\n  } else {\n    // where above we can re-acquire inPrototype via\n    // getPrototypeOf(Element), we cannot do so when\n    // we use mixin, so we install a magic reference\n    customMixin(element, definition.prototype, definition.native);\n    element.__proto__ = definition.prototype;\n  }\n}\n\nfunction customMixin(inTarget, inSrc, inNative) {\n  // TODO(sjmiles): 'used' allows us to only copy the 'youngest' version of\n  // any property. This set should be precalculated. We also need to\n  // consider this for supporting 'super'.\n  var used = {};\n  // start with inSrc\n  var p = inSrc;\n  // The default is HTMLElement.prototype, so we add a test to avoid mixing in\n  // native prototypes\n  while (p !== inNative && p !== HTMLElement.prototype) {\n    var keys = Object.getOwnPropertyNames(p);\n    for (var i=0, k; k=keys[i]; i++) {\n      if (!used[k]) {\n        Object.defineProperty(inTarget, k,\n            Object.getOwnPropertyDescriptor(p, k));\n        used[k] = 1;\n      }\n    }\n    p = Object.getPrototypeOf(p);\n  }\n}\n\nfunction created(element) {\n  // invoke createdCallback\n  if (element.createdCallback) {\n    element.createdCallback();\n  }\n}\n\nscope.upgrade = upgrade;\nscope.upgradeWithDefinition = upgradeWithDefinition;\nscope.implementPrototype = implementPrototype;\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/CustomElements/upgrade.js\n ** module id = 13\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Implements `document.registerElement`\n * @module register\n*/\n\n/**\n * Polyfilled extensions to the `document` object.\n * @class Document\n*/\n\nwindow.CustomElements.addModule(function(scope) {\n\n// imports\nvar isIE = scope.isIE;\nvar upgradeDocumentTree = scope.upgradeDocumentTree;\nvar upgradeAll = scope.upgradeAll;\nvar upgradeWithDefinition = scope.upgradeWithDefinition;\nvar implementPrototype = scope.implementPrototype;\nvar useNative = scope.useNative;\n\n/**\n * Registers a custom tag name with the document.\n *\n * When a registered element is created, a `readyCallback` method is called\n * in the scope of the element. The `readyCallback` method can be specified on\n * either `options.prototype` or `options.lifecycle` with the latter taking\n * precedence.\n *\n * @method register\n * @param {String} name The tag name to register. Must include a dash ('-'),\n *    for example 'x-component'.\n * @param {Object} options\n *    @param {String} [options.extends]\n *      (_off spec_) Tag name of an element to extend (or blank for a new\n *      element). This parameter is not part of the specification, but instead\n *      is a hint for the polyfill because the extendee is difficult to infer.\n *      Remember that the input prototype must chain to the extended element's\n *      prototype (or HTMLElement.prototype) regardless of the value of\n *      `extends`.\n *    @param {Object} options.prototype The prototype to use for the new\n *      element. The prototype must inherit from HTMLElement.\n *    @param {Object} [options.lifecycle]\n *      Callbacks that fire at important phases in the life of the custom\n *      element.\n *\n * @example\n *      FancyButton = document.registerElement(\"fancy-button\", {\n *        extends: 'button',\n *        prototype: Object.create(HTMLButtonElement.prototype, {\n *          readyCallback: {\n *            value: function() {\n *              console.log(\"a fancy-button was created\",\n *            }\n *          }\n *        })\n *      });\n * @return {Function} Constructor for the newly registered type.\n */\nfunction register(name, options) {\n  //console.warn('document.registerElement(\"' + name + '\", ', options, ')');\n  // construct a defintion out of options\n  // TODO(sjmiles): probably should clone options instead of mutating it\n  var definition = options || {};\n  if (!name) {\n    throw new Error('document.registerElement: first argument `name` must not be empty');\n  }\n  if (name.indexOf('-') < 0) {\n    throw new Error('document.registerElement: first argument (\\'name\\') must contain a dash (\\'-\\'). Argument provided was \\'' + String(name) + '\\'.');\n  }\n  // prevent registering reserved names\n  if (isReservedTag(name)) {\n    throw new Error('Failed to execute \\'registerElement\\' on \\'Document\\': Registration failed for type \\'' + String(name) + '\\'. The type name is invalid.');\n  }\n  // elements may only be registered once\n  if (getRegisteredDefinition(name)) {\n    throw new Error('DuplicateDefinitionError: a type with name \\'' + String(name) + '\\' is already registered');\n  }\n  // prototype is optional, default to an extension of HTMLElement\n  if (!definition.prototype) {\n    definition.prototype = Object.create(HTMLElement.prototype);\n  }\n  // record name\n  definition.__name = name.toLowerCase();\n  // ensure a lifecycle object so we don't have to null test it\n  definition.lifecycle = definition.lifecycle || {};\n  // build a list of ancestral custom elements (for native base detection)\n  // TODO(sjmiles): we used to need to store this, but current code only\n  // uses it in 'resolveTagName': it should probably be inlined\n  definition.ancestry = ancestry(definition.extends);\n  // extensions of native specializations of HTMLElement require localName\n  // to remain native, and use secondary 'is' specifier for extension type\n  resolveTagName(definition);\n  // some platforms require modifications to the user-supplied prototype\n  // chain\n  resolvePrototypeChain(definition);\n  // overrides to implement attributeChanged callback\n  overrideAttributeApi(definition.prototype);\n  // 7.1.5: Register the DEFINITION with DOCUMENT\n  registerDefinition(definition.__name, definition);\n  // 7.1.7. Run custom element constructor generation algorithm with PROTOTYPE\n  // 7.1.8. Return the output of the previous step.\n  definition.ctor = generateConstructor(definition);\n  definition.ctor.prototype = definition.prototype;\n  // force our .constructor to be our actual constructor\n  definition.prototype.constructor = definition.ctor;\n  // if initial parsing is complete\n  if (scope.ready) {\n    // upgrade any pre-existing nodes of this type\n    upgradeDocumentTree(document);\n  }\n  return definition.ctor;\n}\n\n// attribute watching\nfunction overrideAttributeApi(prototype) {\n  // overrides to implement callbacks\n  // TODO(sjmiles): should support access via .attributes NamedNodeMap\n  // TODO(sjmiles): preserves user defined overrides, if any\n  if (prototype.setAttribute._polyfilled) {\n    return;\n  }\n  var setAttribute = prototype.setAttribute;\n  prototype.setAttribute = function(name, value) {\n    changeAttribute.call(this, name, value, setAttribute);\n  };\n  var removeAttribute = prototype.removeAttribute;\n  prototype.removeAttribute = function(name) {\n    changeAttribute.call(this, name, null, removeAttribute);\n  };\n  prototype.setAttribute._polyfilled = true;\n}\n\n// https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/\n// index.html#dfn-attribute-changed-callback\nfunction changeAttribute(name, value, operation) {\n  name = name.toLowerCase();\n  var oldValue = this.getAttribute(name);\n  operation.apply(this, arguments);\n  var newValue = this.getAttribute(name);\n  if (this.attributeChangedCallback &&\n      (newValue !== oldValue)) {\n    this.attributeChangedCallback(name, oldValue, newValue);\n  }\n}\n\nfunction isReservedTag(name) {\n  for (var i = 0; i < reservedTagList.length; i++) {\n    if (name === reservedTagList[i]) {\n      return true;\n    }\n  }\n}\n\nvar reservedTagList = [\n  'annotation-xml', 'color-profile', 'font-face', 'font-face-src',\n  'font-face-uri', 'font-face-format', 'font-face-name', 'missing-glyph'\n];\n\nfunction ancestry(extnds) {\n  var extendee = getRegisteredDefinition(extnds);\n  if (extendee) {\n    return ancestry(extendee.extends).concat([extendee]);\n  }\n  return [];\n}\n\nfunction resolveTagName(definition) {\n  // if we are explicitly extending something, that thing is our\n  // baseTag, unless it represents a custom component\n  var baseTag = definition.extends;\n  // if our ancestry includes custom components, we only have a\n  // baseTag if one of them does\n  for (var i=0, a; (a=definition.ancestry[i]); i++) {\n    baseTag = a.is && a.tag;\n  }\n  // our tag is our baseTag, if it exists, and otherwise just our name\n  definition.tag = baseTag || definition.__name;\n  if (baseTag) {\n    // if there is a base tag, use secondary 'is' specifier\n    definition.is = definition.__name;\n  }\n}\n\nfunction resolvePrototypeChain(definition) {\n  // if we don't support __proto__ we need to locate the native level\n  // prototype for precise mixing in\n  if (!Object.__proto__) {\n    // default prototype\n    var nativePrototype = HTMLElement.prototype;\n    // work out prototype when using type-extension\n    if (definition.is) {\n      var inst = document.createElement(definition.tag);\n      nativePrototype = Object.getPrototypeOf(inst);\n    }\n    // ensure __proto__ reference is installed at each point on the prototype\n    // chain.\n    // NOTE: On platforms without __proto__, a mixin strategy is used instead\n    // of prototype swizzling. In this case, this generated __proto__ provides\n    // limited support for prototype traversal.\n    var proto = definition.prototype, ancestor;\n    var foundPrototype = false;\n    while (proto) {\n      if (proto == nativePrototype) {\n        foundPrototype = true;\n      }\n      ancestor = Object.getPrototypeOf(proto);\n      if (ancestor) {\n        proto.__proto__ = ancestor;\n      }\n      proto = ancestor;\n    }\n    if (!foundPrototype) {\n      // Note the spec actually allows this, but it results in broken elements\n      // and is difficult to polyfill correctly, so we throw\n      console.warn(definition.tag + ' prototype not found in prototype chain for ' +\n        definition.is);\n    }\n    // cache this in case of mixin\n    definition.native = nativePrototype;\n  }\n}\n\n// SECTION 4\n\nfunction instantiate(definition) {\n  // 4.a.1. Create a new object that implements PROTOTYPE\n  // 4.a.2. Let ELEMENT by this new object\n  //\n  // the custom element instantiation algorithm must also ensure that the\n  // output is a valid DOM element with the proper wrapper in place.\n  //\n  return upgradeWithDefinition(domCreateElement(definition.tag), definition);\n}\n\n// element registry (maps tag names to definitions)\n\nvar registry = {};\n\nfunction getRegisteredDefinition(name) {\n  if (name) {\n    return registry[name.toLowerCase()];\n  }\n}\n\nfunction registerDefinition(name, definition) {\n  registry[name] = definition;\n}\n\nfunction generateConstructor(definition) {\n  return function() {\n    return instantiate(definition);\n  };\n}\n\nvar HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nfunction createElementNS(namespace, tag, typeExtension) {\n  // NOTE: we do not support non-HTML elements,\n  // just call createElementNS for non HTML Elements\n  if (namespace === HTML_NAMESPACE) {\n    return createElement(tag, typeExtension);\n  } else {\n    return domCreateElementNS(namespace, tag);\n  }\n}\n\nfunction createElement(tag, typeExtension) {\n  // TODO(sjmiles): ignore 'tag' when using 'typeExtension', we could\n  // error check it, or perhaps there should only ever be one argument\n  if (tag) {\n    tag = tag.toLowerCase();\n  }\n  if (typeExtension) {\n    typeExtension = typeExtension.toLowerCase();\n  }\n  var definition = getRegisteredDefinition(typeExtension || tag);\n  if (definition) {\n    if (tag == definition.tag && typeExtension == definition.is) {\n      return new definition.ctor();\n    }\n    // Handle empty string for type extension.\n    if (!typeExtension && !definition.is) {\n      return new definition.ctor();\n    }\n  }\n  var element;\n  if (typeExtension) {\n    element = createElement(tag);\n    element.setAttribute('is', typeExtension);\n    return element;\n  }\n  element = domCreateElement(tag);\n  // Custom tags should be HTMLElements even if not upgraded.\n  if (tag.indexOf('-') >= 0) {\n    implementPrototype(element, HTMLElement);\n  }\n  return element;\n}\n\n// capture native createElement before we override it\nvar domCreateElement = document.createElement.bind(document);\nvar domCreateElementNS = document.createElementNS.bind(document);\n\n// Create a custom 'instanceof'. This is necessary when CustomElements\n// are implemented via a mixin strategy, as for example on IE10.\nvar isInstance;\nif (!Object.__proto__ && !useNative) {\n  isInstance = function(obj, ctor) {\n    // Allows instanceof(<div>, HTMLElement.prototype) to work\n    if (obj instanceof ctor) {\n      return true;\n    }\n    var p = obj;\n    while (p) {\n      // NOTE: this is not technically correct since we're not checking if\n      // an object is an instance of a constructor; however, this should\n      // be good enough for the mixin strategy.\n      if (p === ctor.prototype) {\n        return true;\n      }\n      p = p.__proto__;\n    }\n    return false;\n  };\n} else {\n  isInstance = function(obj, base) {\n    return obj instanceof base;\n  };\n}\n\n// wrap a dom object method that works on nodes such that it forces upgrade\nfunction wrapDomMethodToForceUpgrade(obj, methodName) {\n  var orig = obj[methodName];\n  obj[methodName] = function() {\n    var n = orig.apply(this, arguments);\n    upgradeAll(n);\n    return n;\n  };\n}\n\nwrapDomMethodToForceUpgrade(Node.prototype, 'cloneNode');\nwrapDomMethodToForceUpgrade(document, 'importNode');\n\n// Patch document.importNode to work around IE11 bug that\n// casues children of a document fragment imported while\n// there is a mutation observer to not have a parentNode (!?!)\nif (isIE) {\n  (function() {\n    var importNode = document.importNode;\n    document.importNode = function() {\n      var n = importNode.apply(document, arguments);\n      // Copy all children to a new document fragment since\n      // this one may be broken\n      if (n.nodeType == n.DOCUMENT_FRAGMENT_NODE) {\n        var f = document.createDocumentFragment();\n        f.appendChild(n);\n        return f;\n      } else {\n        return n;\n      }\n    };\n  })();\n}\n\n// exports\ndocument.registerElement = register;\ndocument.createElement = createElement; // override\ndocument.createElementNS = createElementNS; // override\nscope.registry = registry;\nscope.instanceof = isInstance;\nscope.reservedTagList = reservedTagList;\nscope.getRegisteredDefinition = getRegisteredDefinition;\n\n// bc\ndocument.register = document.registerElement;\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/CustomElements/register.js\n ** module id = 14\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n(function(scope){\n\n// imports\nvar useNative = scope.useNative;\nvar initializeModules = scope.initializeModules;\n\nvar isIE = scope.isIE;\n\n// If native, setup stub api and bail.\n// NOTE: we fire `WebComponentsReady` under native for api compatibility\nif (useNative) {\n  // stub\n  var nop = function() {};\n\n  // exports\n  scope.watchShadow = nop;\n  scope.upgrade = nop;\n  scope.upgradeAll = nop;\n  scope.upgradeDocumentTree = nop;\n  scope.upgradeSubtree = nop;\n  scope.takeRecords = nop;\n\n  scope.instanceof = function(obj, base) {\n    return obj instanceof base;\n  };\n\n} else {\n  // Initialize polyfill modules. Note, polyfill modules are loaded but not\n  // executed; this is a convenient way to control which modules run when\n  // the polyfill is required and allows the polyfill to load even when it's\n  // not needed.\n  initializeModules();\n}\n\n// imports\nvar upgradeDocumentTree = scope.upgradeDocumentTree;\nvar upgradeDocument = scope.upgradeDocument;\n\n// ShadowDOM polyfill wraps elements but some elements like `document`\n// cannot be wrapped so we help the polyfill by wrapping some elements.\nif (!window.wrap) {\n  if (window.ShadowDOMPolyfill) {\n    window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded;\n    window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded;\n  } else {\n    window.wrap = window.unwrap = function(node) {\n      return node;\n    };\n  }\n}\n\n// eagarly upgrade imported documents\nif (window.HTMLImports) {\n  window.HTMLImports.__importsParsingHook = function(elt) {\n    if (elt.import) {\n      upgradeDocument(wrap(elt.import));\n    }\n  };\n}\n\n// bootstrap parsing\nfunction bootstrap() {\n  // one more upgrade to catch out of order registrations\n  upgradeDocumentTree(window.wrap(document));\n  // install upgrade hook if HTMLImports are available\n  // set internal 'ready' flag, now document.registerElement will trigger\n  // synchronous upgrades\n  window.CustomElements.ready = true;\n  // async to ensure *native* custom elements upgrade prior to this\n  // DOMContentLoaded can fire before elements upgrade (e.g. when there's\n  // an external script)\n  // Delay doubly to help workaround\n  // https://code.google.com/p/chromium/issues/detail?id=516550.\n  // CustomElements must use requestAnimationFrame in attachedCallback\n  // to query style/layout data. The WebComponentsReady event is intended\n  // to convey overall readiness, which ideally should be after elements\n  // are attached. Adding a slight extra delay to WebComponentsReady\n  // helps preserve this guarantee.\n  var requestAnimationFrame = window.requestAnimationFrame || function(f) {\n    setTimeout(f, 16);\n  };\n  requestAnimationFrame(function() {\n    setTimeout(function() {\n      // capture blunt profiling data\n      window.CustomElements.readyTime = Date.now();\n      if (window.HTMLImports) {\n        window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime;\n      }\n      // notify the system that we are bootstrapped\n      document.dispatchEvent(\n        new CustomEvent('WebComponentsReady', {bubbles: true})\n      );\n    });\n  });\n}\n\n// When loading at readyState complete time (or via flag), boot custom elements\n// immediately.\n// If relevant, HTMLImports must already be loaded.\nif (document.readyState === 'complete' || scope.flags.eager) {\n  bootstrap();\n// When loading at readyState interactive time, bootstrap only if HTMLImports\n// are not pending. Also avoid IE as the semantics of this state are unreliable.\n} else if (document.readyState === 'interactive' && !window.attachEvent &&\n    (!window.HTMLImports || window.HTMLImports.ready)) {\n  bootstrap();\n// When loading at other readyStates, wait for the appropriate DOM event to\n// bootstrap.\n} else {\n  var loadEvent = window.HTMLImports && !window.HTMLImports.ready ?\n      'HTMLImportsLoaded' : 'DOMContentLoaded';\n  window.addEventListener(loadEvent, bootstrap);\n}\n\n})(window.CustomElements);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/CustomElements/boot.js\n ** module id = 15\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/*\n * PLEASE NOTE: This file is duplicated within Polymer. Please keep it in sync!\n * https://github.com/Polymer/polymer/blob/master/src/system/HTMLImports/base.js\n */\n\n/*\n\tCreate polyfill scope and feature detect native support.\n*/\nwindow.HTMLImports = window.HTMLImports || {flags:{}};\n\n(function(scope) {\n\n/**\n\tBasic setup and simple module executer. We collect modules and then execute\n  the code later, only if it's necessary for polyfilling.\n*/\nvar IMPORT_LINK_TYPE = 'import';\nvar useNative = Boolean(IMPORT_LINK_TYPE in document.createElement('link'));\n\n/**\n  Support `currentScript` on all browsers as `document._currentScript.`\n\n  NOTE: We cannot polyfill `document.currentScript` because it's not possible\n  both to override and maintain the ability to capture the native value.\n  Therefore we choose to expose `_currentScript` both when native imports\n  and the polyfill are in use.\n*/\n// NOTE: ShadowDOMPolyfill intrusion.\nvar hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);\nvar wrap = function(node) {\n  return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;\n};\nvar rootDocument = wrap(document);\n\nvar currentScriptDescriptor = {\n  get: function() {\n    var script = window.HTMLImports.currentScript || document.currentScript ||\n        // NOTE: only works when called in synchronously executing code.\n        // readyState should check if `loading` but IE10 is\n        // interactive when scripts run so we cheat.\n        (document.readyState !== 'complete' ?\n        document.scripts[document.scripts.length - 1] : null);\n    return wrap(script);\n  },\n  configurable: true\n};\n\nObject.defineProperty(document, '_currentScript', currentScriptDescriptor);\nObject.defineProperty(rootDocument, '_currentScript', currentScriptDescriptor);\n\n/**\n  Add support for the `HTMLImportsLoaded` event and the `HTMLImports.whenReady`\n  method. This api is necessary because unlike the native implementation,\n  script elements do not force imports to resolve. Instead, users should wrap\n  code in either an `HTMLImportsLoaded` handler or after load time in an\n  `HTMLImports.whenReady(callback)` call.\n\n  NOTE: This module also supports these apis under the native implementation.\n  Therefore, if this file is loaded, the same code can be used under both\n  the polyfill and native implementation.\n */\n\nvar isIE = /Trident/.test(navigator.userAgent);\n\n// call a callback when all HTMLImports in the document at call time\n// (or at least document ready) have loaded.\n// 1. ensure the document is in a ready state (has dom), then\n// 2. watch for loading of imports and call callback when done\nfunction whenReady(callback, doc) {\n  doc = doc || rootDocument;\n  // if document is loading, wait and try again\n  whenDocumentReady(function() {\n    watchImportsLoad(callback, doc);\n  }, doc);\n}\n\n// call the callback when the document is in a ready state (has dom)\nvar requiredReadyState = isIE ? 'complete' : 'interactive';\nvar READY_EVENT = 'readystatechange';\nfunction isDocumentReady(doc) {\n  return (doc.readyState === 'complete' ||\n      doc.readyState === requiredReadyState);\n}\n\n// call <callback> when we ensure the document is in a ready state\nfunction whenDocumentReady(callback, doc) {\n  if (!isDocumentReady(doc)) {\n    var checkReady = function() {\n      if (doc.readyState === 'complete' ||\n          doc.readyState === requiredReadyState) {\n        doc.removeEventListener(READY_EVENT, checkReady);\n        whenDocumentReady(callback, doc);\n      }\n    };\n    doc.addEventListener(READY_EVENT, checkReady);\n  } else if (callback) {\n    callback();\n  }\n}\n\nfunction markTargetLoaded(event) {\n  event.target.__loaded = true;\n}\n\n// call <callback> when we ensure all imports have loaded\nfunction watchImportsLoad(callback, doc) {\n  var imports = doc.querySelectorAll('link[rel=import]');\n  var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];\n  function checkDone() {\n    if (parsedCount == importCount && callback) {\n      callback({\n        allImports: imports,\n        loadedImports: newImports,\n        errorImports: errorImports\n      });\n    }\n  }\n  function loadedImport(e) {\n    markTargetLoaded(e);\n    newImports.push(this);\n    parsedCount++;\n    checkDone();\n  }\n  function errorLoadingImport(e) {\n    errorImports.push(this);\n    parsedCount++;\n    checkDone();\n  }\n  if (importCount) {\n    for (var i=0, imp; i<importCount && (imp=imports[i]); i++) {\n      if (isImportLoaded(imp)) {\n        parsedCount++;\n        checkDone();\n      } else {\n        imp.addEventListener('load', loadedImport);\n        imp.addEventListener('error', errorLoadingImport);\n      }\n    }\n  } else {\n    checkDone();\n  }\n}\n\n// NOTE: test for native imports loading is based on explicitly watching\n// all imports (see below).\n// However, we cannot rely on this entirely without watching the entire document\n// for import links. For perf reasons, currently only head is watched.\n// Instead, we fallback to checking if the import property is available\n// and the document is not itself loading.\nfunction isImportLoaded(link) {\n  return useNative ? link.__loaded ||\n      (link.import && link.import.readyState !== 'loading') :\n      link.__importParsed;\n}\n\n// TODO(sorvell): Workaround for\n// https://www.w3.org/Bugs/Public/show_bug.cgi?id=25007, should be removed when\n// this bug is addressed.\n// (1) Install a mutation observer to see when HTMLImports have loaded\n// (2) if this script is run during document load it will watch any existing\n// imports for loading.\n//\n// NOTE: The workaround has restricted functionality: (1) it's only compatible\n// with imports that are added to document.head since the mutation observer\n// watches only head for perf reasons, (2) it requires this script\n// to run before any imports have completed loading.\nif (useNative) {\n  new MutationObserver(function(mxns) {\n    for (var i=0, l=mxns.length, m; (i < l) && (m=mxns[i]); i++) {\n      if (m.addedNodes) {\n        handleImports(m.addedNodes);\n      }\n    }\n  }).observe(document.head, {childList: true});\n\n  function handleImports(nodes) {\n    for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {\n      if (isImport(n)) {\n        handleImport(n);\n      }\n    }\n  }\n\n  function isImport(element) {\n    return element.localName === 'link' && element.rel === 'import';\n  }\n\n  function handleImport(element) {\n    var loaded = element.import;\n    if (loaded) {\n      markTargetLoaded({target: element});\n    } else {\n      element.addEventListener('load', markTargetLoaded);\n      element.addEventListener('error', markTargetLoaded);\n    }\n  }\n\n  // make sure to catch any imports that are in the process of loading\n  // when this script is run.\n  (function() {\n    if (document.readyState === 'loading') {\n      var imports = document.querySelectorAll('link[rel=import]');\n      for (var i=0, l=imports.length, imp; (i<l) && (imp=imports[i]); i++) {\n        handleImport(imp);\n      }\n    }\n  })();\n\n}\n\n// Fire the 'HTMLImportsLoaded' event when imports in document at load time\n// have loaded. This event is required to simulate the script blocking\n// behavior of native imports. A main document script that needs to be sure\n// imports have loaded should wait for this event.\nwhenReady(function(detail) {\n  window.HTMLImports.ready = true;\n  window.HTMLImports.readyTime = new Date().getTime();\n  var evt = rootDocument.createEvent(\"CustomEvent\");\n  evt.initCustomEvent(\"HTMLImportsLoaded\", true, true, detail);\n  rootDocument.dispatchEvent(evt);\n});\n\n// exports\nscope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;\nscope.useNative = useNative;\nscope.rootDocument = rootDocument;\nscope.whenReady = whenReady;\nscope.isIE = isIE;\n\n})(window.HTMLImports);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/HTMLImports/base.js\n ** module id = 16\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n(function(scope) {\n\n// world's simplest module initializer\nvar modules = [];\nvar addModule = function(module) {\n\tmodules.push(module);\n};\n\nvar initializeModules = function() {\n\tmodules.forEach(function(module) {\n\t\tmodule(scope);\n\t});\n};\n\n// exports\nscope.addModule = addModule;\nscope.initializeModules = initializeModules;\n\n})(window.HTMLImports);\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/HTMLImports/module.js\n ** module id = 17\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nwindow.HTMLImports.addModule(function(scope) {\n\nvar CSS_URL_REGEXP = /(url\\()([^)]*)(\\))/g;\nvar CSS_IMPORT_REGEXP = /(@import[\\s]+(?!url\\())([^;]*)(;)/g;\n\n// path fixup: style elements in imports must be made relative to the main\n// document. We fixup url's in url() and @import.\nvar path = {\n\n  resolveUrlsInStyle: function(style, linkUrl) {\n    var doc = style.ownerDocument;\n    var resolver = doc.createElement('a');\n    style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);\n    return style;\n  },\n\n  resolveUrlsInCssText: function(cssText, linkUrl, urlObj) {\n    var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);\n    r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);\n    return r;\n  },\n\n  replaceUrls: function(text, urlObj, linkUrl, regexp) {\n    return text.replace(regexp, function(m, pre, url, post) {\n      var urlPath = url.replace(/[\"']/g, '');\n      if (linkUrl) {\n        urlPath = (new URL(urlPath, linkUrl)).href;\n      }\n      urlObj.href = urlPath;\n      urlPath = urlObj.href;\n      return pre + '\\'' + urlPath + '\\'' + post;\n    });\n  }\n\n};\n\n// exports\nscope.path = path;\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/HTMLImports/path.js\n ** module id = 18\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nwindow.HTMLImports.addModule(function(scope) {\n\n/*\n  xhr processor.\n*/\nvar xhr = {\n  async: true,\n\n  ok: function(request) {\n    return (request.status >= 200 && request.status < 300)\n        || (request.status === 304)\n        || (request.status === 0);\n  },\n\n  load: function(url, next, nextContext) {\n    var request = new XMLHttpRequest();\n    if (scope.flags.debug || scope.flags.bust) {\n      url += '?' + Math.random();\n    }\n    request.open('GET', url, xhr.async);\n    request.addEventListener('readystatechange', function(e) {\n      if (request.readyState === 4) {\n        // Servers redirecting an import can add a Location header to help us\n        // polyfill correctly.\n        var redirectedUrl = null;\n        try {\n          var locationHeader = request.getResponseHeader(\"Location\");\n          if (locationHeader) {\n            redirectedUrl = (locationHeader.substr( 0, 1 ) === \"/\")\n              ? location.origin + locationHeader  // Location is a relative path\n              : locationHeader;                   // Full path\n          }\n        } catch ( e ) {\n            console.error( e.message );\n        }\n        next.call(nextContext, !xhr.ok(request) && request,\n            request.response || request.responseText, redirectedUrl);\n      }\n    });\n    request.send();\n    return request;\n  },\n\n  loadDocument: function(url, next, nextContext) {\n    this.load(url, next, nextContext).responseType = 'document';\n  }\n\n};\n\n// exports\nscope.xhr = xhr;\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/HTMLImports/xhr.js\n ** module id = 19\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nwindow.HTMLImports.addModule(function(scope) {\n\n// imports\nvar xhr = scope.xhr;\nvar flags = scope.flags;\n\n// This loader supports a dynamic list of urls\n// and an oncomplete callback that is called when the loader is done.\n// NOTE: The polyfill currently does *not* need this dynamism or the\n// onComplete concept. Because of this, the loader could be simplified\n// quite a bit.\nvar Loader = function(onLoad, onComplete) {\n  this.cache = {};\n  this.onload = onLoad;\n  this.oncomplete = onComplete;\n  this.inflight = 0;\n  this.pending = {};\n};\n\nLoader.prototype = {\n\n  addNodes: function(nodes) {\n    // number of transactions to complete\n    this.inflight += nodes.length;\n    // commence transactions\n    for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {\n      this.require(n);\n    }\n    // anything to do?\n    this.checkDone();\n  },\n\n  addNode: function(node) {\n    // number of transactions to complete\n    this.inflight++;\n    // commence transactions\n    this.require(node);\n    // anything to do?\n    this.checkDone();\n  },\n\n  require: function(elt) {\n    var url = elt.src || elt.href;\n    // ensure we have a standard url that can be used\n    // reliably for deduping.\n    // TODO(sjmiles): ad-hoc\n    elt.__nodeUrl = url;\n    // deduplication\n    if (!this.dedupe(url, elt)) {\n      // fetch this resource\n      this.fetch(url, elt);\n    }\n  },\n\n  dedupe: function(url, elt) {\n    if (this.pending[url]) {\n      // add to list of nodes waiting for inUrl\n      this.pending[url].push(elt);\n      // don't need fetch\n      return true;\n    }\n    var resource;\n    if (this.cache[url]) {\n      this.onload(url, elt, this.cache[url]);\n      // finished this transaction\n      this.tail();\n      // don't need fetch\n      return true;\n    }\n    // first node waiting for inUrl\n    this.pending[url] = [elt];\n    // need fetch (not a dupe)\n    return false;\n  },\n\n  fetch: function(url, elt) {\n    flags.load && console.log('fetch', url, elt);\n    if (!url) {\n      setTimeout(function() {\n        this.receive(url, elt, {error: 'href must be specified'}, null);\n      }.bind(this), 0);\n    } else if (url.match(/^data:/)) {\n      // Handle Data URI Scheme\n      var pieces = url.split(',');\n      var header = pieces[0];\n      var body = pieces[1];\n      if(header.indexOf(';base64') > -1) {\n        body = atob(body);\n      } else {\n        body = decodeURIComponent(body);\n      }\n      setTimeout(function() {\n          this.receive(url, elt, null, body);\n      }.bind(this), 0);\n    } else {\n      var receiveXhr = function(err, resource, redirectedUrl) {\n        this.receive(url, elt, err, resource, redirectedUrl);\n      }.bind(this);\n      xhr.load(url, receiveXhr);\n    }\n  },\n\n  receive: function(url, elt, err, resource, redirectedUrl) {\n    this.cache[url] = resource;\n    var $p = this.pending[url];\n    for (var i=0, l=$p.length, p; (i<l) && (p=$p[i]); i++) {\n      // If url was redirected, use the redirected location so paths are\n      // calculated relative to that.\n      this.onload(url, p, resource, err, redirectedUrl);\n      this.tail();\n    }\n    this.pending[url] = null;\n  },\n\n  tail: function() {\n    --this.inflight;\n    this.checkDone();\n  },\n\n  checkDone: function() {\n    if (!this.inflight) {\n      this.oncomplete();\n    }\n  }\n\n};\n\n// exports\nscope.Loader = Loader;\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/HTMLImports/Loader.js\n ** module id = 20\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nwindow.HTMLImports.addModule(function(scope) {\n\n/*\n  Use a mutation observer to call a callback for all added nodes.\n*/\nvar Observer = function(addCallback) {\n  this.addCallback = addCallback;\n  this.mo = new MutationObserver(this.handler.bind(this));\n};\n\nObserver.prototype = {\n\n  // we track mutations for addedNodes, looking for imports\n  handler: function(mutations) {\n    for (var i=0, l=mutations.length, m; (i<l) && (m=mutations[i]); i++) {\n      if (m.type === 'childList' && m.addedNodes.length) {\n        this.addedNodes(m.addedNodes);\n      }\n    }\n  },\n\n  addedNodes: function(nodes) {\n    if (this.addCallback) {\n      this.addCallback(nodes);\n    }\n    for (var i=0, l=nodes.length, n, loading; (i<l) && (n=nodes[i]); i++) {\n      if (n.children && n.children.length) {\n        this.addedNodes(n.children);\n      }\n    }\n  },\n\n  observe: function(root) {\n    this.mo.observe(root, {childList: true, subtree: true});\n  }\n\n};\n\n// exports\nscope.Observer = Observer;\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/HTMLImports/Observer.js\n ** module id = 21\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nwindow.HTMLImports.addModule(function(scope) {\n\n// imports\nvar path = scope.path;\nvar rootDocument = scope.rootDocument;\nvar flags = scope.flags;\nvar isIE = scope.isIE;\nvar IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\nvar IMPORT_SELECTOR = 'link[rel=' + IMPORT_LINK_TYPE + ']';\n\n// importParser\n// highlander object to manage parsing of imports\n// parses import related elements and ensures proper parse order\n// parse order is enforced by crawling the tree and monitoring which elements\n// have been parsed;\n// elements can be dynamically added to imports. These are maintained in a\n// separate queue and parsed after all other elements.\nvar importParser = {\n\n  // parse selectors for main document elements\n  documentSelectors: IMPORT_SELECTOR,\n\n  // parse selectors for import document elements\n  importsSelectors: [\n    IMPORT_SELECTOR,\n    'link[rel=stylesheet]:not([type])',\n    'style:not([type])',\n    'script:not([type])',\n    'script[type=\"application/javascript\"]',\n    'script[type=\"text/javascript\"]'\n  ].join(','),\n\n  map: {\n    link: 'parseLink',\n    script: 'parseScript',\n    style: 'parseStyle'\n  },\n\n  dynamicElements: [],\n\n  // try to parse the next import in the tree\n  parseNext: function() {\n    var next = this.nextToParse();\n    if (next) {\n      this.parse(next);\n    }\n  },\n\n  parse: function(elt) {\n    if (this.isParsed(elt)) {\n      flags.parse && console.log('[%s] is already parsed', elt.localName);\n      return;\n    }\n    var fn = this[this.map[elt.localName]];\n    if (fn) {\n      this.markParsing(elt);\n      fn.call(this, elt);\n    }\n  },\n\n  // marks an element for dynamic parsing and attempts to parse the next element\n  parseDynamic: function(elt, quiet) {\n    this.dynamicElements.push(elt);\n    if (!quiet) {\n      this.parseNext();\n    }\n  },\n\n  // only 1 element may be parsed at a time; parsing is async so each\n  // parsing implementation must inform the system that parsing is complete\n  // via markParsingComplete.\n  // To prompt the system to parse the next element, parseNext should then be\n  // called.\n  // Note, parseNext used to be included at the end of markParsingComplete, but\n  // we must not do this so that, for example, we can (1) mark parsing complete\n  // then (2) fire an import load event, and then (3) parse the next resource.\n  markParsing: function(elt) {\n    flags.parse && console.log('parsing', elt);\n    this.parsingElement = elt;\n  },\n\n  markParsingComplete: function(elt) {\n    elt.__importParsed = true;\n    this.markDynamicParsingComplete(elt);\n    if (elt.__importElement) {\n      elt.__importElement.__importParsed = true;\n      this.markDynamicParsingComplete(elt.__importElement);\n    }\n    this.parsingElement = null;\n    flags.parse && console.log('completed', elt);\n  },\n\n  markDynamicParsingComplete: function(elt) {\n    var i = this.dynamicElements.indexOf(elt);\n    if (i >= 0) {\n      this.dynamicElements.splice(i, 1);\n    }\n  },\n\n  parseImport: function(elt) {\n    elt.import = elt.__doc;\n    if (window.HTMLImports.__importsParsingHook) {\n      window.HTMLImports.__importsParsingHook(elt);\n    }\n    if (elt.import) {\n      elt.import.__importParsed = true;\n    }\n    this.markParsingComplete(elt);\n    // fire load event\n    if (elt.__resource && !elt.__error) {\n      elt.dispatchEvent(new CustomEvent('load', {bubbles: false}));\n    } else {\n      elt.dispatchEvent(new CustomEvent('error', {bubbles: false}));\n    }\n    // TODO(sorvell): workaround for Safari addEventListener not working\n    // for elements not in the main document.\n    if (elt.__pending) {\n      var fn;\n      while (elt.__pending.length) {\n        fn = elt.__pending.shift();\n        if (fn) {\n          fn({target: elt});\n        }\n      }\n    }\n    this.parseNext();\n  },\n\n  parseLink: function(linkElt) {\n    if (nodeIsImport(linkElt)) {\n      this.parseImport(linkElt);\n    } else {\n      // make href absolute\n      linkElt.href = linkElt.href;\n      this.parseGeneric(linkElt);\n    }\n  },\n\n  parseStyle: function(elt) {\n    // TODO(sorvell): style element load event can just not fire so clone styles\n    var src = elt;\n    elt = cloneStyle(elt);\n    src.__appliedElement = elt;\n    elt.__importElement = src;\n    this.parseGeneric(elt);\n  },\n\n  parseGeneric: function(elt) {\n    this.trackElement(elt);\n    this.addElementToDocument(elt);\n  },\n\n  rootImportForElement: function(elt) {\n    var n = elt;\n    while (n.ownerDocument.__importLink) {\n      n = n.ownerDocument.__importLink;\n    }\n    return n;\n  },\n\n  addElementToDocument: function(elt) {\n    var port = this.rootImportForElement(elt.__importElement || elt);\n    port.parentNode.insertBefore(elt, port);\n  },\n\n  // tracks when a loadable element has loaded\n  trackElement: function(elt, callback) {\n    var self = this;\n    var done = function(e) {\n      // make sure we don't get multiple load/error signals (FF seems to do\n      // this sometimes when <style> elments change)\n      elt.removeEventListener('load', done);\n      elt.removeEventListener('error', done);\n      if (callback) {\n        callback(e);\n      }\n      self.markParsingComplete(elt);\n      self.parseNext();\n    };\n    elt.addEventListener('load', done);\n    elt.addEventListener('error', done);\n\n    // NOTE: IE does not fire \"load\" event for styles that have already loaded\n    // This is in violation of the spec, so we try our hardest to work around it\n    if (isIE && elt.localName === 'style') {\n      var fakeLoad = false;\n      // If there's not @import in the textContent, assume it has loaded\n      if (elt.textContent.indexOf('@import') == -1) {\n        fakeLoad = true;\n      // if we have a sheet, we have been parsed\n      } else if (elt.sheet) {\n        fakeLoad = true;\n        var csr = elt.sheet.cssRules;\n        var len = csr ? csr.length : 0;\n        // search the rules for @import's\n        for (var i = 0, r; (i < len) && (r = csr[i]); i++) {\n          if (r.type === CSSRule.IMPORT_RULE) {\n            // if every @import has resolved, fake the load\n            fakeLoad = fakeLoad && Boolean(r.styleSheet);\n          }\n        }\n      }\n      // dispatch a fake load event and continue parsing\n      if (fakeLoad) {\n        // Fire async, to prevent reentrancy\n        setTimeout(function() {\n          elt.dispatchEvent(new CustomEvent('load', {bubbles: false}));\n        });\n      }\n    }\n  },\n\n  // NOTE: execute scripts by injecting them and watching for the load/error\n  // event. Inline scripts are handled via dataURL's because browsers tend to\n  // provide correct parsing errors in this case. If this has any compatibility\n  // issues, we can switch to injecting the inline script with textContent.\n  parseScript: function(scriptElt) {\n    var script = document.createElement('script');\n    script.__importElement = scriptElt;\n    script.src = scriptElt.src ? scriptElt.src :\n        generateScriptDataUrl(scriptElt);\n    // keep track of executing script to help polyfill `document.currentScript`\n    scope.currentScript = scriptElt;\n    this.trackElement(script, function(e) {\n      if (script.parentNode) {\n        script.parentNode.removeChild(script);\n      }\n      scope.currentScript = null;\n    });\n    this.addElementToDocument(script);\n  },\n\n  // determine the next element in the tree which should be parsed\n  // crawl the document tree to find the next unparsed element\n  // then process any dynamically added elements (these should process in 'add'\n  // order.\n  nextToParse: function() {\n    this._mayParse = [];\n    return !this.parsingElement && (this.nextToParseInDoc(rootDocument) ||\n        this.nextToParseDynamic());\n  },\n\n  nextToParseInDoc: function(doc, link) {\n    // use `marParse` list to avoid looping into the same document again\n    // since it could cause an iloop.\n    if (doc && this._mayParse.indexOf(doc) < 0) {\n      this._mayParse.push(doc);\n      var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));\n      for (var i=0, l=nodes.length, p=0, n; (i<l) && (n=nodes[i]); i++) {\n        if (!this.isParsed(n)) {\n          if (this.hasResource(n)) {\n            return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;\n          } else {\n            return;\n          }\n        }\n      }\n    }\n    // all nodes have been parsed, ready to parse import, if any\n    return link;\n  },\n\n  // note dynamically added elements are stored in a separate queue\n  nextToParseDynamic: function() {\n    return this.dynamicElements[0];\n  },\n\n  // return the set of parse selectors relevant for this node.\n  parseSelectorsForNode: function(node) {\n    var doc = node.ownerDocument || node;\n    return doc === rootDocument ? this.documentSelectors :\n        this.importsSelectors;\n  },\n\n  isParsed: function(node) {\n    return node.__importParsed;\n  },\n\n  needsDynamicParsing: function(elt) {\n    return (this.dynamicElements.indexOf(elt) >= 0);\n  },\n\n  hasResource: function(node) {\n    if (nodeIsImport(node) && (node.__doc === undefined)) {\n      return false;\n    }\n    return true;\n  }\n\n};\n\nfunction nodeIsImport(elt) {\n  return (elt.localName === 'link') && (elt.rel === IMPORT_LINK_TYPE);\n}\n\nfunction generateScriptDataUrl(script) {\n  var scriptContent = generateScriptContent(script);\n  return 'data:text/javascript;charset=utf-8,' + encodeURIComponent(scriptContent);\n}\n\nfunction generateScriptContent(script) {\n  return script.textContent + generateSourceMapHint(script);\n}\n\n// calculate source map hint\nfunction generateSourceMapHint(script) {\n  var owner = script.ownerDocument;\n  owner.__importedScripts = owner.__importedScripts || 0;\n  var moniker = script.ownerDocument.baseURI;\n  var num = owner.__importedScripts ? '-' + owner.__importedScripts : '';\n  owner.__importedScripts++;\n  return '\\n//# sourceURL=' + moniker + num + '.js\\n';\n}\n\n// style/stylesheet handling\n\n// clone style with proper path resolution for main document\n// NOTE: styles are the only elements that require direct path fixup.\nfunction cloneStyle(style) {\n  var clone = style.ownerDocument.createElement('style');\n  clone.textContent = style.textContent;\n  path.resolveUrlsInStyle(clone);\n  return clone;\n}\n\n// exports\nscope.parser = importParser;\nscope.IMPORT_SELECTOR = IMPORT_SELECTOR;\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/HTMLImports/parser.js\n ** module id = 22\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nwindow.HTMLImports.addModule(function(scope) {\n\n// imports\nvar flags = scope.flags;\nvar IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\nvar IMPORT_SELECTOR = scope.IMPORT_SELECTOR;\nvar rootDocument = scope.rootDocument;\nvar Loader = scope.Loader;\nvar Observer = scope.Observer;\nvar parser = scope.parser;\n\n// importer\n// highlander object to manage loading of imports\n// for any document, importer:\n// - loads any linked import documents (with deduping)\n// - whenever an import is loaded, prompts the parser to try to parse\n// - observes imported documents for new elements (these are handled via the\n// dynamic importer)\nvar importer = {\n\n  documents: {},\n\n  // nodes to load in the mian document\n  documentPreloadSelectors: IMPORT_SELECTOR,\n\n  // nodes to load in imports\n  importsPreloadSelectors: [\n    IMPORT_SELECTOR\n  ].join(','),\n\n  loadNode: function(node) {\n    importLoader.addNode(node);\n  },\n\n  // load all loadable elements within the parent element\n  loadSubtree: function(parent) {\n    var nodes = this.marshalNodes(parent);\n    // add these nodes to loader's queue\n    importLoader.addNodes(nodes);\n  },\n\n  marshalNodes: function(parent) {\n    // all preloadable nodes in inDocument\n    return parent.querySelectorAll(this.loadSelectorsForNode(parent));\n  },\n\n  // find the proper set of load selectors for a given node\n  loadSelectorsForNode: function(node) {\n    var doc = node.ownerDocument || node;\n    return doc === rootDocument ? this.documentPreloadSelectors :\n        this.importsPreloadSelectors;\n  },\n\n  loaded: function(url, elt, resource, err, redirectedUrl) {\n    flags.load && console.log('loaded', url, elt);\n    // store generic resource\n    // TODO(sorvell): fails for nodes inside <template>.content\n    // see https://code.google.com/p/chromium/issues/detail?id=249381.\n    elt.__resource = resource;\n    elt.__error = err;\n    if (isImportLink(elt)) {\n      var doc = this.documents[url];\n      // if we've never seen a document at this url\n      if (doc === undefined) {\n        // generate an HTMLDocument from data\n        doc = err ? null : makeDocument(resource, redirectedUrl || url);\n        if (doc) {\n          doc.__importLink = elt;\n          // note, we cannot use MO to detect parsed nodes because\n          // SD polyfill does not report these as mutations.\n          this.bootDocument(doc);\n        }\n        // cache document\n        this.documents[url] = doc;\n      }\n      // don't store import record until we're actually loaded\n      // store document resource\n      elt.__doc = doc;\n    }\n    parser.parseNext();\n  },\n\n  bootDocument: function(doc) {\n    this.loadSubtree(doc);\n    // observe documents for new elements being added\n    this.observer.observe(doc);\n    parser.parseNext();\n  },\n\n  loadedAll: function() {\n    parser.parseNext();\n  }\n\n};\n\n// loader singleton to handle loading imports\nvar importLoader = new Loader(importer.loaded.bind(importer),\n    importer.loadedAll.bind(importer));\n\n// observer singleton to handle observing elements in imports\n// NOTE: the observer has a node added callback and this is set\n// by the dynamic importer module.\nimporter.observer = new Observer();\n\nfunction isImportLink(elt) {\n  return isLinkRel(elt, IMPORT_LINK_TYPE);\n}\n\nfunction isLinkRel(elt, rel) {\n  return elt.localName === 'link' && elt.getAttribute('rel') === rel;\n}\n\nfunction hasBaseURIAccessor(doc) {\n  return !! Object.getOwnPropertyDescriptor(doc, 'baseURI');\n}\n\nfunction makeDocument(resource, url) {\n  // create a new HTML document\n  var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);\n  // cache the new document's source url\n  doc._URL = url;\n  // establish a relative path via <base>\n  var base = doc.createElement('base');\n  base.setAttribute('href', url);\n  // add baseURI support to browsers (IE) that lack it.\n  if (!doc.baseURI && !hasBaseURIAccessor(doc)) {\n    // Use defineProperty since Safari throws an exception when using assignment.\n    Object.defineProperty(doc, 'baseURI', {value:url});\n  }\n  // ensure UTF-8 charset\n  var meta = doc.createElement('meta');\n  meta.setAttribute('charset', 'utf-8');\n\n  doc.head.appendChild(meta);\n  doc.head.appendChild(base);\n  // install html\n  doc.body.innerHTML = resource;\n  // TODO(sorvell): ideally this code is not aware of Template polyfill,\n  // but for now the polyfill needs help to bootstrap these templates\n  if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {\n    HTMLTemplateElement.bootstrap(doc);\n  }\n  return doc;\n}\n\n// Polyfill document.baseURI for browsers without it.\nif (!document.baseURI) {\n  var baseURIDescriptor = {\n    get: function() {\n      var base = document.querySelector('base');\n      return base ? base.href : window.location.href;\n    },\n    configurable: true\n  };\n\n  Object.defineProperty(document, 'baseURI', baseURIDescriptor);\n  Object.defineProperty(rootDocument, 'baseURI', baseURIDescriptor);\n}\n\n// exports\nscope.importer = importer;\nscope.importLoader = importLoader;\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/HTMLImports/importer.js\n ** module id = 23\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nwindow.HTMLImports.addModule(function(scope) {\n\n// imports\nvar parser = scope.parser;\nvar importer = scope.importer;\n\n// dynamic\n// highlander object to manage elements dynamically added to imports\n// for any observed document, dynamic:\n// - tells the importer to load any imports that are added.\n// - tells the parser to parse any added elements that need to be parsed.\n// dynamic importer)\nvar dynamic = {\n  // process (load/parse) any nodes added to imported documents.\n  added: function(nodes) {\n    var owner, parsed, loading;\n    for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {\n      if (!owner) {\n        owner = n.ownerDocument;\n        parsed = parser.isParsed(owner);\n      }\n      // note: the act of loading kicks the parser, so we use parseDynamic's\n      // 2nd argument to control if this added node needs to kick the parser.\n      loading = this.shouldLoadNode(n);\n      if (loading) {\n        importer.loadNode(n);\n      }\n      if (this.shouldParseNode(n) && parsed) {\n        parser.parseDynamic(n, loading);\n      }\n    }\n  },\n\n  shouldLoadNode: function(node) {\n    return (node.nodeType === 1) && matches.call(node,\n        importer.loadSelectorsForNode(node));\n  },\n\n  shouldParseNode: function(node) {\n    return (node.nodeType === 1) && matches.call(node,\n        parser.parseSelectorsForNode(node));\n  }\n\n};\n\n// let the dynamic element helper tie into the import observer.\nimporter.observer.addCallback = dynamic.added.bind(dynamic);\n\n// x-plat matches\nvar matches = HTMLElement.prototype.matches ||\n    HTMLElement.prototype.matchesSelector ||\n    HTMLElement.prototype.webkitMatchesSelector ||\n    HTMLElement.prototype.mozMatchesSelector ||\n    HTMLElement.prototype.msMatchesSelector;\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/HTMLImports/dynamic.js\n ** module id = 24\n ** module chunks = 0\n **/","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n(function(scope){\n\n// imports\nvar initializeModules = scope.initializeModules;\nvar isIE = scope.isIE;\n\n/*\nNOTE: Even when native HTMLImports exists, the following api is available by\nloading the polyfill. This provides api compatibility where the polyfill\ncannot be \"correct\":\n\n  * `document._currentScript`\n  * `HTMLImportsLoaded` event\n  * `HTMLImports.whenReady(callback)\n*/\nif (scope.useNative) {\n  return;\n}\n\n// Initialize polyfill modules. Note, polyfill modules are loaded but not\n// executed; this is a convenient way to control which modules run when\n// the polyfill is required and allows the polyfill to load even when it's\n// not needed.\ninitializeModules();\n\n// imports\nvar rootDocument = scope.rootDocument;\n\n/*\n  Bootstrap the imports machine.\n*/\nfunction bootstrap() {\n  window.HTMLImports.importer.bootDocument(rootDocument);\n}\n\n// TODO(sorvell): SD polyfill does *not* generate mutations for nodes added\n// by the parser. For this reason, we must wait until the dom exists to\n// bootstrap.\nif (document.readyState === 'complete' ||\n    (document.readyState === 'interactive' && !window.attachEvent)) {\n  bootstrap();\n} else {\n  document.addEventListener('DOMContentLoaded', bootstrap);\n}\n\n})(window.HTMLImports);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webcomponents.js/src/HTMLImports/boot.js\n ** module id = 25\n ** module chunks = 0\n **/","var HANDJS = HANDJS || {};\r\n\r\n(function () {\r\n    // If the user agent already supports Pointer Events, do nothing\r\n    if (window.PointerEvent)\r\n        return;\r\n\r\n    // Polyfilling indexOf for old browsers\r\n    if (!Array.prototype.indexOf) {\r\n        Array.prototype.indexOf = function (searchElement) {\r\n            var t = Object(this);\r\n            var len = t.length >>> 0;\r\n            if (len === 0) {\r\n                return -1;\r\n            }\r\n            var n = 0;\r\n            if (arguments.length > 0) {\r\n                n = Number(arguments[1]);\r\n                if (n !== n) { // shortcut for verifying if it's NaN\r\n                    n = 0;\r\n                } else if (n !== 0 && n !== Infinity && n !== -Infinity) {\r\n                    n = (n > 0 || -1) * Math.floor(Math.abs(n));\r\n                }\r\n            }\r\n            if (n >= len) {\r\n                return -1;\r\n            }\r\n            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\r\n            for (; k < len; k++) {\r\n                if (k in t && t[k] === searchElement) {\r\n                    return k;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n    }\r\n    //Polyfilling forEach for old browsers\r\n    if (!Array.prototype.forEach) {\r\n        Array.prototype.forEach = function (method, thisArg) {\r\n            if (!this || !(method instanceof Function))\r\n                throw new TypeError();\r\n            for (var i = 0; i < this.length; i++)\r\n                method.call(thisArg, this[i], i, this);\r\n        };\r\n    }\r\n\t// Polyfilling trim for old browsers\r\n\tif (!String.prototype.trim) {\r\n\t\tString.prototype.trim = function () {\r\n\t\t\treturn this.replace(/^\\s+|\\s+$/, '');\r\n\t\t};\r\n\t}\r\n\r\n    // Installing Hand.js\r\n    var supportedEventsNames = [\"pointerdown\", \"pointerup\", \"pointermove\", \"pointerover\", \"pointerout\", \"pointercancel\", \"pointerenter\", \"pointerleave\"];\r\n    var upperCaseEventsNames = [\"PointerDown\", \"PointerUp\", \"PointerMove\", \"PointerOver\", \"PointerOut\", \"PointerCancel\", \"PointerEnter\", \"PointerLeave\"];\r\n\r\n    var POINTER_TYPE_TOUCH = \"touch\";\r\n    var POINTER_TYPE_PEN = \"pen\";\r\n    var POINTER_TYPE_MOUSE = \"mouse\";\r\n\r\n    var previousTargets = {};\r\n\r\n    var checkPreventDefault = function (node) {\r\n        while (node && !node.handjs_forcePreventDefault) {\r\n            node = node.parentNode;\r\n        }\r\n        return !!node || window.handjs_forcePreventDefault;\r\n    };\r\n\r\n    // Touch events\r\n    var generateTouchClonedEvent = function (sourceEvent, newName, canBubble, target, relatedTarget) {\r\n        // Considering touch events are almost like super mouse events\r\n        var evObj;\r\n        \r\n        if (document.createEvent) {\r\n            evObj = document.createEvent('MouseEvents');\r\n            evObj.initMouseEvent(newName, canBubble, true, window, 1, sourceEvent.screenX, sourceEvent.screenY,\r\n                sourceEvent.clientX, sourceEvent.clientY, sourceEvent.ctrlKey, sourceEvent.altKey,\r\n                sourceEvent.shiftKey, sourceEvent.metaKey, sourceEvent.button, relatedTarget || sourceEvent.relatedTarget);\r\n        }\r\n        else {\r\n            evObj = document.createEventObject();\r\n            evObj.screenX = sourceEvent.screenX;\r\n            evObj.screenY = sourceEvent.screenY;\r\n            evObj.clientX = sourceEvent.clientX;\r\n            evObj.clientY = sourceEvent.clientY;\r\n            evObj.ctrlKey = sourceEvent.ctrlKey;\r\n            evObj.altKey = sourceEvent.altKey;\r\n            evObj.shiftKey = sourceEvent.shiftKey;\r\n            evObj.metaKey = sourceEvent.metaKey;\r\n            evObj.button = sourceEvent.button;\r\n            evObj.relatedTarget = relatedTarget || sourceEvent.relatedTarget;\r\n        }\r\n        // offsets\r\n        if (evObj.offsetX === undefined) {\r\n            if (sourceEvent.offsetX !== undefined) {\r\n\r\n                // For Opera which creates readonly properties\r\n                if (Object && Object.defineProperty !== undefined) {\r\n                    Object.defineProperty(evObj, \"offsetX\", {\r\n                        writable: true\r\n                    });\r\n                    Object.defineProperty(evObj, \"offsetY\", {\r\n                        writable: true\r\n                    });\r\n                }\r\n\r\n                evObj.offsetX = sourceEvent.offsetX;\r\n                evObj.offsetY = sourceEvent.offsetY;\r\n            } else if (Object && Object.defineProperty !== undefined) {\r\n                Object.defineProperty(evObj, \"offsetX\", {\r\n                    get: function () {\r\n                        if (this.currentTarget && this.currentTarget.offsetLeft) {\r\n                            return sourceEvent.clientX - this.currentTarget.offsetLeft;\r\n                        }\r\n                        return sourceEvent.clientX;\r\n                    }\r\n                });\r\n                Object.defineProperty(evObj, \"offsetY\", {\r\n                    get: function () {\r\n                        if (this.currentTarget && this.currentTarget.offsetTop) {\r\n                            return sourceEvent.clientY - this.currentTarget.offsetTop;\r\n                        }\r\n                        return sourceEvent.clientY;\r\n                    }\r\n                });\r\n            }\r\n            else if (sourceEvent.layerX !== undefined) {\r\n                evObj.offsetX = sourceEvent.layerX - sourceEvent.currentTarget.offsetLeft;\r\n                evObj.offsetY = sourceEvent.layerY - sourceEvent.currentTarget.offsetTop;\r\n            }\r\n        }\r\n\r\n        // adding missing properties\r\n\r\n        if (sourceEvent.isPrimary !== undefined)\r\n            evObj.isPrimary = sourceEvent.isPrimary;\r\n        else\r\n            evObj.isPrimary = true;\r\n\r\n        if (sourceEvent.pressure)\r\n            evObj.pressure = sourceEvent.pressure;\r\n        else {\r\n            var button = 0;\r\n\r\n            if (sourceEvent.which !== undefined)\r\n                button = sourceEvent.which;\r\n            else if (sourceEvent.button !== undefined) {\r\n                button = sourceEvent.button;\r\n            }\r\n            evObj.pressure = (button === 0) ? 0 : 0.5;\r\n        }\r\n\r\n\r\n        if (sourceEvent.rotation)\r\n            evObj.rotation = sourceEvent.rotation;\r\n        else\r\n            evObj.rotation = 0;\r\n\r\n        // Timestamp\r\n        if (sourceEvent.hwTimestamp)\r\n            evObj.hwTimestamp = sourceEvent.hwTimestamp;\r\n        else\r\n            evObj.hwTimestamp = 0;\r\n\r\n        // Tilts\r\n        if (sourceEvent.tiltX)\r\n            evObj.tiltX = sourceEvent.tiltX;\r\n        else\r\n            evObj.tiltX = 0;\r\n\r\n        if (sourceEvent.tiltY)\r\n            evObj.tiltY = sourceEvent.tiltY;\r\n        else\r\n            evObj.tiltY = 0;\r\n\r\n        // Width and Height\r\n        if (sourceEvent.height)\r\n            evObj.height = sourceEvent.height;\r\n        else\r\n            evObj.height = 0;\r\n\r\n        if (sourceEvent.width)\r\n            evObj.width = sourceEvent.width;\r\n        else\r\n            evObj.width = 0;\r\n\r\n        // preventDefault\r\n        evObj.preventDefault = function () {\r\n            if (sourceEvent.preventDefault !== undefined)\r\n                sourceEvent.preventDefault();\r\n        };\r\n\r\n        // stopPropagation\r\n        if (evObj.stopPropagation !== undefined) {\r\n            var current = evObj.stopPropagation;\r\n            evObj.stopPropagation = function () {\r\n                if (sourceEvent.stopPropagation !== undefined)\r\n                    sourceEvent.stopPropagation();\r\n                current.call(this);\r\n            };\r\n        }\r\n\r\n        // Pointer values\r\n        evObj.pointerId = sourceEvent.pointerId;\r\n        evObj.pointerType = sourceEvent.pointerType;\r\n\r\n        switch (evObj.pointerType) {// Old spec version check\r\n            case 2:\r\n                evObj.pointerType = POINTER_TYPE_TOUCH;\r\n                break;\r\n            case 3:\r\n                evObj.pointerType = POINTER_TYPE_PEN;\r\n                break;\r\n            case 4:\r\n                evObj.pointerType = POINTER_TYPE_MOUSE;\r\n                break;\r\n        }\r\n\r\n        // Fire event\r\n        if (target)\r\n            target.dispatchEvent(evObj);\r\n        else if (sourceEvent.target) {\r\n            sourceEvent.target.dispatchEvent(evObj);\r\n        } else {\r\n            sourceEvent.srcElement.fireEvent(\"on\" + getMouseEquivalentEventName(newName), evObj); // We must fallback to mouse event for very old browsers\r\n        }\r\n    };\r\n\r\n    var generateMouseProxy = function (evt, eventName, canBubble, target, relatedTarget) {\r\n        evt.pointerId = 1;\r\n        evt.pointerType = POINTER_TYPE_MOUSE;\r\n        generateTouchClonedEvent(evt, eventName, canBubble, target, relatedTarget);\r\n    };\r\n\r\n    var generateTouchEventProxy = function (name, touchPoint, target, eventObject, canBubble, relatedTarget) {\r\n        var touchPointId = touchPoint.identifier + 2; // Just to not override mouse id\r\n\r\n        touchPoint.pointerId = touchPointId;\r\n        touchPoint.pointerType = POINTER_TYPE_TOUCH;\r\n        touchPoint.currentTarget = target;\r\n\r\n        if (eventObject.preventDefault !== undefined) {\r\n            touchPoint.preventDefault = function () {\r\n                eventObject.preventDefault();\r\n            };\r\n        }\r\n\r\n        generateTouchClonedEvent(touchPoint, name, canBubble, target, relatedTarget);\r\n    };\r\n\r\n    var checkEventRegistration = function (node, eventName) {\r\n        return node.__handjsGlobalRegisteredEvents && node.__handjsGlobalRegisteredEvents[eventName];\r\n    };\r\n    var findEventRegisteredNode = function (node, eventName) {\r\n        while (node && !checkEventRegistration(node, eventName))\r\n            node = node.parentNode;\r\n        if (node)\r\n            return node;\r\n        else if (checkEventRegistration(window, eventName))\r\n            return window;\r\n    };\r\n\r\n    var generateTouchEventProxyIfRegistered = function (eventName, touchPoint, target, eventObject, canBubble, relatedTarget) { // Check if user registered this event\r\n        if (findEventRegisteredNode(target, eventName)) {\r\n            generateTouchEventProxy(eventName, touchPoint, target, eventObject, canBubble, relatedTarget);\r\n        }\r\n    };\r\n\r\n    //var handleOtherEvent = function (eventObject, name, useLocalTarget, checkRegistration) {\r\n    //    if (eventObject.preventManipulation)\r\n    //        eventObject.preventManipulation();\r\n\r\n    //    for (var i = 0; i < eventObject.changedTouches.length; ++i) {\r\n    //        var touchPoint = eventObject.changedTouches[i];\r\n\r\n    //        if (useLocalTarget) {\r\n    //            previousTargets[touchPoint.identifier] = touchPoint.target;\r\n    //        }\r\n\r\n    //        if (checkRegistration) {\r\n    //            generateTouchEventProxyIfRegistered(name, touchPoint, previousTargets[touchPoint.identifier], eventObject, true);\r\n    //        } else {\r\n    //            generateTouchEventProxy(name, touchPoint, previousTargets[touchPoint.identifier], eventObject, true);\r\n    //        }\r\n    //    }\r\n    //};\r\n\r\n    var getMouseEquivalentEventName = function (eventName) {\r\n        return eventName.toLowerCase().replace(\"pointer\", \"mouse\");\r\n    };\r\n\r\n    var getPrefixEventName = function (prefix, eventName) {\r\n        var upperCaseIndex = supportedEventsNames.indexOf(eventName);\r\n        var newEventName = prefix + upperCaseEventsNames[upperCaseIndex];\r\n\r\n        return newEventName;\r\n    };\r\n\r\n    var registerOrUnregisterEvent = function (item, name, func, enable) {\r\n        if (item.__handjsRegisteredEvents === undefined) {\r\n            item.__handjsRegisteredEvents = [];\r\n        }\r\n\r\n        if (enable) {\r\n            if (item.__handjsRegisteredEvents[name] !== undefined) {\r\n                item.__handjsRegisteredEvents[name]++;\r\n                return;\r\n            }\r\n\r\n            item.__handjsRegisteredEvents[name] = 1;\r\n            item.addEventListener(name, func, false);\r\n        } else {\r\n\r\n            if (item.__handjsRegisteredEvents.indexOf(name) !== -1) {\r\n                item.__handjsRegisteredEvents[name]--;\r\n\r\n                if (item.__handjsRegisteredEvents[name] !== 0) {\r\n                    return;\r\n                }\r\n            }\r\n            item.removeEventListener(name, func);\r\n            item.__handjsRegisteredEvents[name] = 0;\r\n        }\r\n    };\r\n\r\n    var setTouchAware = function (item, eventName, enable) {\r\n        // Leaving tokens\r\n        if (!item.__handjsGlobalRegisteredEvents) {\r\n            item.__handjsGlobalRegisteredEvents = [];\r\n        }\r\n        if (enable) {\r\n            if (item.__handjsGlobalRegisteredEvents[eventName] !== undefined) {\r\n                item.__handjsGlobalRegisteredEvents[eventName]++;\r\n                return;\r\n            }\r\n            item.__handjsGlobalRegisteredEvents[eventName] = 1;\r\n        } else {\r\n            if (item.__handjsGlobalRegisteredEvents[eventName] !== undefined) {\r\n                item.__handjsGlobalRegisteredEvents[eventName]--;\r\n                if (item.__handjsGlobalRegisteredEvents[eventName] < 0) {\r\n                    item.__handjsGlobalRegisteredEvents[eventName] = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        var nameGenerator;\r\n        var eventGenerator;\r\n        if (window.MSPointerEvent) {\r\n            nameGenerator = function (name) { return getPrefixEventName(\"MS\", name); };\r\n            eventGenerator = generateTouchClonedEvent;\r\n        }\r\n        else {\r\n            nameGenerator = getMouseEquivalentEventName;\r\n            eventGenerator = generateMouseProxy;\r\n        }\r\n        switch (eventName) {\r\n            case \"pointerenter\":\r\n            case \"pointerleave\":\r\n                var targetEvent = nameGenerator(eventName);\r\n                if (item['on' + targetEvent.toLowerCase()] !== undefined) {\r\n                    registerOrUnregisterEvent(item, targetEvent, function (evt) { eventGenerator(evt, eventName); }, enable);\r\n                }\r\n                break;\r\n        }\r\n    };\r\n\r\n    // Intercept addEventListener calls by changing the prototype\r\n    var interceptAddEventListener = function (root) {\r\n        var current = root.prototype ? root.prototype.addEventListener : root.addEventListener;\r\n\r\n        var customAddEventListener = function (name, func, capture) {\r\n            // Branch when a PointerXXX is used\r\n            if (supportedEventsNames.indexOf(name) !== -1) {\r\n                setTouchAware(this, name, true);\r\n            }\r\n\r\n            if (current === undefined) {\r\n                this.attachEvent(\"on\" + getMouseEquivalentEventName(name), func);\r\n            } else {\r\n                current.call(this, name, func, capture);\r\n            }\r\n        };\r\n\r\n        if (root.prototype) {\r\n            root.prototype.addEventListener = customAddEventListener;\r\n        } else {\r\n            root.addEventListener = customAddEventListener;\r\n        }\r\n    };\r\n\r\n    // Intercept removeEventListener calls by changing the prototype\r\n    var interceptRemoveEventListener = function (root) {\r\n        var current = root.prototype ? root.prototype.removeEventListener : root.removeEventListener;\r\n\r\n        var customRemoveEventListener = function (name, func, capture) {\r\n            // Release when a PointerXXX is used\r\n            if (supportedEventsNames.indexOf(name) !== -1) {\r\n                setTouchAware(this, name, false);\r\n            }\r\n\r\n            if (current === undefined) {\r\n                this.detachEvent(getMouseEquivalentEventName(name), func);\r\n            } else {\r\n                current.call(this, name, func, capture);\r\n            }\r\n        };\r\n        if (root.prototype) {\r\n            root.prototype.removeEventListener = customRemoveEventListener;\r\n        } else {\r\n            root.removeEventListener = customRemoveEventListener;\r\n        }\r\n    };\r\n\r\n    // Hooks\r\n    interceptAddEventListener(window);\r\n    interceptAddEventListener(window.HTMLElement || window.Element);\r\n    interceptAddEventListener(document);\r\n    if (!navigator.isCocoonJS){\r\n        interceptAddEventListener(HTMLBodyElement);\r\n        interceptAddEventListener(HTMLDivElement);\r\n        interceptAddEventListener(HTMLImageElement);\r\n        interceptAddEventListener(HTMLUListElement);\r\n        interceptAddEventListener(HTMLAnchorElement);\r\n        interceptAddEventListener(HTMLLIElement);\r\n        interceptAddEventListener(HTMLTableElement);\r\n        if (window.HTMLSpanElement) {\r\n            interceptAddEventListener(HTMLSpanElement);\r\n        }\r\n    }\r\n    if (window.HTMLCanvasElement) {\r\n        interceptAddEventListener(HTMLCanvasElement);\r\n    }\r\n    if (!navigator.isCocoonJS && window.SVGElement) {\r\n        interceptAddEventListener(SVGElement);\r\n    }\r\n\r\n    interceptRemoveEventListener(window);\r\n    interceptRemoveEventListener(window.HTMLElement || window.Element);\r\n    interceptRemoveEventListener(document);\r\n    if (!navigator.isCocoonJS){\r\n        interceptRemoveEventListener(HTMLBodyElement);\r\n        interceptRemoveEventListener(HTMLDivElement);\r\n        interceptRemoveEventListener(HTMLImageElement);\r\n        interceptRemoveEventListener(HTMLUListElement);\r\n        interceptRemoveEventListener(HTMLAnchorElement);\r\n        interceptRemoveEventListener(HTMLLIElement);\r\n        interceptRemoveEventListener(HTMLTableElement);\r\n        if (window.HTMLSpanElement) {\r\n            interceptRemoveEventListener(HTMLSpanElement);\r\n        }\r\n    }\r\n    if (window.HTMLCanvasElement) {\r\n        interceptRemoveEventListener(HTMLCanvasElement);\r\n    }\r\n    if (!navigator.isCocoonJS && window.SVGElement) {\r\n        interceptRemoveEventListener(SVGElement);\r\n    }\r\n\r\n    // Prevent mouse event from being dispatched after Touch Events action\r\n    var touching = false;\r\n    var touchTimer = -1;\r\n\r\n    function setTouchTimer() {\r\n        touching = true;\r\n        clearTimeout(touchTimer);\r\n        touchTimer = setTimeout(function () {\r\n            touching = false;\r\n        }, 700);\r\n        // 1. Mobile browsers dispatch mouse events 300ms after touchend\r\n        // 2. Chrome for Android dispatch mousedown for long-touch about 650ms\r\n        // Result: Blocking Mouse Events for 700ms.\r\n    }\r\n\r\n    function getFirstCommonNode(x, y) {\r\n        while (x) {\r\n            if (x.contains(y))\r\n                return x;\r\n            x = x.parentNode;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    //generateProxy receives a node to dispatch the event\r\n    function dispatchPointerEnter(currentTarget, relatedTarget, generateProxy) {\r\n        var commonParent = getFirstCommonNode(currentTarget, relatedTarget);\r\n        var node = currentTarget;\r\n        var nodelist = [];\r\n        while (node && node !== commonParent) {//target range: this to the direct child of parent relatedTarget\r\n            if (checkEventRegistration(node, \"pointerenter\")) //check if any parent node has pointerenter\r\n                nodelist.push(node);\r\n            node = node.parentNode;\r\n        }\r\n        while (nodelist.length > 0)\r\n            generateProxy(nodelist.pop());\r\n    }\r\n\r\n    //generateProxy receives a node to dispatch the event\r\n    function dispatchPointerLeave(currentTarget, relatedTarget, generateProxy) {\r\n        var commonParent = getFirstCommonNode(currentTarget, relatedTarget);\r\n        var node = currentTarget;\r\n        while (node && node !== commonParent) {//target range: this to the direct child of parent relatedTarget\r\n            if (checkEventRegistration(node, \"pointerleave\"))//check if any parent node has pointerleave\r\n                generateProxy(node);\r\n            node = node.parentNode;\r\n        }\r\n    }\r\n    \r\n    // Handling events on window to prevent unwanted super-bubbling\r\n    // All mouse events are affected by touch fallback\r\n    function applySimpleEventTunnels(nameGenerator, eventGenerator) {\r\n        [\"pointerdown\", \"pointermove\", \"pointerup\", \"pointerover\", \"pointerout\"].forEach(function (eventName) {\r\n            window.addEventListener(nameGenerator(eventName), function (evt) {\r\n                if (!touching && findEventRegisteredNode(evt.target, eventName))\r\n                    eventGenerator(evt, eventName, true);\r\n            });\r\n        });\r\n        if (window['on' + nameGenerator(\"pointerenter\").toLowerCase()] === undefined)\r\n            window.addEventListener(nameGenerator(\"pointerover\"), function (evt) {\r\n                if (touching)\r\n                    return;\r\n                var foundNode = findEventRegisteredNode(evt.target, \"pointerenter\");\r\n                if (!foundNode || foundNode === window)\r\n                    return;\r\n                else if (!foundNode.contains(evt.relatedTarget)) {\r\n                    dispatchPointerEnter(foundNode, evt.relatedTarget, function (targetNode) {\r\n                        eventGenerator(evt, \"pointerenter\", false, targetNode, evt.relatedTarget);\r\n                    });\r\n                }\r\n            });\r\n        if (window['on' + nameGenerator(\"pointerleave\").toLowerCase()] === undefined)\r\n            window.addEventListener(nameGenerator(\"pointerout\"), function (evt) {\r\n                if (touching)\r\n                    return;\r\n                var foundNode = findEventRegisteredNode(evt.target, \"pointerleave\");\r\n                if (!foundNode || foundNode === window)\r\n                    return;\r\n                else if (!foundNode.contains(evt.relatedTarget)) {\r\n                    dispatchPointerLeave(foundNode, evt.relatedTarget, function (targetNode) {\r\n                        eventGenerator(evt, \"pointerleave\", false, targetNode, evt.relatedTarget);\r\n                    });\r\n                }\r\n            });\r\n    }\r\n\r\n    (function () {\r\n        if (window.MSPointerEvent) {\r\n            //IE 10\r\n            applySimpleEventTunnels(\r\n                function (name) { return getPrefixEventName(\"MS\", name); },\r\n                generateTouchClonedEvent);\r\n        }\r\n        else {\r\n            applySimpleEventTunnels(getMouseEquivalentEventName, generateMouseProxy);\r\n\r\n            // Handling move on window to detect pointerleave/out/over\r\n            if (window.ontouchstart !== undefined) {\r\n                window.addEventListener('touchstart', function (eventObject) {\r\n                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {\r\n                        var touchPoint = eventObject.changedTouches[i];\r\n                        previousTargets[touchPoint.identifier] = touchPoint.target;\r\n\r\n                        generateTouchEventProxyIfRegistered(\"pointerover\", touchPoint, touchPoint.target, eventObject, true);\r\n\r\n                        //pointerenter should not be bubbled\r\n                        dispatchPointerEnter(touchPoint.target, null, function (targetNode) {\r\n                            generateTouchEventProxy(\"pointerenter\", touchPoint, targetNode, eventObject, false);\r\n                        });\r\n\r\n                        generateTouchEventProxyIfRegistered(\"pointerdown\", touchPoint, touchPoint.target, eventObject, true);\r\n                    }\r\n                    setTouchTimer();\r\n                });\r\n\r\n                window.addEventListener('touchend', function (eventObject) {\r\n                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {\r\n                        var touchPoint = eventObject.changedTouches[i];\r\n                        var currentTarget = previousTargets[touchPoint.identifier];\r\n\r\n                        generateTouchEventProxyIfRegistered(\"pointerup\", touchPoint, currentTarget, eventObject, true);\r\n                        generateTouchEventProxyIfRegistered(\"pointerout\", touchPoint, currentTarget, eventObject, true);\r\n\r\n                        //pointerleave should not be bubbled\r\n                        dispatchPointerLeave(currentTarget, null, function (targetNode) {\r\n                            generateTouchEventProxy(\"pointerleave\", touchPoint, targetNode, eventObject, false);\r\n                        });\r\n                    }\r\n                    setTouchTimer();\r\n                });\r\n\r\n                window.addEventListener('touchmove', function (eventObject) {\r\n                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {\r\n                        var touchPoint = eventObject.changedTouches[i];\r\n                        var newTarget = document.elementFromPoint(touchPoint.clientX, touchPoint.clientY);\r\n                        var currentTarget = previousTargets[touchPoint.identifier];\r\n\r\n                        // If force preventDefault\r\n                        if (currentTarget && checkPreventDefault(currentTarget) === true)\r\n                            eventObject.preventDefault();\r\n\r\n                        generateTouchEventProxyIfRegistered(\"pointermove\", touchPoint, currentTarget, eventObject, true);\r\n                        if (!navigator.isCocoonJS){\r\n                            var newTarget = document.elementFromPoint(touchPoint.clientX, touchPoint.clientY);\r\n                            if (currentTarget === newTarget) {\r\n                                continue; // We can skip this as the pointer is effectively over the current target\r\n                            }\r\n\r\n                            if (currentTarget) {\r\n                                // Raise out\r\n                                generateTouchEventProxyIfRegistered(\"pointerout\", touchPoint, currentTarget, eventObject, true, newTarget);\r\n\r\n                                // Raise leave\r\n                                if (!currentTarget.contains(newTarget)) { // Leave must be called if the new target is not a child of the current\r\n                                    dispatchPointerLeave(currentTarget, newTarget, function (targetNode) {\r\n                                        generateTouchEventProxy(\"pointerleave\", touchPoint, targetNode, eventObject, false, newTarget);\r\n                                    });\r\n                                }\r\n                            }\r\n\r\n                            if (newTarget) {\r\n                                // Raise over\r\n                                generateTouchEventProxyIfRegistered(\"pointerover\", touchPoint, newTarget, eventObject, true, currentTarget);\r\n\r\n                                // Raise enter\r\n                                if (!newTarget.contains(currentTarget)) { // Leave must be called if the new target is not the parent of the current\r\n                                    dispatchPointerEnter(newTarget, currentTarget, function (targetNode) {\r\n                                        generateTouchEventProxy(\"pointerenter\", touchPoint, targetNode, eventObject, false, currentTarget);\r\n                                    })\r\n                                }\r\n                            }\r\n                            previousTargets[touchPoint.identifier] = newTarget;\r\n                        }\r\n                    }\r\n                    setTouchTimer();\r\n                });\r\n\r\n                window.addEventListener('touchcancel', function (eventObject) {\r\n                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {\r\n                        var touchPoint = eventObject.changedTouches[i];\r\n\r\n                        generateTouchEventProxyIfRegistered(\"pointercancel\", touchPoint, previousTargets[touchPoint.identifier], eventObject, true);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    })();\r\n    \r\n\r\n    // Extension to navigator\r\n    if (navigator.pointerEnabled === undefined) {\r\n\r\n        // Indicates if the browser will fire pointer events for pointing input\r\n        navigator.pointerEnabled = true;\r\n\r\n        // IE\r\n        if (navigator.msPointerEnabled) {\r\n            navigator.maxTouchPoints = navigator.msMaxTouchPoints;\r\n        }\r\n    }\r\n})();\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/handjs/hand.base.js\n ** module id = 26\n ** module chunks = 0\n **/","(function () {\n\n/*** Variables ***/\n\n  var win = window,\n    doc = document,\n    attrProto = {\n      setAttribute: Element.prototype.setAttribute,\n      removeAttribute: Element.prototype.removeAttribute\n    },\n    hasShadow = Element.prototype.createShadowRoot,\n    container = doc.createElement('div'),\n    noop = function(){},\n    trueop = function(){ return true; },\n    regexReplaceCommas = /,/g,\n    regexCamelToDash = /([a-z])([A-Z])/g,\n    regexPseudoParens = /\\(|\\)/g,\n    regexPseudoCapture = /:(\\w+)\\u276A(.+?(?=\\u276B))|:(\\w+)/g,\n    regexDigits = /(\\d+)/g,\n    keypseudo = {\n      action: function (pseudo, event) {\n        return pseudo.value.match(regexDigits).indexOf(String(event.keyCode)) > -1 == (pseudo.name == 'keypass') || null;\n      }\n    },\n    /*\n      - The prefix object generated here is added to the xtag object as xtag.prefix later in the code\n      - Prefix provides a variety of prefix variations for the browser in which your code is running\n      - The 4 variations of prefix are as follows:\n        * prefix.dom: the correct prefix case and form when used on DOM elements/style properties\n        * prefix.lowercase: a lowercase version of the prefix for use in various user-code situations\n        * prefix.css: the lowercase, dashed version of the prefix\n        * prefix.js: addresses prefixed APIs present in global and non-Element contexts\n    */\n    prefix = (function () {\n      var styles = win.getComputedStyle(doc.documentElement, ''),\n          pre = (Array.prototype.slice\n            .call(styles)\n            .join('')\n            .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])\n          )[1];\n      return {\n        dom: pre == 'ms' ? 'MS' : pre,\n        lowercase: pre,\n        css: '-' + pre + '-',\n        js: pre == 'ms' ? pre : pre[0].toUpperCase() + pre.substr(1)\n      };\n    })(),\n    matchSelector = Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype[prefix.lowercase + 'MatchesSelector'];\n\n  var issetCustomEvent = false;\n  var customEvent;\n  try {\n    customEvent = doc.createEvent('CustomEvent');\n    issetCustomEvent = true;\n  } catch(e) {\n    customEvent = doc.createEvent('Event');\n  }\n\n/*** Functions ***/\n\n// Utilities\n\n  /*\n    This is an enhanced typeof check for all types of objects. Where typeof would normaly return\n    'object' for many common DOM objects (like NodeLists and HTMLCollections).\n    - For example: typeOf(document.children) will correctly return 'htmlcollection'\n  */\n  var typeCache = {},\n      typeString = typeCache.toString,\n      typeRegexp = /\\s([a-zA-Z]+)/;\n  function typeOf(obj) {\n    var type = typeString.call(obj);\n    return typeCache[type] || (typeCache[type] = type.match(typeRegexp)[1].toLowerCase());\n  }\n\n  function clone(item, type){\n    var fn = clone[type || typeOf(item)];\n    return fn ? fn(item) : item;\n  }\n    clone.object = function(src){\n      var obj = {};\n      for (var key in src) obj[key] = clone(src[key]);\n      return obj;\n    };\n    clone.array = function(src){\n      var i = src.length, array = new Array(i);\n      while (i--) array[i] = clone(src[i]);\n      return array;\n    };\n\n  /*\n    The toArray() method allows for conversion of any object to a true array. For types that\n    cannot be converted to an array, the method returns a 1 item array containing the passed-in object.\n  */\n  var unsliceable = { 'undefined': 1, 'null': 1, 'number': 1, 'boolean': 1, 'string': 1, 'function': 1 };\n  function toArray(obj){\n    return unsliceable[typeOf(obj)] ? [obj] : Array.prototype.slice.call(obj, 0);\n  }\n\n// DOM\n\n  var str = '';\n  function query(element, selector){\n    return (selector || str).length ? toArray(element.querySelectorAll(selector)) : [];\n  }\n\n// Pseudos\n\n  function parsePseudo(fn){fn();}\n\n// Mixins\n\n  function mergeOne(source, key, current){\n    var type = typeOf(current);\n    if (type == 'object' && typeOf(source[key]) == 'object') xtag.merge(source[key], current);\n    else source[key] = clone(current, type);\n    return source;\n  }\n\n  function mergeMixin(tag, original, mixin, name) {\n    var key, keys = {};\n    for (var z in original) keys[z.split(':')[0]] = z;\n    for (z in mixin) {\n      key = keys[z.split(':')[0]];\n      if (typeof original[key] == 'function') {\n        if (!key.match(':mixins')) {\n          original[key + ':mixins'] = original[key];\n          delete original[key];\n          key = key + ':mixins';\n        }\n        original[key].__mixin__ = xtag.applyPseudos(z + (z.match(':mixins') ? '' : ':mixins'), mixin[z], tag.pseudos, original[key].__mixin__);\n      }\n      else {\n        original[z] = mixin[z];\n        delete original[key];\n      }\n    }\n  }\n\n  var uniqueMixinCount = 0;\n  function addMixin(tag, original, mixin){\n    for (var z in mixin){\n      original[z + ':__mixin__(' + (uniqueMixinCount++) + ')'] = xtag.applyPseudos(z, mixin[z], tag.pseudos);\n    }\n  }\n\n  function resolveMixins(mixins, output){\n    var index = mixins.length;\n    while (index--){\n      output.unshift(mixins[index]);\n      if (xtag.mixins[mixins[index]].mixins) resolveMixins(xtag.mixins[mixins[index]].mixins, output);\n    }\n    return output;\n  }\n\n  function applyMixins(tag) {\n    resolveMixins(tag.mixins, []).forEach(function(name){\n      var mixin = xtag.mixins[name];\n      for (var type in mixin) {\n        var item = mixin[type],\n            original = tag[type];\n        if (!original) tag[type] = item;\n        else {\n          switch (type){\n            case 'mixins': break;\n            case 'events': addMixin(tag, original, item); break;\n            case 'accessors':\n            case 'prototype':\n              for (var z in item) {\n                if (!original[z]) original[z] = item[z];\n                else mergeMixin(tag, original[z], item[z], name);\n              }\n              break;\n            default: mergeMixin(tag, original, item, name);\n          }\n        }\n      }\n    });\n    return tag;\n  }\n\n// Events\n\n  function delegateAction(pseudo, event) {\n    var match,\n        target = event.target,\n        root = event.currentTarget;\n    while (!match && target && target != root) {\n      if (target.tagName && matchSelector.call(target, pseudo.value)) match = target;\n      target = target.parentNode;\n    }\n    if (!match && root.tagName && matchSelector.call(root, pseudo.value)) match = root;\n    return match ? pseudo.listener = pseudo.listener.bind(match) : null;\n  }\n\n  function touchFilter(event){\n    return event.button === 0;\n  }\n\n  function writeProperty(key, event, base, desc){\n    if (desc) event[key] = base[key];\n    else Object.defineProperty(event, key, {\n      writable: true,\n      enumerable: true,\n      value: base[key]\n    });\n  }\n\n  var skipProps = {};\n  for (var z in customEvent) skipProps[z] = 1;\n  function inheritEvent(event, base){\n    var desc = Object.getOwnPropertyDescriptor(event, 'target');\n    for (var z in base) {\n      if (!skipProps[z]) writeProperty(z, event, base, desc);\n    }\n    event.baseEvent = base;\n  }\n\n// Accessors\n\n  function modAttr(element, attr, name, value, method){\n    attrProto[method].call(element, name, attr && attr.boolean ? '' : value);\n  }\n\n  function syncAttr(element, attr, name, value, method){\n    if (attr && (attr.property || attr.selector)) {\n      var nodes = attr.property ? [element.xtag[attr.property]] : attr.selector ? xtag.query(element, attr.selector) : [],\n          index = nodes.length;\n      while (index--) nodes[index][method](name, value);\n    }\n  }\n\n  function attachProperties(tag, prop, z, accessor, attr, name){\n    var key = z.split(':'), type = key[0];\n    if (type == 'get') {\n      key[0] = prop;\n      tag.prototype[prop].get = xtag.applyPseudos(key.join(':'), accessor[z], tag.pseudos, accessor[z]);\n    }\n    else if (type == 'set') {\n      key[0] = prop;\n      var setter = tag.prototype[prop].set = xtag.applyPseudos(key.join(':'), attr ? function(value){\n        var old, method = 'setAttribute';\n        if (attr.boolean){\n          value = !!value;\n          old = this.hasAttribute(name);\n          if (!value) method = 'removeAttribute';\n        }\n        else {\n          value = attr.validate ? attr.validate.call(this, value) : value;\n          old = this.getAttribute(name);\n        }\n        modAttr(this, attr, name, value, method);\n        accessor[z].call(this, value, old);\n        syncAttr(this, attr, name, value, method);\n      } : accessor[z] ? function(value){\n        accessor[z].call(this, value);\n      } : null, tag.pseudos, accessor[z]);\n\n      if (attr) attr.setter = accessor[z];\n    }\n    else tag.prototype[prop][z] = accessor[z];\n  }\n\n  function parseAccessor(tag, prop){\n    tag.prototype[prop] = {};\n    var accessor = tag.accessors[prop],\n        attr = accessor.attribute,\n        name;\n\n    if (attr) {\n      name = attr.name = (attr ? (attr.name || prop.replace(regexCamelToDash, '$1-$2')) : prop).toLowerCase();\n      attr.key = prop;\n      tag.attributes[name] = attr;\n    }\n\n    for (var z in accessor) attachProperties(tag, prop, z, accessor, attr, name);\n\n    if (attr) {\n      if (!tag.prototype[prop].get) {\n        var method = (attr.boolean ? 'has' : 'get') + 'Attribute';\n        tag.prototype[prop].get = function(){\n          return this[method](name);\n        };\n      }\n      if (!tag.prototype[prop].set) tag.prototype[prop].set = function(value){\n        value = attr.boolean ? !!value : attr.validate ? attr.validate.call(this, value) : value;\n        var method = attr.boolean ? (value ? 'setAttribute' : 'removeAttribute') : 'setAttribute';\n        modAttr(this, attr, name, value, method);\n        syncAttr(this, attr, name, value, method);\n      };\n    }\n  }\n\n  var unwrapComment = /\\/\\*!?(?:\\@preserve)?[ \\t]*(?:\\r\\n|\\n)([\\s\\S]*?)(?:\\r\\n|\\n)\\s*\\*\\//;\n  function parseMultiline(fn){\n    return typeof fn == 'function' ? unwrapComment.exec(fn.toString())[1] : fn;\n  }\n\n/*** X-Tag Object Definition ***/\n\n  var xtag = {\n    tags: {},\n    defaultOptions: {\n      pseudos: [],\n      mixins: [],\n      events: {},\n      methods: {},\n      accessors: {},\n      lifecycle: {},\n      attributes: {},\n      'prototype': {\n        xtag: {\n          get: function(){\n            return this.__xtag__ ? this.__xtag__ : (this.__xtag__ = { data: {} });\n          }\n        }\n      }\n    },\n    register: function (name, options) {\n      var _name;\n      if (typeof name == 'string') _name = name.toLowerCase();\n      else throw 'First argument must be a Custom Element string name';\n      xtag.tags[_name] = options || {};\n\n      var basePrototype = options.prototype;\n      delete options.prototype;\n      var tag = xtag.tags[_name].compiled = applyMixins(xtag.merge({}, xtag.defaultOptions, options));\n\n      for (var z in tag.events) tag.events[z] = xtag.parseEvent(z, tag.events[z]);\n      for (z in tag.lifecycle) tag.lifecycle[z.split(':')[0]] = xtag.applyPseudos(z, tag.lifecycle[z], tag.pseudos, tag.lifecycle[z]);\n      for (z in tag.methods) tag.prototype[z.split(':')[0]] = { value: xtag.applyPseudos(z, tag.methods[z], tag.pseudos, tag.methods[z]), enumerable: true };\n      for (z in tag.accessors) parseAccessor(tag, z);\n\n      if (tag.shadow) tag.shadow = tag.shadow.nodeName ? tag.shadow : xtag.createFragment(tag.shadow);\n      if (tag.content) tag.content = tag.content.nodeName ? tag.content.innerHTML : parseMultiline(tag.content);\n      var created = tag.lifecycle.created;\n      var finalized = tag.lifecycle.finalized;\n      tag.prototype.createdCallback = {\n        enumerable: true,\n        value: function(){\n          var element = this;\n          if (tag.shadow && hasShadow) this.createShadowRoot().appendChild(tag.shadow.cloneNode(true));\n          if (tag.content) this.appendChild(document.createElement('div')).outerHTML = tag.content;\n          var output = created ? created.apply(this, arguments) : null;\n          xtag.addEvents(this, tag.events);\n          for (var name in tag.attributes) {\n            var attr = tag.attributes[name],\n                hasAttr = this.hasAttribute(name),\n                hasDefault = attr.def !== undefined;\n            if (hasAttr || attr.boolean || hasDefault) {\n              this[attr.key] = attr.boolean ? hasAttr : !hasAttr && hasDefault ? attr.def : this.getAttribute(name);\n            }\n          }\n          tag.pseudos.forEach(function(obj){\n            obj.onAdd.call(element, obj);\n          });\n          this.xtagComponentReady = true;\n          if (finalized) finalized.apply(this, arguments);\n          return output;\n        }\n      };\n\n      var inserted = tag.lifecycle.inserted,\n          removed = tag.lifecycle.removed;\n      if (inserted || removed) {\n        tag.prototype.attachedCallback = { value: function(){\n          if (removed) this.xtag.__parentNode__ = this.parentNode;\n          if (inserted) return inserted.apply(this, arguments);\n        }, enumerable: true };\n      }\n      if (removed) {\n        tag.prototype.detachedCallback = { value: function(){\n          var args = toArray(arguments);\n          args.unshift(this.xtag.__parentNode__);\n          var output = removed.apply(this, args);\n          delete this.xtag.__parentNode__;\n          return output;\n        }, enumerable: true };\n      }\n      if (tag.lifecycle.attributeChanged) tag.prototype.attributeChangedCallback = { value: tag.lifecycle.attributeChanged, enumerable: true };\n\n      tag.prototype.setAttribute = {\n        writable: true,\n        enumerable: true,\n        value: function (name, value){\n          var old;\n          var _name = name.toLowerCase();\n          var attr = tag.attributes[_name];\n          if (attr) {\n            old = this.getAttribute(_name);\n            value = attr.boolean ? '' : attr.validate ? attr.validate.call(this, value) : value;\n          }\n          modAttr(this, attr, _name, value, 'setAttribute');\n          if (attr) {\n            if (attr.setter) attr.setter.call(this, attr.boolean ? true : value, old);\n            syncAttr(this, attr, _name, value, 'setAttribute');\n          }\n        }\n      };\n\n      tag.prototype.removeAttribute = {\n        writable: true,\n        enumerable: true,\n        value: function (name){\n          var _name = name.toLowerCase();\n          var attr = tag.attributes[_name];\n          var old = this.hasAttribute(_name);\n          modAttr(this, attr, _name, '', 'removeAttribute');\n          if (attr) {\n            if (attr.setter) attr.setter.call(this, attr.boolean ? false : undefined, old);\n            syncAttr(this, attr, _name, '', 'removeAttribute');\n          }\n        }\n      };\n\n      var elementProto = basePrototype ?\n            basePrototype :\n            tag['extends'] ?\n            Object.create(doc.createElement(tag['extends']).constructor).prototype :\n            win.HTMLElement.prototype;\n\n      var definition = {\n        'prototype': Object.create(elementProto, tag.prototype)\n      };\n      if (tag['extends']) {\n        definition['extends'] = tag['extends'];\n      }\n      var reg = doc.registerElement(_name, definition);\n      return reg;\n    },\n\n    /* Exposed Variables */\n\n    mixins: {},\n    prefix: prefix,\n    captureEvents: { focus: 1, blur: 1, scroll: 1, DOMMouseScroll: 1 },\n    customEvents: {\n      animationstart: {\n        attach: [prefix.dom + 'AnimationStart']\n      },\n      animationend: {\n        attach: [prefix.dom + 'AnimationEnd']\n      },\n      transitionend: {\n        attach: [prefix.dom + 'TransitionEnd']\n      },\n      move: {\n        attach: ['pointermove']\n      },\n      enter: {\n        attach: ['pointerenter']\n      },\n      leave: {\n        attach: ['pointerleave']\n      },\n      scrollwheel: {\n        attach: ['DOMMouseScroll', 'mousewheel'],\n        condition: function(event){\n          event.delta = event.wheelDelta ? event.wheelDelta / 40 : Math.round(event.detail / 3.5 * -1);\n          return true;\n        }\n      },\n      tap: {\n        attach: ['pointerdown', 'pointerup'],\n        condition: function(event, custom){\n          if (event.type == 'pointerdown') {\n            custom.startX = event.clientX;\n            custom.startY = event.clientY;\n          }\n          else if (event.button === 0 &&\n                   Math.abs(custom.startX - event.clientX) < 10 &&\n                   Math.abs(custom.startY - event.clientY) < 10) return true;\n        }\n      },\n      tapstart: {\n        attach: ['pointerdown'],\n        condition: touchFilter\n      },\n      tapend: {\n        attach: ['pointerup'],\n        condition: touchFilter\n      },\n      tapmove: {\n        attach: ['pointerdown', 'pointerup'],\n        condition: function(event, custom){\n          if (event.type == 'pointerdown') {\n            if (!custom.moveListener) custom.moveListener = xtag.addEvent(this, 'pointermove', custom.listener);\n          }\n          else if (event.type == 'pointerup') {\n            xtag.removeEvent(this, custom.moveListener);\n            custom.moveListener = null;\n          }\n          else return true;\n        }\n      },\n      taphold: {\n        attach: ['pointerdown', 'pointerup'],\n        condition: function(event, custom){\n          if (event.type == 'pointerdown') {\n            (custom.pointers = custom.pointers || {})[event.pointerId] = setTimeout(\n              xtag.fireEvent.bind(null, this, 'taphold'),\n              custom.duration || 1000\n            );\n          }\n          else if (event.type == 'pointerup') {\n            if (custom.pointers) {\n              clearTimeout(custom.pointers[event.pointerId]);\n              delete custom.pointers[event.pointerId];\n            }\n          }\n          else return true;\n        }\n      }\n    },\n    pseudos: {\n      __mixin__: {},\n      mixins: {\n        onCompiled: function(fn, pseudo){\n          var mixin = pseudo.source && pseudo.source.__mixin__ || pseudo.source;\n          if (mixin) switch (pseudo.value) {\n            case null: case '': case 'before': return function(){\n              mixin.apply(this, arguments);\n              return fn.apply(this, arguments);\n            };\n            case 'after': return function(){\n              var returns = fn.apply(this, arguments);\n              mixin.apply(this, arguments);\n              return returns;\n            };\n            case 'none': return fn;\n          }\n          else return fn;\n        }\n      },\n      keypass: keypseudo,\n      keyfail: keypseudo,\n      delegate: {\n        action: delegateAction\n      },\n      preventable: {\n        action: function (pseudo, event) {\n          return !event.defaultPrevented;\n        }\n      },\n      duration: {\n        onAdd: function(pseudo){\n          pseudo.source.duration = Number(pseudo.value);\n        }\n      },\n      capture: {\n        onCompiled: function(fn, pseudo){\n          if (pseudo.source) pseudo.source.capture = true;\n        }\n      }\n    },\n\n    /* UTILITIES */\n\n    clone: clone,\n    typeOf: typeOf,\n    toArray: toArray,\n\n    wrap: function (original, fn) {\n      return function(){\n        var output = original.apply(this, arguments);\n        fn.apply(this, arguments);\n        return output;\n      };\n    },\n    /*\n      Recursively merges one object with another. The first argument is the destination object,\n      all other objects passed in as arguments are merged from right to left, conflicts are overwritten\n    */\n    merge: function(source, k, v){\n      if (typeOf(k) == 'string') return mergeOne(source, k, v);\n      for (var i = 1, l = arguments.length; i < l; i++){\n        var object = arguments[i];\n        for (var key in object) mergeOne(source, key, object[key]);\n      }\n      return source;\n    },\n\n    /*\n      ----- This should be simplified! -----\n      Generates a random ID string\n    */\n    uid: function(){\n      return Math.random().toString(36).substr(2,10);\n    },\n\n    /* DOM */\n\n    query: query,\n\n    skipTransition: function(element, fn, bind){\n      var prop = prefix.js + 'TransitionProperty';\n      element.style[prop] = element.style.transitionProperty = 'none';\n      var callback = fn ? fn.call(bind || element) : null;\n      return xtag.skipFrame(function(){\n        element.style[prop] = element.style.transitionProperty = '';\n        if (callback) callback.call(bind || element);\n      });\n    },\n\n    requestFrame: (function(){\n      var raf = win.requestAnimationFrame ||\n                win[prefix.lowercase + 'RequestAnimationFrame'] ||\n                function(fn){ return win.setTimeout(fn, 20); };\n      return function(fn){ return raf(fn); };\n    })(),\n\n    cancelFrame: (function(){\n      var cancel = win.cancelAnimationFrame ||\n                   win[prefix.lowercase + 'CancelAnimationFrame'] ||\n                   win.clearTimeout;\n      return function(id){ return cancel(id); };\n    })(),\n\n    skipFrame: function(fn){\n      var id = xtag.requestFrame(function(){ id = xtag.requestFrame(fn); });\n      return id;\n    },\n\n    matchSelector: function (element, selector) {\n      return matchSelector.call(element, selector);\n    },\n\n    set: function (element, method, value) {\n      element[method] = value;\n      if (window.CustomElements) CustomElements.upgradeAll(element);\n    },\n\n    innerHTML: function(el, html){\n      xtag.set(el, 'innerHTML', html);\n    },\n\n    hasClass: function (element, klass) {\n      return element.className.split(' ').indexOf(klass.trim())>-1;\n    },\n\n    addClass: function (element, klass) {\n      var list = element.className.trim().split(' ');\n      klass.trim().split(' ').forEach(function (name) {\n        if (!~list.indexOf(name)) list.push(name);\n      });\n      element.className = list.join(' ').trim();\n      return element;\n    },\n\n    removeClass: function (element, klass) {\n      var classes = klass.trim().split(' ');\n      element.className = element.className.trim().split(' ').filter(function (name) {\n        return name && !~classes.indexOf(name);\n      }).join(' ');\n      return element;\n    },\n\n    toggleClass: function (element, klass) {\n      return xtag[xtag.hasClass(element, klass) ? 'removeClass' : 'addClass'].call(null, element, klass);\n    },\n\n    /*\n      Runs a query on only the children of an element\n    */\n    queryChildren: function (element, selector) {\n      var id = element.id,\n          attr = '#' + (element.id = id || 'x_' + xtag.uid()) + ' > ',\n          parent = element.parentNode || !container.appendChild(element);\n      selector = attr + (selector + '').replace(regexReplaceCommas, ',' + attr);\n      var result = element.parentNode.querySelectorAll(selector);\n      if (!id) element.removeAttribute('id');\n      if (!parent) container.removeChild(element);\n      return toArray(result);\n    },\n\n    /*\n      Creates a document fragment with the content passed in - content can be\n      a string of HTML, an element, or an array/collection of elements\n    */\n    createFragment: function(content) {\n      var template = document.createElement('template');\n      if (content) {\n        if (content.nodeName) toArray(arguments).forEach(function(e){\n          template.content.appendChild(e);\n        });\n        else template.innerHTML = parseMultiline(content);\n      }\n      return template.content;\n    },\n\n    /*\n      Removes an element from the DOM for more performant node manipulation. The element\n      is placed back into the DOM at the place it was taken from.\n    */\n    manipulate: function(element, fn){\n      var next = element.nextSibling,\n          parent = element.parentNode,\n          returned = fn.call(element) || element;\n      if (next) parent.insertBefore(returned, next);\n      else parent.appendChild(returned);\n    },\n\n    /* PSEUDOS */\n\n    applyPseudos: function(key, fn, target, source) {\n      var listener = fn,\n          pseudos = {};\n      if (key.match(':')) {\n        var matches = [],\n            valueFlag = 0;\n        key.replace(regexPseudoParens, function(match){\n          if (match == '(') return ++valueFlag == 1 ? '\\u276A' : '(';\n          return !--valueFlag ? '\\u276B' : ')';\n        }).replace(regexPseudoCapture, function(z, name, value, solo){\n          matches.push([name || solo, value]);\n        });\n        var i = matches.length;\n        while (i--) parsePseudo(function(){\n          var name = matches[i][0],\n              value = matches[i][1];\n          if (!xtag.pseudos[name]) throw \"pseudo not found: \" + name + \" \" + value;\n          value = (value === '' || typeof value == 'undefined') ? null : value;\n          var pseudo = pseudos[i] = Object.create(xtag.pseudos[name]);\n          pseudo.key = key;\n          pseudo.name = name;\n          pseudo.value = value;\n          pseudo['arguments'] = (value || '').split(',');\n          pseudo.action = pseudo.action || trueop;\n          pseudo.source = source;\n          pseudo.onAdd = pseudo.onAdd || noop;\n          pseudo.onRemove = pseudo.onRemove || noop;\n          var original = pseudo.listener = listener;\n          listener = function(){\n            var output = pseudo.action.apply(this, [pseudo].concat(toArray(arguments)));\n            if (output === null || output === false) return output;\n            output = pseudo.listener.apply(this, arguments);\n            pseudo.listener = original;\n            return output;\n          };\n          if (!target) pseudo.onAdd.call(fn, pseudo);\n          else target.push(pseudo);\n        });\n      }\n      for (var z in pseudos) {\n        if (pseudos[z].onCompiled) listener = pseudos[z].onCompiled(listener, pseudos[z]) || listener;\n      }\n      return listener;\n    },\n\n    removePseudos: function(target, pseudos){\n      pseudos.forEach(function(obj){\n        obj.onRemove.call(target, obj);\n      });\n    },\n\n  /*** Events ***/\n\n    parseEvent: function(type, fn) {\n      var pseudos = type.split(':'),\n          key = pseudos.shift(),\n          custom = xtag.customEvents[key],\n          event = xtag.merge({\n            type: key,\n            stack: noop,\n            condition: trueop,\n            capture: xtag.captureEvents[key],\n            attach: [],\n            _attach: [],\n            pseudos: '',\n            _pseudos: [],\n            onAdd: noop,\n            onRemove: noop\n          }, custom || {});\n      event.attach = toArray(event.base || event.attach);\n      event.chain = key + (event.pseudos.length ? ':' + event.pseudos : '') + (pseudos.length ? ':' + pseudos.join(':') : '');\n      var stack = xtag.applyPseudos(event.chain, fn, event._pseudos, event);\n      event.stack = function(e){\n        e.currentTarget = e.currentTarget || this;\n        var detail = e.detail || {};\n        if (!detail.__stack__) return stack.apply(this, arguments);\n        else if (detail.__stack__ == stack) {\n          e.stopPropagation();\n          e.cancelBubble = true;\n          return stack.apply(this, arguments);\n        }\n      };\n      event.listener = function(e){\n        var args = toArray(arguments),\n            output = event.condition.apply(this, args.concat([event]));\n        if (!output) return output;\n        // The second condition in this IF is to address the following Blink regression: https://code.google.com/p/chromium/issues/detail?id=367537\n        // Remove this when affected browser builds with this regression fall below 5% marketshare\n        if (e.type != key && (e.baseEvent && e.type != e.baseEvent.type)) {\n          xtag.fireEvent(e.target, key, {\n            baseEvent: e,\n            detail: output !== true && (output.__stack__ = stack) ? output : { __stack__: stack }\n          });\n        }\n        else return event.stack.apply(this, args);\n      };\n      event.attach.forEach(function(name) {\n        event._attach.push(xtag.parseEvent(name, event.listener));\n      });\n      return event;\n    },\n\n    addEvent: function (element, type, fn, capture) {\n      var event = typeof fn == 'function' ? xtag.parseEvent(type, fn) : fn;\n      event._pseudos.forEach(function(obj){\n        obj.onAdd.call(element, obj);\n      });\n      event._attach.forEach(function(obj) {\n        xtag.addEvent(element, obj.type, obj);\n      });\n      event.onAdd.call(element, event, event.listener);\n      element.addEventListener(event.type, event.stack, capture || event.capture);\n      return event;\n    },\n\n    addEvents: function (element, obj) {\n      var events = {};\n      for (var z in obj) {\n        events[z] = xtag.addEvent(element, z, obj[z]);\n      }\n      return events;\n    },\n\n    removeEvent: function (element, type, event) {\n      event = event || type;\n      event.onRemove.call(element, event, event.listener);\n      xtag.removePseudos(element, event._pseudos);\n      event._attach.forEach(function(obj) {\n        xtag.removeEvent(element, obj);\n      });\n      element.removeEventListener(event.type, event.stack, false);\n    },\n\n    removeEvents: function(element, obj){\n      for (var z in obj) xtag.removeEvent(element, obj[z]);\n    },\n\n    fireEvent: function(element, type, options){\n      options = options || {};\n\n      var event;\n      var bubbles = options.bubbles !== false;\n      var cancelable = options.cancelable !== false;\n\n      if (issetCustomEvent) {\n        event = doc.createEvent('CustomEvent');\n        event.initCustomEvent(type, bubbles, cancelable, options.detail);\n\n      } else {\n        event = doc.createEvent('Event');\n        event.initEvent(type, bubbles, cancelable);\n        event.detail = options.detail;\n      }\n\n      if (options.baseEvent) inheritEvent(event, options.baseEvent);\n\n      element.dispatchEvent(event);\n    }\n  };\n\n  if (typeof define === 'function' && define.amd) define(xtag);\n  else if (typeof module !== 'undefined' && module.exports) module.exports = xtag;\n  else win.xtag = xtag;\n\n  doc.addEventListener('WebComponentsReady', function(){\n    xtag.fireEvent(doc.body, 'DOMComponentsLoaded');\n  }, false);\n\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/x-tag/src/core.js\n ** module id = 27\n ** module chunks = 0\n **/"],"sourceRoot":""}